#!/bin/bash -e

# 터미널 색상 정의, URL 파라미터 정리 (공백제거, 마지막 / 제거)
RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BLUE='\033[0;34m' NC='\033[0m'
line="------------------------------------------------------------------------------------------------------"
bar() { printf "\n\n${!1}%s%s ${NC}\n" "${2:+[$2] }" "${line:(${2:+3}+${#2})}" ;}
log() { echo -e "${!1}$2${NC}"; }

PARAM1=${PARAM1:=$1}
PARAM1="${PARAM1%/}"

# Jenkins 서버 번호 추출 (jenkins03, jenkins06 등)
[[ ${PARAM1} =~ jenkins([0-9]+) ]] || { echo "Invalid job URL"; exit 1; }
JEN_NUM="KEY_JENKINS${BASH_REMATCH[1]}"
JENKINS_API_KEYS="${!JEN_NUM}"

# Jenkins 서버 URL 검증 및 서버명 추출
[ -z "${PARAM1}" ] && { log RED "Error: URL required"; exit 1; }
if [[ "${PARAM1}" =~ ^https?://[^/]+/(jenkins[0-9]+)/.*job/.*/[0-9]+$ ]]; then
    JENKINS_SERVER="${BASH_REMATCH[1]}"
else
    log RED "Invalid URL format"; exit 1
fi
JENKINS_API_KEY="${JENKINS_API_KEYS[${JENKINS_SERVER}]}"
[ -z "${JENKINS_API_KEY}" ] && bar YELLOW "No API key for ${JENKINS_SERVER}"


## 빌드 로그 다운로드 (타임스탬프 포함)
LOG_FILE="/tmp/console_${BUILD_NUMBER}.txt"
log BLUE "Processing: ${PARAM1}"
wget --no-check-certificate -q -O "${LOG_FILE}" "${PARAM1}/timestamps/?time=HH:mm:ss&timeZone=GMT+9&appendLog" || { bar RED "Download failed"; exit 1; }
[ -s "${LOG_FILE}" ] || { bar RED "Empty log"; exit 1; }
log GREEN "Downloaded $(wc -l < "${LOG_FILE}" | tr -d ' ') lines"

log BLUE "========================================\nYocto Build Error Analysis\n========================================"

## Step 0: 빌드 결과 출력 (SUCCESS면 분석 불필요)
bar YELLOW "Step 0: Build result"
BUILD_RESULT=$(grep -E "Finished: (SUCCESS|FAILURE|ABORTED|UNSTABLE)" "${LOG_FILE}" | tail -1)
echo "Status: ${BUILD_RESULT}"

# ABORTED 원인 확인
if [[ "${BUILD_RESULT}" =~ ABORTED ]]; then
    ABORT_REASON=$(grep -E "(timed out|Aborted by user|Terminated|Killed)" "${LOG_FILE}" | tail -1)
    [ -n "${ABORT_REASON}" ] && log RED "Abort reason: ${ABORT_REASON}"
fi

[[ "${BUILD_RESULT}" =~ SUCCESS ]] && { bar GREEN "Success - no analysis"; rm -f "${LOG_FILE}"; exit 0; }
log RED "Failed"


## Step 1: 다양한 에러에 대한 전체개수 카운트 (오탐 필터링)
bar YELLOW "Step 1: Error count"
GREP_FILTER="grep -v 'new branch.*error' | grep -v '\[[ =]\{2,\} error:' | grep -v '0 errors' | grep -v 'libgpg-error.*bb:do_'"
ERROR_COUNT=$(grep -i "ERROR" "${LOG_FILE}" | eval ${GREP_FILTER} | wc -l | tr -d ' ')
FAILED_COUNT=$(grep -i "FAILED" "${LOG_FILE}" | grep -v "0 skipped, 0 failed" | wc -l | tr -d ' ')
FATAL_COUNT=$(grep -i "fatal error" "${LOG_FILE}" | wc -l | tr -d ' ')
ERROR_LINES=$(grep -n -i "ERROR" "${LOG_FILE}" | eval ${GREP_FILTER} | head -10)
echo "ERROR: ${ERROR_COUNT}, FAILED: ${FAILED_COUNT}, FATAL: ${FATAL_COUNT}"


## Step 2: 실패한 Yocto 태스크 계층 구조 (do_build → do_compile → do_fetch)
bar YELLOW "Step 2: Task hierarchy"
FAILED_TASKS=$(grep -B 5 -i "ERROR" "${LOG_FILE}" | grep -v "new branch.*error" | grep -o "do_[a-z_]*" | sort -u)

if [ -n "${FAILED_TASKS}" ]; then
    # 태스크 계층 정의: "들여쓰기:태스크명들"
    HIERARCHY=(
        "0:do_build"
        "2:do_image do_rootfs do_testimage"
        "4:do_package_write_ipk do_package_write_rpm do_package_write_deb"
        "6:do_packagedata do_package_qa"
        "8:do_package"
        "10:do_populate_sysroot do_install"
        "12:do_compile do_compile_ptest_base"
        "14:do_configure"
        "16:do_patch do_unpack"
        "18:do_fetch"
    )

    # 최종 실패한 task를 미리 찾고
    LAST_FAILED_TASK=""
    for entry in "${HIERARCHY[@]}"; do
        indent="${entry%%:*}"
        tasks="${entry#*:}"
        for task in $tasks; do
            if echo "${FAILED_TASKS}" | grep -q "$task"; then
                LAST_FAILED_TASK="$task"
            fi
        done
    done

    # 하나씩 출력하면서 최종 실패한 task가 나올때 빨간색으로 표기
    for entry in "${HIERARCHY[@]}"; do
        indent="${entry%%:*}"
        tasks="${entry#*:}"
        for task in $tasks; do
            if echo "${FAILED_TASKS}" | grep -q "$task"; then
                if [ "$task" = "$LAST_FAILED_TASK" ]; then
                    printf "${RED}%*s>> %s${NC}\n\n" $indent "" "$task"
                else
                    printf "%*s>> %s\n" $indent "" "$task"
                fi
            fi
        done
    done
else
    echo "No failed tasks\n\n"
fi


## Step 3: 실패한 레시피 파일 (.bb)
bar YELLOW "Step 3: Failed recipes"
# 실제 Task failed 에러에서 레시피 추출
FAILED_RECIPES=$(grep -E "ERROR: Task.*failed" "${LOG_FILE}" | grep -Eo "[a-z0-9_-]+_[0-9]+\.[0-9]+.*\.bb" | sort -u | head -5)

if [ -n "${FAILED_RECIPES}" ]; then
    log RED "$(echo "$FAILED_RECIPES")"
else
    # ABORTED 빌드인 경우 timeout 유발한 fetch 태스크 찾기
    if [[ "${BUILD_RESULT}" =~ ABORTED ]]; then
        echo "No task failures (build was aborted)"

        # 마지막 Started된 do_fetch 태스크 찾기
        LAST_FETCH=$(grep "do_fetch: Started" "${LOG_FILE}" | tail -1)
        if [ -n "${LAST_FETCH}" ]; then
            FETCH_RECIPE=$(echo "${LAST_FETCH}" | grep -oE "recipe [a-z0-9_-]+-[0-9]+\.[0-9]+[^:]*" | cut -d' ' -f2)
            FETCH_TIME=$(echo "${LAST_FETCH}" | awk '{print $1}')

            # Succeeded 확인
            if ! grep -q "${FETCH_RECIPE}.*do_fetch: Succeeded" "${LOG_FILE}"; then
                echo -e "\n${RED}Timeout likely caused by:${NC}"
                echo "  Recipe: ${FETCH_RECIPE%.bb}.bb"
                echo "  Task: do_fetch (started at ${FETCH_TIME}, never completed)"
                echo ""
            fi
        fi
    else
        echo "None found\n"
    fi
fi

set -x
## Step 4: 핵심 실패 지점 (ERROR 발생 라인의 앞5줄, 뒤 10줄 컨텍스트 출력)
bar YELLOW "Step 4: Failure points"
FAILURE_POINT=$(grep -nE "(ERROR: Task.*failed|ERROR: Function failed|returned non-zero exit status|Build timed out|Aborted by)" "${LOG_FILE}" | grep -v "\[PostBuildScript\]" | tail -5)

if [ -n "${FAILURE_POINT}" ]; then
    echo "${FAILURE_POINT}" | while IFS=: read -r line_num rest; do
        [ -n "${line_num}" ] && [ "${line_num}" -gt 0 ] 2>/dev/null && {
            log GREEN "=== Line ${line_num} Time ${rest:0:8} ==="
            start=$((line_num-5))
            end=$((line_num+10))
            sed -n "${start},${end}p" "${LOG_FILE}" | awk -v target=$((line_num-start+1)) -v red="${RED}" -v nc="${NC}" 'NR==target {print red $0 nc} NR!=target {print}'
            echo
        }
    done
else
    echo "None found\n"
fi


## Step 5: 상세 error 출력

bar YELLOW "Step 5: detail error"
ERROR_LOG_FILES=$(grep -oP 'ERROR: Logfile of failure stored in: \K/.+' "${LOG_FILE}" | sort -u)
if [ -n "$ERROR_LOG_FILES" ]; then
    for filepath in ${ERROR_LOG_FILES}; do
        if [ -f "$filepath" ]; then
           tail -n 10  $filepath
        fi
    done
fi


# Jenkins 빌드 정보 업데이트 (API key 있을 경우)
set -ex
if [ -n "${JENKINS_API_KEY}" ]; then
curl -sX POST -u $USER:$JENKINS_API_KEY ${JOB_URL}/$BUILD_NUMBER/configSubmit \
    -F "json={\"displayName\":\"${BUILD_NUMBER}.${DOWN_DIR}\", \"description\":\"${script} ${PARAM1}\"}" > /dev/null
fi
#rm -f "${LOG_FILE}"