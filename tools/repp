#!/bin/bash
## ==========================================================================
##  readme    : repo utiliies
##  mail      : joongkeun.kim@lge.com, av9300@gmail.com
## ==========================================================================
###---------------------------------------------------------- DEBUG OPTION
#DEBUG=["echo -e"|:], : means no-operation
## DEBUG=[ : | "printf ${RED}%s${NCOL}\n" ]
DEBUG=: #"printf ${RED}%s${NCOL}\n"

PATH_FULL=$(realpath "$BASH_SOURCE")
PATH_DIR="${PATH_FULL%/*}"
PATH_FILE="${PATH_FULL##*/}"
DIR_CURR=$(pwd)
LC_ALL=C.UTF-8
$DEBUG "[$_][$BASH_SOURCE][$0]  [${PATH_FULL}][${PATH_DIR}][${PATH_FILE}]"


if [ -e "${PATH_DIR}/prelibrary" ]; then source ${PATH_DIR}/prelibrary;
else source ${proFILEdir}/tools/prelibrary; fi
## custom builtin variable setting
ACCOUNT=vc.integrator
PATH_MIRROR="/data001/${ACCOUNT}"/mirror
VGIT="vgit.lge.com"
LAMP="lamp.lge.com"
GERRIT=( "${VGIT}/na:29420" "${VGIT}/eu:29430" "${VGIT}/as:29440" "${VGIT}/adas:29550" "${VGIT}/devops_test:29999" "${LAMP}/review:29418" )


##------------------------ alias & oneline func ------------------------------
##============================================================================
#### git alias
## load direct from below
source <(cat <<\EOF
    git config --global alias.alias 'config --get-regexp ^alias\.'
    git config --global alias.st 'status'
    git config --global alias.ci 'commit --verbose'
    git config --global alias.loga 'log --oneline --decorate --graph -n 20 --all'
    git config --global alias.logo "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset %C(blue)<%an>%Creset' --abbrev-commit --date=relative"
    git config --global alias.tagcur 'describe --tags --abbrev=0 --match'
    git config --global alias.diffc 'difftool -t bc'
    git config --global alias.diffv 'difftool -t vimdiff'
    git config --global alias.difft 'difftool --dir-diff -t vimdiff'


    ## NEEDTO: sudo apt-get install icdiff
    #git config --global alias.diffi "difftool --extcmd 'icdiff'"
     git config --global alias.diffi "!_gitdiff() { git difftool --extcmd 'icdiff'; }; _gitdiff"
    #git config --global alias.diffi '!_gitdiff() { git difftool --extcmd "icdiff $@"; }; _gitdiff' --replace-all
    #git config --global alias.clear !_gitclear() { git reset --hard $1; git clean -xdf; }; _gitclear
EOF
) 2> /dev/null


## oneline function
##suppress print path
pushd() { command pushd "$@" > /dev/null ;}
popd() { command popd "$@" > /dev/null ;}
NJOBS=$(( $(nproc --all) / 4))
gittcheck_isgitproject(){ git -C "$1" rev-parse --is-inside-work-tree &> /dev/null ;}

##--------------------------- Menu Functions --------------------------------
##============================================================================

function tempfunc(){
## ---------------------------------------------------------------------------
# template for bash fuction
# $1 parameter explanation
# $2 parameter explanation
    local cmd=$1
    local opt=$2

    case $cmd in
       help) cat <<- EOF
				usage) gitt branch list <''|name-filter>
				usage) gitt branch create|new <name>
				usage) gitt branch delete|remove <name>
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) echo "default functionality"
    ;; esac
}



function ret_server() {
## ---------------------------------------------------------------------------
## search target from source and return
    local target=$1
    local source="${@:2}"
    case $target in                                                                       # return value
            http)    echo "${source}"| awk -F[./:] '{print "http://"$1"."$2"."$3"/"$4}'   # http://vgit.lge.com/na
    ;;      port)    echo "${source}"| awk -F[./:] '{print $5}'                           # 29420
    ;;       sub)    echo "${source}"| awk -F[./:] '{print $1}'                           # vgit
    ;;    domain)    echo "${source}"| awk -F[./:] '{print $2"."$3}'                      # lge.com
    ;; subdomain)    echo "${source}"| awk -F[./:] '{print $1"."$2"."$3}'                 # vgit.lge.com
    ;;      path)    echo "${source}"| awk -F[./:] '{print $4}'                           # na
    ;;       url)    echo "${source}"| awk -F[./:] '{print $1"."$2"."$3"/"$4}'            # vgit.lge.com/na
    ;;    remote)    echo "${source}"| awk -F[./:] '{print $1"_"$4}'                      # vgit_na
    ;;     debug)    echo "${source}"                                                     # vgit.lge.com/na:29420
    ;;         *)    echo "not processed"                                                 # vgit.lge.com/na:29420
    esac
}


function getserver() {
## ---------------------------------------------------------------------------
## format: getserver [29420|na|vgit|lamp|review] [port|http|sub|domain|subdomain|path|url|remote|debug]
## exception: vgitxxx lampxxx will return only postfix after delimter _

    local search_key=$1
    local return_type=$2
    case $search_key in
    vgit_*|lamp_*)   search_key="${search_key#*_}";                                      #remove prefix vgit_ or lamp_ and return remain.
    esac

    for _item in ${GERRIT[@]};do
        if [[ ${_item##*/} =~ "$search_key" ]]; then
            ret_server $return_type ${_item}
            return 0
        fi
    done
    #default server, if not [[ ${_item##*/} =~ "$search_key" ]]
    ret_server $return_type ${GERRIT[4]}
}



## repp ======================================================================================================================
function reppshow_manifesttree(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest file name
# $2 treedepth to display sub manifest
    local file
    local path='|--|--|--|--|--|--'
    local treedepth=${2:-0}

    ##print name of manifest
    printf "%s$1 \n" "${path::${treedepth}}"

    (( treedepth=treedepth+3 ))
    ##print name of branches not revision
    cat $1| sed -n 's/.*revision="\([^ |\t]*\)".*/\1/p'| grep -v '^[a-f0-9]*$'| sort| uniq| xargs -n1 -I {} printf "%60s {}\n"
    ##print only 10 revision for notice
    cat $1| sed -n 's/.*revision="\([^ |\t]*\)".*/\1/p'| grep -e '^[a-f0-9]*$'| head -10| xargs -n1 -I {} printf "%60s {}\n"

    ##sub manifests
    cat $1 | sed -n 's/.*include name="\(.*\)".*/\1/p' | \
    while read -r file; do
        if [ -n "${file}" ];then reppshow_manifesttree ${file} ${treedepth}; fi
    done
    (( treedepth=treedepth-3 ))
}



function reppmani(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest output file name
# $2 command
# $3 branch name or branch postfix
    local cmd=$1
    local item=$2
    local str=$3
    local filter=$4

    if [[ ! "${PWD}" =~ "${REPP_PATH}" ]]; then
        warn "you must move to manifest dir, path is changed automatically ${REPP_PATH}"
        info "you can go by 'repp go mani' or 'git go mani'"
        cd ${REPP_PATH}
    fi


    case ${cmd} in
        info)   ##get global variable and repo init command.
                reppget_repcmd info

                bar inline "current manifest file"
                echo "${REPP_ROOT}/.repo/${REPPFILE_MANI}"

                ##show manifest file with included sub manifests.
                bar inline "manifests"
                clog  "    <name of manifest>                                      <including branches>"
                reppshow_manifesttree ${manifest:-${REPPFILE_MANI}} 0
                info "to see specific xml, run 'repp info <xml>'"

                ##show count of repository
                ### block infomation
                bar inline "misc information for this repositories"
                clog "number of repositories: " $REPP_COUNT

                bar inline "recently changed history [git log 10]"
                showRUN git log -10 --name-status --abbrev=6 --date=format:"%Y-%m-%d %H:%M" --pretty=format:"%C(yellow)%ad %C(red)%h %C(green)%s%C(reset)"

                bar inline "file name & only modified file, not add/delete files (press 'q' to stop)"
                info "you can find add/delete git projects here recent 12 weeks"
                showRUNQ "git log -p --color=always --pretty=oneline --diff-filter=M --since=12-weeks  |more -30"

    ;;   gen)   bar inline "current manifest.xml [${REPPFILE_MANI}] regnerated with option"
                echo 'ex) <project groups="qcos" name="common/nad/ntc" path="nad/tsu-src/ntc" remote="devops" revision="master"/>'
                echo "upper format will be generated by no option(enter)"
                clog "no-option" "generate revision as branch"
                clog "-r" "generate revision as HEAD rev"
                if (( "$(reppversion ver)" > 230 )); then
                    clog "-r --suppress-upstream-revision --suppress-dest-branch" "generate revision without upstream-revision or dest-branch"
                    clog "-m default.xml" "use default.xml as input"
                    clog "--json ${REPPFILE_XML/.xml/.json}" "generate manifest to json format"
                fi
                read -p "input option :" opt
                if [[ ! "${opt}" =~ "--json" ]] || [[ ! "${opt}" =~ "-o" ]]; then opt+=" -o ${item:-${REPPFILE_XML}}"; fi
                showRUN repo manifest ${opt} 2> /dev/null
    ;;change)   under "please run one of these 'repp mani change' commands to generate cmd to change manifest easily\n"
                clog "usage)" "repp mani change <revision|name|path|remote|upstream|dest-branch|groups|dest|src|etc> <change-string> <filter>"
                clog "\n   verifiy :" "cat \${REPPFILE_XML} | <cmd> | grep --color=auto ${str}"
                clog "   preview :" "icdiff <( cat \${REPPFILE_XML} ) <( <cmd> )\n"
                cat <<- CHANGE
				   flow(input cmd): $ repp mani change remote vgit_new vgit_as
				   flow(generated): select postfilter cmd $ cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#'
				   flow(verify   ): cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#' | grep --color=auto vgit_new
				   flow(compare  ): $ icdiff <( cat ${REPPFILE_XML} ) <( cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#' )
				   flow(ok? save ): $ cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#' > repp.xml
CHANGE

                bar inline "repp mani change revision migration_today"
                clog "change field<revision> to value<migration_today>" "generate 3 type <cmd>"
                cat <<- CHANGE
				     infix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="${str}"#'
				    prefix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="${str}\1"#'
				   postfix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="\1${str}"#'
CHANGE
                printf "\n"
                bar inline "repp mani change remote vgit_new vgit_as"
                clog "change field<remote> its contents is matching <vgit_as> to value <vgit_new>" "generate 3 type <cmd>"
                cat <<- CHANGE
				  infilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="${str}"#'
				 prefilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="${str}\1"#'
				postfilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="\1${str}"#'
CHANGE

    ;;  diff)   bar inline "compare 2 different manifests"
                reppget_repcmd
                clog 'ex)' 'repp mani diff <old manifest.xml> <new manifest.xml>'    
                clog 'ex)' 'repp mani diff event/230426_mig.xml event/230712_upstream.xml'    
                ## listup xml by date
                [ -z "${item}" ] && ( git log --since=3-weeks --first-parent --date=format:'%Y-%m-%d (%a) %H:%M:%S' --pretty=format:'%Cgreen%cd [%t]%Creset' --name-status| awk 'NF==1{date=$1}NF>1 && !seen[$2]++{print date,$0}' FS=$'\t' )
                if [ -z "${item}" ]; then 
                    read -p $'\n\nchoose old manifest compare to current: ' opt 
                    clog "\ninput old [${opt}]" "will be compared to current manifest [${REPPFILE_MANI}]"
                    clog "otherwise" "ctrl+c to break, and run 'repp mani diff ${opt} <manifest to compare>'"
                fi
                echo 
                read -p $'\ninfo: repo sync all branch is needed (without -c option) [enter:continue| ctrl+c:break] '
                repo sync -qj5
                repo --no-pager diffmanifests --no-color --raw ${item:-${opt}} ${str:-${REPPFILE_MANI}} --pretty-format='%h| %ci| %an| %s' > repp.diff
                showRUN repo diffmanifests ${item:-${opt}} ${str:-${REPPFILE_MANI}} --pretty-format='%Cred%h %Cgreen(%ci) %C(blue)<%an>%Creset %s' 
                
                cat <<-EOL
		guide)   added projects(NOT compare) : path-added,   project-added   (in ${str} manifest)
		       removed projects(NOT compare) : path-removed, project-removed (in {item} manifest)
		       missing projects(NOT compare) : path-same,    project-changed          
		  unreachable revisions(NOT compare) : need to 'repo sync' (without -c, fetch all project revision)
		          skip projects(NOT compare) : path-same, project-same, branch-same (No diff, SKIP)
		       changed projects( OK compare) : path-same, project-same, branch-changed 
EOL
    ;;  diffcheck)
                bar inline "check result of difference 2 manifests"
                local cpath cbrold cbrnew cremote cproject ccommitid deployed
                IFS=' '; cat repp.diff | sed -e 's/\x1b\[[0-9;]*m//g'| while read -r -a line; do
                    case ${line[0]} in 
                         C) 
                            cpath="${line[1]}"; cbrold="${line[2]}"; cbrnew="${line[3]}"
                            cremote=$(cat ${REPPFILE_CSV} |grep ${cpath} | cut -d'|' -f2)
                            cproject=$(cat ${REPPFILE_CSV} |grep ${cpath} | cut -d'|' -f4|xargs)
                            
                        ;;R) 
                            ccommitid="${line[1]/|/}"
                            ##echo "${cremote}> ${cproject}> ${cbrnew}> ${ccommitid}"                            
                            ##get change_id and find commmit in new branch, it is deployed.
                            deployed=$( revv commit $(getserver ${cremote} path) ${ccommitid} | sed '1d'|  jq -cC '.[].branch' | grep "${cbrnew}" )
                            [ -z "${deployed}" ] && info "[missing commits] ${cremote}> ${cproject}> ${cbrnew}> ${ccommitid}"
                    esac
                done
                                
    ;; help|*)   cat <<- EOF
				usage) repp mani info
				usage) repp mani gen <outfile>
				   ex) repp mani gen current.xml                          #default out: ${REPPFILE_XML}
				usage) repp mani change <groups|upstream|dest-branch|etc> <str> <filter>
				   ex) repp mani change remote vgit_new                   #change "any string" to "vgit_new" in all remote field
				   ex) repp mani change remote vgit_new vgit_as           #change only from "vgit_as" to "vgit_new" in remote field
				usage) repp mani diff event/old.xml <new.xml>             #compare old manifest to new manifest 
				   ex) repp mani diff event/compare.xml                   #compare history event/compare.xml to current.xml
				   ex) repp mani diff default.xml event/230712_mig.xml    #compare history from 2 different manifests 
				   ex) repp mani diff                                     #can choose manifest in recent 3 weeks, comparing to current manifest
				usage) repp mani diffcheck                                #post analysis after 'repp mani diff' for missed commits checking
EOF
    ;; esac
}



function reppget_repcmd(){
## ---------------------------------------------------------------------------
# get repo command from exising repo project
# $1 show repo command (default: save info to each variable such as REPP_URL, REPP_BRANCH, ...)
    local count file_tempa file_tempb

    if [ -z "${REPP_BRANCH}" ]; then
        printf "${RED}[warning] please check if you have switched to a topic branch from after repo init${NCOL}\n"
        printf "${RED}[warning] temporarily set to local branch name${NCOL}\n"
        printf "\tyou can set-up upstream branch with: git branch -u %s <branch-name>\n" "$(echo $(git remote -v |cut -f1))"
        REPP_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    fi

    ## find using manifest.xml
    file_tempa=$(command ls -Art ../*.xml | tail -n 1)
    count=$(grep -c include ${file_tempa})
    if [ -L "${file_tempa}" ];then
        file_tempb=$(readlink "${file_tempa}")
        REPPFILE_MANI=${file_tempb#*/}
    elif [ $count -eq 1 ]; then
        file_tempb=$(grep include $file_tempa |sed -E 's/<.*name="(.*)".\/>/\1/')
        REPPFILE_MANI=${file_tempb// /}
    else
        REPPFILE_MANI=default.xml
    fi

    if [ -n "$REPP_GROUPS" ] && [[ ! "${EXTRA_OPTION}" =~ "--groups" ]] ;then EXTRA_OPTION="--groups=$REPP_GROUPS "; fi
    if [ -n "$REPP_MIRROR" ] && [[ ! "${EXTRA_OPTION}" =~ "--reference" ]] ;then EXTRA_OPTION+="--reference=$REPP_MIRROR"; fi

    
    if [ "$1" = "info" ];then
        bar inline "repo-init cmd"
        REPP_CMD="repo init -u $REPP_URL -b $REPP_BRANCH -m ${REPPFILE_MANI} ${EXTRA_OPTION} --repo-url=${REPP_REPOURL}"
        log "${REPP_CMD}"
    fi
    return 0
}



function reppinfo(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local manifest=$1

    pushd ${REPP_PATH}
    #oldIFS=${IFS}; IFS='';

    ##show repo dir path
    bar inline "repo path"
    log "${REPP_PATH}"

    ##get global variable and repo init command.
    reppget_repcmd info

    ##show manifest file with included sub manifests.
    bar inline "manifests"
    clog  "    <name of manifest>                                      <including branches>"
    reppshow_manifesttree ${manifest:-${REPPFILE_MANI}} 0
    info "to see specific xml, run 'repp info <xml>'"

    bar inline "remotes & review sites"
    for (( i=0; i < ${#REPP_REMOTELIST[@]}; i++ )); do
        printf "remote: %s,\t\t" "${REPP_REMOTELIST[$i]}"
        printf "review: %s\n" "${REPP_REVIEWLIST[$i]}"
    done
    ##show count of repository
    ### block infomation
    bar inline "misc information for this repositories"
    clog "number of repositories: " $REPP_COUNT

    clog "md5 sum for all repositories:"
    repo forall -j16 -c git log -1 --pretty=format:%H%n | md5sum

    ##show last synced time
    if [ -f .git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y .git/FETCH_HEAD );
    else clog "last manifest-synced time(check date of files below): "; ls -lct | tail -10;fi

    #IFS=${oldIFS}
    popd
}



function reppshow(){
## ---------------------------------------------------------------------------
# print information(changes, recent commits) of current repository#
    ##topic/working branch
    bar inline "repo branch: check if working branch existed (WAIT: It takes time) "
    repo branch

    ##run command "repo info"
    bar outline "it takes time to get information..."
    echo "repo status" > ${REPPFILE_STATUS}

    ##remove colored output with 1) sed command, 2) --color option
    #repo status -j8 |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPPFILE_STATUS}
    repo --no-pager --color=never status -j8 >> ${REPPFILE_STATUS}

    ##list up repo commit, remote, branch, project, path
    reppfind |more -60

    ## repo info command is duplicated with reppfind functionality, so remove it.
    #bar inline "repo info: git repo/source path /branch rev saved to [ ${REPPFILE_STATUS} ]"
    #echo "repo info" >> ${REPPFILE_STATUS}
    #repo info |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPPFILE_STATUS}
    
    bar inline "repo status: uncommitted changes list saved to [ ${REPPFILE_STATUS} ]"    
    info "\${REPPFILE_STATUS} you can use this file to check dirty commits left"
}



# local menu_items=('go ROOT　dir' 'go Manifests　dir' 'go GIT　root dir' 'exit')
# run_menu "${menu_items[@]}"
# case "$?" in
    # 1|11)  cd "${REPP_ROOT}"        ;;
    # 2|12)  cd "${REPP_PATH}"        ;;
# esac

function reppgo() {
## ---------------------------------------------------------------------------
# return git root path or return near git path
    local cmd="$1"

    case $cmd in
        help) cat <<- EOF
				usage) repp go              # go repo root dir
				usage) repp go root         # same to above
				usage) repp go mani         # go manifest dir
				usage) repp go git          # go current git root dir
				usage) repp go repo         # show menu to select similar-depth repo project
EOF
                return 1
      ;;repo)
                local INPUT=( $(find ${REPP_ROOT}/.. -maxdepth 4 -name ".repo" 2> /dev/null |head -60))
                if [ -n "${INPUT}" ];
                then run_menu "${INPUT[@]}";  cd "${menu_selected}/.."
                else INPUT=( $(find ${HOME} -maxdepth 4 -name ".repo" 2> /dev/null |head -60))
                     run_menu "${INPUT[@]}";  cd "${menu_selected}/.."
                fi
      ;;  '')    gittgo root
      ;;   *)    gittgo $cmd
    esac
}



function gittgo() {
## ---------------------------------------------------------------------------
# return git root path or return near git path
    local cmd="$1"
    local current_dir=${PWD}

    case $cmd in
        help) cat <<- EOF
				usage) gitt go root         # go repo root dir
				usage) gitt go mani         # go manifest dir
				usage) gitt go git          # go current git root dir
				usage) gitt go              # same to above
				usage) gitt go <dir>        # show git path including 'dir' and can move
				   ex) gitt go build        # show git path including 'build' and move to select
EOF
                return 0
      ;;root)   cd "${REPP_ROOT:-${GITT_PATH}}"; if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
      ;;mani)   cd "${REPP_PATH}"; if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
    ;;git|'')   cd "${GITT_PATH}"; if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
    esac

    if ! repp_initvar; then warn "your are not in repo"; return 1; fi 
    if [ ! -f ${REPPFILE_CSV} ]; then reppfind $cmd; fi

    local INPUT=( $(cat ${REPPFILE_CSV} |grep ${cmd}| awk -v FS="\|" '{print $5}'| sort) )
    if [ -n "${INPUT}" ];
    then 
        run_menu "${INPUT[@]}"; cd "${REPP_ROOT}/${menu_selected##* }"; 
        if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
    else warn "you must find path manaully"; return 1
    fi
}



function reppcommit(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local count=$1
    local out

    #echo "[$1][$count][$out]"
    if [ -z $count ]; then
    cat <<- EOF
		usage) enter        # default, show top 20 recent commits among all git recent(-1) commits
		usage) 4            # show top 4 recent commits among all git recent(-1) commits
		usage) save         # save all recent(-1) commits to ${REPPFILE_COMMIT}
EOF
        read -p "how many commit want to read? [#:number| enter:20| save:savefile| q(ctrl+c):exit]: " count;
    fi

    case $count in
        *[0-9]*) out='/dev/stdout';;
        '') out='/dev/stdout'
            count=20
            log "\nonly shows recent maxium 20 first-commits(git log -1) from all repository"
            ;;
        *)  out=${REPPFILE_COMMIT}
            count=${REPP_COUNT}
            log "\check file [$out], all -1 commits are saved"
            ;;
    esac

    bar outline "repo get recent commit"
    bar inline "date:YMD HMS]       [sha]   [author]      [commit title]                                            [git project                            branch"
    repo forall -j16 -c 'printf "%-100.100s %-80s \n" "$(git log -1 --abbrev=6 --date=format:"%Y-%m-%d %H:%M:%S" --pretty=format:"%ad  %h  [%an] %s")" "[${REPO_PROJECT}  ${REPO_RREV}]"' | sort -r |head -${count:-50} > $out
    #repo forall -c "git log -1 --abbrev=6 --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%ad  %h  [%an] %d %s%n'" |sort -r |head -${count:-50} > $out

}



function reppfind(){
## ---------------------------------------------------------------------------
# find git repository with path and project name with regexp
# $1 path or project
# usage: reppfind [path|project]
    local cmd="$1"

    
    if [ -f "${REPPFILE_CSV}" ];
    then info "reuse generated file [\${REPPFILE_CSV}] or you can remove and retry this";
    else repo forall -j1 -c 'printf "%.6s|%.7s|%-32.32s|%-74.74s|%.80s \n" "${REPO_LREV}" "${REPO_REMOTE}" "${REPO_RREV}" "${REPO_PROJECT}" "${REPO_PATH}"' > ${REPPFILE_CSV}
    fi

    case ${cmd} in
        help) cat <<- EOF
		 info) \${REPPFILE_CSV} is saved. can be opened by excel menu [data> text> select file> file open wizard]
		       or can be reformatted by excel menu [data> text to columns> select delimter'|'> finish]
		usage) repp find                           # show rev,remote,branch,project,path info for all repo
		usage) repp find <string>                  # list git which has string 'string' in all git info
		   ex) repp find build                     # list git which has string 'build' in all git info
		   ex) repp find |grep -v vendor/qct       # list git info not containing 'vendor/qct'
		   ex) cat \${REPPFILE_CSV}                 # cat output file
		usage) repp find @rev                      # print rev colume for all repo
		usage) repp find @remote                   # print project colume for all repo
		usage) repp find @branch                   # print branch colume for all repo
		usage) repp find @project                  # print project colume for all repo
		usage) repp find @path                     # print path colume for all repo
		   ex) repp find @project |grep meta       # print project colume containing 'meta'
EOF
    ;; @rev)      clog "<REPO_LREV>";    awk -v FS="|" '{print $1}' ${REPPFILE_CSV} |pCount
    ;; @remote)   clog "<REPO_REMOTE>";  awk -v FS="|" '{print $2}' ${REPPFILE_CSV} |sort |uniq |pCount
    ;; @branch)   clog "<REPO_RREV>";    awk -v FS="|" '{print $3}' ${REPPFILE_CSV} |sort |uniq |pCount
    ;; @project)  clog "<REPO_PROJECT>"; awk -v FS="|" '{print $4}' ${REPPFILE_CSV} |sort |pCount
    ;; @path)     clog "<REPO_PATH>";    awk -v FS="|" '{print $5}' ${REPPFILE_CSV} |sort |pCount
    ;; '')        printf "\e[1;33m%6.6s %7.7s %-32.32s %-74.74s %.80s \e[0m\n" "REPO_LREV" "REPO_REMOTE" "REPO_RREV" "REPO_PROJECT" "REPO_PATH"
                  cat ${REPPFILE_CSV} |pCount
                  printf "\n\n"
                  info "Above \${REPPFILE_CSV} is generated, all repository info is save: ${REPPFILE_CSV}"
                  clog "\${REPPFILE_CSV}" "this file can opened by excel menu [data> text> select file> file open wizard], or reformatted by [data>text to columns> select delimter'|'> finish]"
                  clog "to see help: " "repp find help"
    ;; *)         printf "\e[1;33m%6.6s %7.7s %-32.32s %-74.74s %.80s \e[0m\n" "REPO_LREV" "REPO_REMOTE" "REPO_RREV" "REPO_PROJECT" "REPO_PATH"
                  cat ${REPPFILE_CSV} | grep -i --color=always ${cmd} |pCount
    esac
}



function reppbranch(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest output file name
# $2 command
# $3 branch name or branch postfix
    local cmd=$1
    local name=$2

    case ${cmd} in
       ''|help) cat <<- EOF
		 info) gitt branch info                    # show only current git branch info (local, remote branch and commits)

		usage) repp branch list                    # list all remote branches for all gits (it takes times)
		   ex) repp branch list '*release*'        # find *release* matching branches (asterix need to be closed by colon)
		usage) repp branch create                  # show commands can create branch for all, some gits by pre/in/postfix
		usage) repp branch remove                  # show commands can revove branch for all, some gits
		   ex) repp branch create release          # show commands to create 'release' branch
		usage) repp branch checksum                # print local repo checksum and remote tracking branch checksum
		usage) repp branch compare                 # compare which git is diff between local and remote tracking branch
		usage) repp branch compare <remote>        # compare which git is diff among local, remote tracking, a remote branch.
		   ex) repp branch compare mig_230426      # compare between 3 branches (local, remote, mig_230426 branch)
EOF
    ;;  list|find)
                under "please run one of these 'git ls-remote' commands to check if branch is existed in remote\n"
                info "this command show all git project and show if the branch is existed"
                clog "prefix:" "repo forall -pc 'git ls-remote -h \${REPO_REMOTE} refs/heads/\$1_\${REPO_RREV}' ${name:-<branch-prefix>}"
                clog "postfix:" "repo forall -pc 'git ls-remote -h \${REPO_REMOTE} refs/heads/\${REPO_RREV}_\$1' ${name:-<branch-postfix>}"

                bar inline "check exact ${name} remote branche is existed for all gits"
                #showRUNQ y repo forall -c 'printf "%30s| %-70s\n" ${REPO_REMOTE} ${REPO_PROJECT} $(git ls-remote -h ${REPO_REMOTE} refs/heads/$1)' ${name}
                #test case all) repp branch list, repp branch list '*', repp branch list '*mas*',  exact) repp branch list m/master, repp branch list 'm/master'
                set -o noglob
                showRUN repo forall -c 'printf "\t\t >>>> [%10s] ${YELLOW}%-60s${NCOL}\n" ${REPO_REMOTE} ${REPO_PROJECT}; git ls-remote -h ${REPO_REMOTE} refs/heads/${1}' ${name:-*}
                set +o noglob
    ;;  create|new)
                under "please run one of these 'git push' commands to create branch in remote\n"
                info "<branch name> will be passing to 'git push' cmd in position of parameter \${1}"
                info "variable preview: \${REPO_REMOTE}|\${REPO_RREV} $(repo forall . -c 'echo ${REPO_REMOTE}\|${REPO_RREV}' 2> /dev/null)\n"
                clog "infix:" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
                clog "prefix :" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}_\${REPO_RREV}' ${name:-<branch-prefix>}"
                clog "postfix:" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${REPO_RREV}_\${1}' ${name:-<branch-postfix>}"
                echo 
                clog "ex) infix only current git" "repo forall . -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
                clog "ex) infix for several git " "repo forall xxx/yyy ppp/qqq/rrr -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
    ;;  remove|delete)
                under "please run one of these 'git push' commands to delete branch in remote\n"
                info "<branch name> will be passing to 'git push' cmd in position of parameter \${1}\n"
                clog "infix:" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
                clog "prefix :" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${1}_\${REPO_RREV}' ${name:-<branch-prefix>}"
                clog "postfix:" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${REPO_RREV}_\${1}' ${name:-<branch-postfix>}"
                echo
                clog "ex) infix only current git" "repo forall . -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
                clog "ex) infix for several git " "repo forall xxx/yyy ppp/qqq/rrr -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
    ;;  checksum) ##don' use showRUN, md5sum includes showRUN command.
                bar inline "1. md5sum of local HEAD in all repository"
                repo forall -c 'git log -1 --pretty=format:%H%n' | md5sum

                bar inline "2. md5sum of remote all tracking branch in all repository"
                repo forall -c 'git ls-remote -h ${REPO_REMOTE} refs/heads/${REPO_RREV} | cut -f1' |md5sum
                #repo forall -c 'git ls-remote -h ${REPO_REMOTE} refs/heads/$1 | cut -f1' ${name:-${REPP_BRANCH}} |md5sum
                
                info "you can use 'repp branch compare' to get which git is different"
    ;;  compare)
                bar inline "generate branch info local, remote tracking branch, and specific remote branch"
                #repo forall -pc 'git diff --shortstat tagA tagB'
                fileA=$(mktemp); fileB=$(mktemp)
                repo forall -c 'printf "%s %s %s\n" $(git log -1 --pretty=format:%H%n) ${REPO_RREV} ${REPO_PROJECT}' > ${fileA}
                repo forall -c 'printf "%s %s %s\n" $(git ls-remote -h ${REPO_REMOTE} refs/heads/${REPO_RREV}) ${REPO_PROJECT}' > ${fileB}
                if [ -n "${name}" ]; then
                    fileC=$(mktemp)
                    repo forall -c 'printf "%s %s %s\n" $(git ls-remote -h ${REPO_REMOTE} refs/heads/$1) ${REPO_PROJECT}' ${name} > ${fileC}
                fi

                info "please compare command: vimdiff ${fileA} ${fileB} ${fileC}"
                info "please compare command: icdiff ${fileA} ${fileB} |more -60"
    ;;       *) reppbranch help
    esac
}



function reppinit(){
## ---------------------------------------------------------------------------
# repo init helper
# $1 short repo init command
    ##option handle
    local cmd="$1"

    case $cmd in
       help|'')    cat <<-EOF
			 usage) repp init -u <manifest-url> -b <manifest-branch> -m <manifest-name> -p <platform> -c
			                  --reference=<mirror-path> --depth=<depth> --repo-url=<repo-url>
			                  --no-clone-bundle --partial-clone --no-tags --mirror
				ex) repp init -u ssh://${USER}@vgit.lge.com:29440/honda/linux/manifest -b tsu_25.5my_release
				ex) repp init -u https://android.googlesource.com/platform/manifest -b android-12.1.0_r1
				ex) repp init -b lampauto_r_release -m all.xml
				ex) repp init -u ssh://lamp.lge.com:29418/platform/manifest.git -b lampauto_r_release
				     -m lampauto/lampauto-gm-recent.xml --reference=/data001/vc.integrator/mirror/lampauto_r_release/
				     --repo-url=ssh://lamp.lge.com:29418/repo/git-repo.git

EOF
            info 'please refer http://collab.lge.com/main/x/wY6wa'
            return 1
       ;; *) :
    esac


    #### parameter parsing
    local url revision manifest platform reference depth repo_url extra ret=0
    if ! options=$(getopt -l reference:,depth:,repo-url:,no-clone-bundle,partial-clone,no-tags,mirror -o b:m:p:u: -- "$@")
    then err 'please check "repo init --help"'; return 1; fi

    ##reset legacy positional parameter except $options
    eval set -- "$options"
    ##parse parameter from options using shift, which shifts the $1, $2, ... value sequencely
    while true; do
        $DEBUG [$1][$2]
        case $1 in
            ##when option has sub option, should shift 2 or just shift
            -u|--manifest-url)                                          url=$2;         shift 2;;
            -b|--manifest-branch)                                       revision=$2;    shift 2;;
            -m|--manifest-name)                                         manifest=$2;    shift 2;;
            -p|--platform)                                              platform=$2;    shift 2;;
            --reference)                                                reference=$2;   shift 2;;
            --depth)                                                    depth=$2;       shift 2;;
            --repo-url)                                                 repo_url=$2;    shift 2;;
            ##single option that need no additional sub value
            ##skip single option and remove getopt cmd
            -c|--current-branch)                                  extra="${extra} $1";  shift 1;;
            --no-clone-bundle|--partial-clone|--no-tags|--mirror) extra="${extra} $1";  shift 1;;
            --|*)                                                                  shift; break;;
        esac
    done

    #### parameter check
    ##if url has lamp and url is null, default url is lamp or return
    local sep='~'
    case ${url}$sep${revision} in
         $sep*lamp*) url="ssh://lamp.lge.com:29418/platform/manifest.git" ;;
         $sep*) err "-u manifest-url is necessary" ;;
         *$sep*) : ;;
    esac
    ##if reference dir is existed, set reference as default.
    if [ -z "${reference}" ];then reference="${reference:-${PATH_MIRROR}/${revision}}"; [ ! -d "${reference}" ] && reference=''; fi
    ##issue https://github.com/OP-TEE/manifest/issues/157
    if [ -z "${repo_url}" ] && [ "${url}" != "${url/lamp/}" ];then repo_url='ssh://lamp.lge.com:29418/repo/git-repo.git'; fi

    #### run repo command
    ##url handle with replication server
    local file_info=$(mktemp)
    cmd_repoinit="repo init ${url:+-u ${url}} ${revision:+-b ${revision}} ${manifest:+-m ${manifest}} ${platform:+-p ${platform}} ${reference:+--reference=${reference}} ${depth:+--depth=${depth}} ${repo_url:+--repo-url=${repo_url}} ${extra} $@"

    ##make final repo init cmd
    bar outline "executed command:" >> ${file_info}
    printf "${cmd_repoinit}\n" >> ${file_info}

    ##execute cmd
    reppcheck_initcmd ${cmd_repoinit}
    if [ "$?" -eq 1 ]; then ret=1; fi

    ##show repo info
    bar outline >> ${file_info}
    cat ${file_info}; rm -f ${file_info}

    ##go next step or not
    if [ "$ret" -eq 0 ]; then info "to repo sync?:[enter:continue| ctrl+c:break] "; reppsync;
    else err "'repp connect help' or 'repp init help'"; fi
}



function reppsync(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
# ex) reppsync
    local cmd=$1
    local opts="${@:2}"
    local preopt njobs

    case $cmd in
        help) cat <<- EOF
			usage) repp sync                # sync with default option
			usage) repp sync debug          # for debugging with --trace
			usage) repp sync <option>       # default option) --no-tags --no-clone-bundle --fail-fast
			   ex) repp sync --force-sync   # go current git root dir
			   ex) gitt go build            # show git path including 'build' and move to select
EOF
        ;; debug)   info "you can use permission check with 'repp connect' command"
                    preopt="--trace" ; njobs=1
        # -[[:digit:]] ) ##same to '*[0-9])'
        #           njobs=${cmd}
        #    -*)    opts="${cmd} ${opts}"
        ;;    *)    
                    info "default cmd: repo sync --no-tags --no-clone-bundle --fail-fast -cj8"
                    clog "-m" "event/branch_migration.xml  # use input manifest.xml (to check if manifest work before commit) "
                    clog "-d" "                            # back to manifest revision"
                    clog "-f" "                            # force sync with overwriting"
                    clog "--jobs-network=" "8              # count of network thread [default 1]"
                    clog "--auto-gc" "                     # with garbage collection [default no]"

                    read -p  $'\n\nPlease input option to repo sync [enter:auto| opts:-qcj4| ctrl+c:exit]: ' opts;
                    if [ -z $opts ]; then njobs=${NJOBS}; fi        
    esac

    showRUN repo ${preopt} sync --no-tags --no-clone-bundle --fail-fast -cj${njobs:-8} ${opts}

    #"$@" 2> >(tee -a ${file_error})
    "$@" > >(tee -a ${file_error})
    case $? in
     0) ;;
     1) echo Generic error, usually because invalid command line options or malformed configuration;;
     2) echo Connection failed;;
     *) echo Unknown Error;;
    esac
}



function reppreset(){
## ---------------------------------------------------------------------------
# reset git repositories
# $1 target

    local cmd=$1
    case ${cmd} in
            help)   cat <<-EOF
				usage) repp reset          # reset all repository to original revision
				usage) repp reset check    # show reset result (details: repp show)
				usage) repp reset project  # remove legacy 'repo sync' info to 'repo sync' again.

				 info) gitt reset          # provide detail control for one repository
EOF
        ;;   '')    info "repp reset help : for more usage\n"
                    ## git reset --hard;   #reset to local lastest commit status.
                    ## git clean -xdf      #remove uncommitted change
                    showRUNQ y repo forall -cj${NJOBS} 'git reset --hard @{upstream}; git clean -xdf'
                    
                    #showRUN repo sync -dlvj${NJOBS} --force-remove-dirty
                    info "\nfinish reset all repositories, and reset FETCH_HEAD"
        ;;project)  info "you can repo sync without conflicting legacy objects"
                    showRUNQ y echo "
                    ${REPP_ROOT}/.repo/project.list
                    ${REPP_ROOT}/.repo/project-objects/
                    ${REPP_ROOT}/.repo/projects/"
                    rm  -rf ${REPP_ROOT}/.repo/project.list \
                    ${REPP_ROOT}/.repo/project-objects/ \
                    ${REPP_ROOT}/.repo/projects/
        ;;check|*)  showRUN repo status -vj${NJOBS}
                    info "\n\n reset to manifest revision and check if uncommited change existed"
    esac
}




function reppversion(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local file_log=$(mktemp)
    python3  $(which repo) --version > ${file_log}
    
    local cmd="$1"
    ## only 3digit length version code is valid to compare old version
    local VER=$(cat ${file_log} | grep "repo version"  |tr -dc '[:digit:]')
    case $cmd in
          help) :
        ;; ver) echo ${VER:0:3} && return 0
    esac
    #if VER is not integer, in case of error
    [[ ${VER} != ?(-)+([0-9]) ]] && VER=000

    echo "this version is expected to used, please check this version is matched to your local version"

    bar inline "expected"
    info "warning: this is the repo packaged with this project."
    $REPP_PATH/../repo/repo version

    printf "\n\n"
    bar inline "found"
    info "the local version currently you are using"
    bar inline "what"
    cat ${file_log}

    echo
    py_path=$(which python) >/dev/null
    py_ver="$(python --version 2>&1)"
    printf "[check] %s is working in [%s]\n" "${py_ver}" "${py_path}"

    bar inline "where"
    which repo
    which git

    if (( ${VER:0:3} < 230 )); then
        under "you need to upgrade 'repo' to use full functionality\n"
        clog "1. remove old .repo:" rm -rf ${REPP_ROOT}/.repo
        clog "2. download to dir:" git clone https://gerrit.googlesource.com/git-repo ${PATH_MIRROR}/repo2 --mirror
        clog "3. repo init with below command:" --repo-url=[${REPP_REPOURL}] --\> [${PATH_MIRROR}/repo2]
        pushd ${REPP_PATH} ; reppget_repcmd info ; popd
        clog "-->"
        echo "${REPP_CMD/${REPP_REPOURL}/${PATH_MIRROR}/repo2}"
        #| sed -e 's#--repo-url=${REPP_REPOURL}#--repo-url=${PATH_MIRROR}/repo2'
    fi
}



function reppcheck_initcmd(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
    local file_error=$(mktemp)
    local ret=1 #return 1 is success, 0 is fail
    echo "\$ $@"
    time "$@" 2> >(tee -a ${file_error})
    #"$@" | tee -a ${file_error}


    case $(cat ${file_error}) in
        help)                           echo "init error handler"
    ;; *fatal*|*fail*|*error*)          err "check error log [${file_error}]"
    ;; *Permission?denied*publickey*)   err "check error permission"
    ;; *)                               ret=0
    esac

    [ "$ret" -eq 1 ] && echo "check http://collab.lge.com/main/pages/viewpage.action?pageId=1620608725"
    return $ret
}



function reppcheck_server(){
## ---------------------------------------------------------------------------
# check if server can access code-review server by SSH protocol
# SSH protocol is used in local server to get source from code-review sever
    local server=$1
    local user=$2
    local port=$3
    local gitproject=$4
    local branch=$5
    local ret

    local file_error="$(mktemp)"
    #echo "\$ ssh -T $user@$server -p $2 -vvv" ;
    bar inline "step3.1-localserver: [remote] check if sshd is serviced on this port $port "
    clog solution "check port num is correct? check account and ssh-key is matched and registered?"

    #echo "ssh -T $user@$server -p $port -vvv 2> $file_error"
    echo \n| ssh -T $user@$server -p $port -vvv 2> $file_error

    case $(cat ${file_error}) in
        help)       echo "ssh connection error msg handler"
    ;; *success*)   echo "good, SSHD is active on port [$port] in server [$server], you can connect"
    ;; *Connection?refused*)
                    err "check log in ${file_error}"
                    grep -En "*Connection refused*" $file_error
                    err "check IP/PORT setting in (.ssh/config) with below"
                    ping $server -c2
                    return 1
    ;; *publickey*) err check publickey
                    return 1
    ;; *)           err "unknown error is occured, please check log [${file_error}]"
                    return 1
    esac

    bar inline "step3.2-localserver: [remote] check if I can access git project from local-server"
    clog solution "check git name path is correct and can access"
    ret=$(ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject})
    [ -n "$ret" ] &&  echo "gitproject existed and accessed [${gitproject}]" || err "check git project is existed or permission allowed [${gitproject}]"

    bar inline "step3.3-localserver: [remote] check if I can access the branch from local-server (default: master)"
    clog solution "check branch name path is correct and can access"
    #ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject} -b ${branch}
    ret=$(ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject} -b ${branch})
    [ -n "$ret" ] &&  echo "branch existed and accessed [${branch}]" || err "check git branch is existed or permission allowed [${branch}]"
    #rm -f ${file_error}

    under "you can check 'READ' accessibility for all branch & repository (wait 30s)\n"
    read -p "check accessibility for all repository  [enter:continue| ctrl+c:exit]: "
    repo forall -c bash -c '
    GERRIT=( "vgit_na:29420" "vgit_eu:29430" "vgit_as:29440" "vgit_adas:29550" "vgit_devops_test:29999" "lamp_review:29418" )
    for _item in ${GERRIT[@]};do
        [ ${_item%:*} = "${REPO_REMOTE}" ] && printf "[%4.4s] " "${REPO_I}" && ssh $REPO__${USER}@$0 -p ${_item#*:} gerrit ls-projects --prefix ${REPO_PROJECT} -b ${REPO_RREV} --limit 1
    done
    ' $(getserver ${oriserver} subdomain) #vgit.lge.com
}



#reppforall joongkeun.kim na tsu_25.5my_release
function reppforall(){
## ---------------------------------------------------------------------------
# check if an account in server can access code-review server by SSH protocol
# SSH protocol is used in local server to get source from code-review sever

    local user=$1
    local server=$(getserver $2)
    local branch=$3
    local gitproject=$4

    #repo forall -c 'ssh $1@$2 -p $3 gerrit ls-projects --prefix ${REPO_PROJECT} -b ${REPO_RREV}'  $user $server $port
    repo forall -c 'ssh $1@$2 -p $3 gerrit ls-projects --prefix ${5:-${REPO_PROJECT}} -b ${4:-${REPO_RREV}}'  $user $(getserver $server subdomain) $(getserver $server port) ${gitproject} ${branch}
}



function reppconnect(){
## ---------------------------------------------------------------------------
# check connection and report error
# $1 server
# $2 port
# $3 password
    local cmd="$1"
    case ${cmd} in

       help)    cat <<-EOF
			  usage) repp connect [server]  [user]          [gitproject]   [branch]
			 -----------------------------------------------------------------
			default) repp connect remotes   $ACCOUNT        manifests    current
			     ex) repp connect na        testaccount     tiger/tools  tiger_release
			     ex) repp connect na        joongkeun.kim   tiger/tools  tiger_release
			     ex) repp connect na        testaccount     tiger/tools
			     ex) repp connect na        testaccount     
			     ex) repp connect na        testaccount
			     ex) repp connect
EOF
                return 1;
    ;;     *) :
    esac

    local user oriserver server gitproject branch port
    local temp_p=$(expr "${REPP_URL}" : ".*[0-9]/\(.*\)\..*")
    [ -z "$4" ] && info "use default branch: ${GITT_BRANCH:-${REPP_BRANCH}}"        ;branch=${4:-${GITT_BRANCH:-${REPP_BRANCH}}}
    [ -z "$3" ] && info "use default git project: ${GITT_PROJECT:-${REPP_PROJECT}}" ;gitproject=${3:-${GITT_PROJECT:-${REPP_PROJECT}}}
    [ -z "$2" ] && info "use default account: $USER"                                ;user=${2:-$USER}
    [ -z "$1" ] && info "use default server: ${GITT_REMOTE:-${REPP_REMOTE}}"        ;oriserver=${1:-${GITT_REMOTE:-${REPP_REMOTE}}}
    server=$( getserver ${oriserver} subdomain ); port=$(getserver ${oriserver} port)


    dlog [$user][$oriserver][$server][$gitproject][$branch]
    clog "should be this format:" "[testaccount][$oriserver][$server][$gitproject][$branch]"

    under "step1: check basic server environments\n"
    #local port=$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')
    bar inline "step1.1-ssh: [local] check if ssh is installed"
    clog solution "install proper version of ssh"
    if [ -x "$(command -v ssh)" ]; then  log "ssh is installed in [$(which ssh)]"; else err "ssh is not installed, install it"; fi

    if [ -z $oriserver ]; then reppconnect help && return 1;fi
    bar inline "step1.2-tcp: [remote] check if server tcp port is well listened"
    clog solution "check port num is correct? firewall is active? internet is on?"
    showRUN timeout 5 bash -c "</dev/tcp/${server}/$port"
    if [ $? == 0 ];then echo "server $server over port $port is listened";
    else echo "server $server over port $port is not listened, please contact server manager"; fi


    under "step2: check gerrit permission from WEB(HTTP)as admin[${ACCOUNT}]\n"
    showRUN revvcheck_server ${oriserver} ${user} ${gitproject} ${branch}
    under "step3: check gerrit connection from SERVER(SSH) as user[${user}]\n"
    showRUN reppcheck_server ${server} ${user} ${port} ${gitproject} ${branch}
}



function reppfind_repodir(){
## ---------------------------------------------------------------------------
# find input-path up and down,
# $1:path name, $2:max depth to sub dir, $3:print or not
# ex) reppfind_repodir .repo 5
# ex) reppfind_repodir .git 2
    local T=$PWD
    local target=${1:-.repo}
    local down_depth=${2:-2} #default value:2

    ## find in sub directory with depth
    readarray -t REPP_PATH_ALL < <(find . -maxdepth ${down_depth} -path "*${target}" |sort)
    case ${#REPP_PATH_ALL[@]} in
    1)  ## found one in sub dir
        REPP_PATH=$(readlink -f ${REPP_PATH_ALL[0]})
        ;;
    0)  ## not found, so find in parent directory upto $HOME
        while [[ "${PWD}" =~ "${HOME}" ]]; do
            if [ -d ${target} ]; then break; fi
            pushd ..
        done
        if [ -d ${target} ]; then REPP_PATH=$(readlink -f ${target});else REPP_PATH='';fi
        pushd -0 && dirs -c
        cd $T
        ;;
    *)  ## found multiple dir in sub dir
        warn "subdir [%s]\n" ${#REPP_PATH_ALL[@]}
        warn "%s\n" ${REPP_PATH_ALL[@]};
        REPP_PATH=''
        ;;
    esac
}



function repp_initvar(){
## ---------------------------------------------------------------------------
# find input-path up and down,

    local ret=1
    ## move to repo root
    reppfind_repodir .repo/manifests 5 
    ## set variable REPP if manifest dir exists
    if [ -d "${REPP_PATH}" ];then
        pushd ${REPP_PATH}
        REPP_REMOTE=$(getserver $(git remote -v |grep fetch | grep -oP '(?<=:)[0-9]+(?=/)') remote)
        #REPP_PROJECT=$(git remote -v |grep fetch | sed -E 's#.*[0-9]+(.*).git.*$#\1#')
        REPP_PROJECT=$(git config --get-regexp remote.*.url  |head -1|cut -d' ' -f2)
        REPP_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}| sed 's:.*/::')  #GITT_BRANCH
        REPP_REVIEW=$(git config --get-regexp remote.*.review|cut -d' ' -f2|head -1)        #GITT_REVIEW
        REPP_URL=$(git config --get-regexp remote.$(git remote|head -1).url|cut -d' ' -f2|head -1) #GITT_URL

        REPP_ROOT=${REPP_PATH%/.repo*}
        #REPP_URL=$(git remote -v |grep fetch |awk '{print $2}')
        #REPP_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}| sed 's:.*/::')
        REPP_REPOURL=$(cat ../repo/.git/config |grep url|sed 's/.*= \(.*\)/\1/')
        #REPP_MIRROR=$(cat ../manifests.git/config |grep reference|sed 's/.*= \(.*\)/\1/')
        REPP_MIRROR=$(git config --get-regexp repo.reference |head -1|cut -d' ' -f2)
        REPP_GROUPS=$(git config --get-regexp manifest.groups |head -1|cut -d' ' -f2)
        REPP_COUNT=$($REPP_PATH/../repo/repo list |wc -l)

        REPP_REMOTELIST=( $(repo manifest 2>/dev/null |grep review | sed -E 's#.*name="([^"]*[^"]*)".*#\1#') )
        REPP_REVIEWLIST=( $(repo manifest 2>/dev/null |grep review | sed -E 's#.*review="([^"]*[^"]*)".*#\1#') )
        popd
        ret=0
    fi
    REPPFILE_STATUS=${REPP_ROOT}/repp.status
    REPPFILE_COMMIT=${REPP_ROOT}/repp.commit
    REPPFILE_CSV=${REPP_ROOT}/repp.csv
    REPPFILE_XML=repp.xml

    if [[ $ret -eq 1 ]]; then
        $DEBUG ${REPP_PATH_ALL[@]};
        $DEBUG "you are not in repo project, please check !";
    fi
    return $ret
    
}

function gitt_initvar(){
## ---------------------------------------------------------------------------
# find input-path up and down,

    local temp

    if ! gittcheck_isgitproject; then
        return 1
    fi

    ##readarray -t GITT_REMOTE < <(git remote -v |cut -f1|uniq)
    GITT_REMOTE=$(git remote|head -1)

    #git config --get-regexp remote.$GITT_REMOTE |sort|grep -Ee "(projectname|url)"
    #git config --get-regexp remote.*.projectname|cut -d' ' -f2
    temp=$(git config --get-regexp remote.* |grep -Ee "(projectname|url)" |head -1|grep -Po '\w/\K.\w+[^?]+')
    if [ -n "${GITT_PROJECT}" ] && [ "${temp}" = "${GITT_PROJECT}" ]; then 
        return 0; #git path not changed, so break
    fi
    GITT_PROJECT=${temp}


    #NEEDTO WORK: find more secure way to get current branch revision
    GITT_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}| sed 's:.*/::')
    [ -z "${GITT_BRANCH}" ] && GITT_BRANCH=$(git branch -ar |grep -e '->' |sed -E 's#.*[/|>](.*)$#\1#') 
    [ -z "${GITT_BRANCH}" ] && GITT_BRANCH=$(git branch -ar |grep -e 'm/' |sed -E 's#.*[/|>](.*)$#\1#')
    [ -z "${GITT_BRANCH}" ] && warn "'repo start <workingbranch> --all' is recommended" 
    [ -z "${GITT_BRANCH}" ] && ( err "check your branch with 'git branch'
    repo start <working branch> --all       # make working branch
    source repp                             # reload repp script"
    )

    GITT_REVIEW=$(git config --get-regexp remote.*.review|cut -d' ' -f2|head -1)
    GITT_URL=$(git config --get-regexp remote.${GITT_REMOTE}.url|cut -d' ' -f2|head -1)
    GITT_PATH=$(git rev-parse --show-toplevel)
    return 0
}

function revv_initvar(){
    local ret=0
    #default initial gerrit API key is na (vgit_na).

    key_id=$(getserver ${GITT_REMOTE:-${REPP_REMOTE}} sub)
    key=$(ende_code dev ${key_id})

    if (( 40 > ${#key} )); then
        warn "if problem continue, check gerrit http key value in [~/.key_${key_id}] \n
        you can generate .key_XXX : code enf ${key_id} <check_key_from_gerrit_account>"
        ret=1
    fi

    if ! revvcheck_server ${server:-na} ${ACCOUNT} checkapi; then
        err "please check correct account&key is saved in ~/.key_${key_id} in $HOME dir"
        ret=1
    fi
    
    return $ret
}


function reppcheck_initvar(){
## ---------------------------------------------------------------------------
# find repo, gitt, review variable

    local cmd=$1
    ## --------------------------------------------------------
    if [[ "${cmd}" =~ "repp" ]]; then   
        if ! repp_initvar ; then warn "you are not in repo project" && return 1;  fi
    fi
    ## --------------------------------------------------------
    if [[ "${cmd}" =~ "gitt" ]]; then
        if ! gitt_initvar ; then warn "you are not in git project" && return 1;  fi
    fi
    ## --------------------------------------------------------
    if [[ "${cmd}" =~ "revv" ]]; then   
        if ! revv_initvar ; then warn "you don't have a permission, please check" && return 1;  fi
    fi
    return 0
}



function gittinfo(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# TODO: clone command
    local TEMP
    local review_gerrit=admin/repos
    bar inline "git path"
    clog 'current git path:' "${GITT_PATH}"

    ## "error: must check" must be checked!!!
    bar inline "show all remote info"
    clog ' remote:' ${GITT_REMOTE:="error: must check"}
    clog 'project:' ${GITT_PROJECT:="not defined"}
    clog ' branch:' ${GITT_BRANCH:="error: must check"}
    clog ' review:' ${GITT_REVIEW:="not defined"}
    clog '    url:' ${GITT_URL:="error: must check"}

    ##review system check
    case $(git config --get-regexp remote|cut -d' ' -f2) in
      help)             echo "site customization"
    ;;*github.com*)     GIT_SITE=$(printf "https://%s" ${GITT_URL}|sed -E 's#^.*github.com:(.*.git)$#http://github.com/\1#')
    ;;*vgit.lge.com*manifest*) 
        case ${GITT_URL} in #remove starting string 'vgit.lge.com:29420/'
           *vgit.lge.com:29420*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'na' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29430*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'eu' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29440*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'as' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29550*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'adas' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29999*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'devops_test' ${review_gerrit}/${GITT_URL##*9/} )
        ;;                    *) GIT_SITE="please add site custom setting" ;;
        esac
    ;;''|*)             GIT_SITE=$(printf "%s/${review_gerrit}/%s" "$(echo ${GITT_REVIEW}|sed -E 's#(.*)[/]$#\1#')" ${GITT_PROJECT} )
    ;;esac
    clog "review system site:" ${GIT_SITE}
    clog "url on gitiles & gerrit for branch:" "(${GITT_BRANCH})"
    clog "gitiles: " ${GIT_SITE/"${review_gerrit}"/"plugins/gitiles"}/+/refs/heads/${GITT_BRANCH}
    clog " gerrit: " ${GIT_SITE/"${review_gerrit}/"/"gitweb?p="}.git\;a=shortlog\;h=refs/heads/${GITT_BRANCH}

    bar inline "git clone & push commands"
    clog " git clone:" "git clone ${GITT_URL} -b ${GITT_BRANCH}"
    TEMP=$(printf "git push $GITT_REMOTE HEAD:refs/heads/%s" ${GITT_BRANCH})
    clog " git push review:" ${TEMP/\/heads/\/for}    
    clog " git push direct:" $TEMP

    bar inline "recent commit info"
    git show --stat --oneline HEAD

    bar inline "last synced time"
    #show last synced time
    oldIFS=${IFS}; IFS='';
    if [ -f ${GITT_PATH}/.git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y ${GITT_PATH}/.git/FETCH_HEAD );
    else clog "last manifest-synced date(check date of files below):" "\n$(ls -lct ${GITT_PATH}/.git| tail -1)";fi
    IFS=${oldIFS}
}



function gittshow(){
## ---------------------------------------------------------------------------
# show commit history by git log, or show commit by git show
# $1: "number of commit" or "commit sha1"
    #topic/working branch
    local depth="${1:-15}"

    if [[ ${#depth} -gt 3 ]] && [[ ${depth} =~ ^[0-9a-f]+$ ]]; then
        bar outline "call native git"
        git show --stat ${depth}
        return 0
    fi

    bar outline "gitt show is based on command: git log "
    bar inline "git commit history with option (to see all branche, gitt show 15 --all)"
    showRUN git log --decorate --graph -n${depth} --pretty=format:'%Cred%h -%C(yellow)%s %Cgreen(%ci) %C(blue)<%an>%Creset'

    bar inline "git commit history with diff file list"
    echo "filter: --since(=after), --before(=until)"
    echo "date  : 6 hour, 2-day, 2-week, 1-month, 1-year"
    clog "ex:" "--since=2-weeks, --since=04:24, --before=6-hours, --after=2022-11-10 --before=2022-11-20-23"
    read -p "input add option [default:--pretty="short" --name-only with your input option] "

    bar inline "file name only (press 'q' to stop)"
    #git log --color=always --pretty="short" --name-only ${reply} --pretty=format:'%Cred%h -%C(yellow)%s %Cgreen(%ci) %C(blue)<%an>%Creset' |more -60
    git log --color=always --pretty="short" --name-only ${reply} --pretty=format:'%Cred%H %Cgreen(%ci) %n%C(yellow)%s %C(blue)<%an>%Creset' 

    clog "to see only modified file & contents, not add/delete files:" "git log -p --color=always --pretty=oneline --diff-filter=M ${reply}"
}



function formatprint(){
## ---------------------------------------------------------------------------

    local cmd=$*
    local index=0 line;

    #cmd preprocessor
    case ${cmd} in
                 help) echo "pre-process cmd"
    ;;   *git?status*) under "file changes list\n"
    ;;              *) echo "not found"
    esac

    readarray -t resultline < <( ${cmd[*]} )
    #resultline=("${cmd[*]}" "${resultline[@]}")
    #declare -p resultline

    ##read one line from array "${resultline[@]}"
    ##for line in "${resultline[@]}"; do while read item; do
    printf "%14s | %-14s -- \t%s\n" "indexed area" "working tree" "filelist"
    echo ${linemi}
    for line in "${resultline[@]}"; do
        #echo "KJK:[${line:0:1}][${line:1:1}]"
            ##custom handler for each item.
            case ${line:0:1} in
                 help)   :
            ;;    '#')   bar inline "file changes in branch: ${line}"
            ;;    '?')   printf "%14s | " "new"
            ;;    '!')   printf "%14s | " "new"
            ;;    ' ')   printf "%14s | " ""
            ;;    'A')   printf "%14s | " "added"
            ;;    'M')   printf "%14s | " "modified"
            ;;    'D')   printf "%14s | " "deleted"
            ;;    'T')   printf "%14s | " "type changed"
            ;;    'R')   printf "%14s | " "renamed"
            ;;    'C')   printf "%14s | " "copied"
            ;;    'U')   printf "%14s | " "unmerged"
            ;;      *)   clog "must classfied"  "${line}"
            esac
            case ${line:1:1} in
                 help)   :
            ;;    '?')   printf "%-14s -- \t%s\n" "untracked" "${line:3}"
            ;;    '!')   printf "%-14s -- \t%s\n" "ignored" "${line:3}"
            ;;    ' ')   printf "%-14s -- \t%s\n" "tracked" "${line:3}"
            ;;    'A')   printf "%-14s -- \t%s\n" "added" "${line:3}"
            ;;    'M')   printf "%-14s -- \t%s\n" "modified" "${line:3}"
            ;;    'D')   printf "%-14s -- \t%s\n" "deleted" "${line:3}"
            ;;    'T')   printf "%-14s -- \t%s\n" "type changed" "${line:3}"
            ;;    'R')   printf "%-14s -- \t%s\n" "renamed" "${line:3}"
            ;;    'C')   printf "%-14s -- \t%s\n" "copied" "${line:3}"
            ;;    'U')   printf "%-14s -- \t%s\n" "unmerged" "${line:3}"
            esac
            #printf "%${width}s\n" "${item}"
            #index=$(( ++index % ${#cmd[@]} ))
    ##done <<< "${line}"; done
    done
}



function gittcommit(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: number of commit
# $2: other option such as --all (all branch)
    local cmd="$1"
    local opt="${@:2}"
    case $cmd in
       auto)    msg=$(date +"%y%m%d:%H%M")
                git commit -m "${msg}: ${opt:-test}"
                git show --stat --oneline HEAD
                clog "[run]" "git push $GITT_REMOTE HEAD:refs/heads/${GITT_BRANCH}"
    ;; reset)   gittreset help
    ;; info)    formatprint git status -s --porcelain
                printf "\n\n"
                read -p "to see diff with cached in detail [ enter:compare| line:compare with line | q(ctrl+c):break ]: "
                case "$REPLY" in
                    help) clog "you can use with options:" "git diffi --line-numbers"
                ;;  line) git difftool --extcmd 'icdiff --line-numbers'
                ;;  *) git difftool --extcmd 'icdiff'
                esac
                if [ $? -ne 0 ];then echo "need to install 'sudo apt-get install icdiff'"; fi
    ;; help|*)    cat <<-EOF
				usage) gitt commit info         # show commit info and diff with cached
				usage) gitt commit auto         # add auto commit
				   ex) gitt commit auto misc    # add auto commit with msg 'misc'
				usage) gitt commit reset        # show useful reset command

				 info) gitt diff                # diff advanced with HEAD, HEAD^, staged, unstaged, revision
				 info) gitt info                # overall info for current git
				 info) gitt branch info         # branch info
EOF
    esac
}



function gittbranch_info(){
## ---------------------------------------------------------------------------
# show branch local & remote
# $1 all or filter

    ## local branch
    #list option must be wrapped with quoat ex) --list '*relese*'
    bar inline "info: branch local"
    clog "[local]" "* marked is current branch"
    showRUN git branch -vv

    ## remote branch
    bar inline "info: branch remote"
    clog "[remote]" "tracking branch"
    echo ${GITT_BRANCH}

    ## remote branch which are same to local HEAD
    bar inline "find remote branch which are at same local HEAD"
    clog "[always latest]" "read from remote live"
    git ls-remote -h ${GITT_REMOTE}| grep $(git log -1 --pretty=format:%H%n)
    if [ $? -eq 0 ]; then warn "local branch is same to remote branch";
    else warn "there is no remote branches same to current HEAD pointing, please below log"; fi

    bar inline "git log all branches cmd:'git loga' "
    git loga
}



function gittbranch_list(){
## -------------------- -------------------------------------------------------
# show branch local & remote
# $1 all or filter
    local opt=$1
    local filter

    read -p "'git fetch' is needed to get recent branch details [enter:continue| ctrl+c:break] :"
    git fetch
    bar inline "remote tag] recent 20 by date (bottom is newest create tag)"
    echo "get all branches and sort by date recent its tag"
    showRUNQ "git for-each-ref --color=always --sort=creatordate refs/tags \
    --format='%(color:yellow)%(committerdate:short) %(color:red)%(objectname:short) %(color:green)%(refname:short) %(color:blue)%(authorname)%(color:reset) %(contents:subject)' | tail -20"


    bar inline "remote branch] recent 20 by date (bottom is newest commit added)"
    showRUNQ "git for-each-ref --color=always --sort=committerdate refs/remotes \
    --format='%(color:yellow)%(committerdate:short) %(color:red)%(objectname:short) %(color:green)%(refname:short) %(color:blue)%(authorname)%(color:reset) %(contents:subject)' | tail -20"


    # echo "branch: remote all with filter (${filter:-all}) in remote repository"
    # set -o noglob
    # [ -z "${opt}" ] && filter="" || filter="--list *${opt}*"
    # set +o noglob

    # bar inline "lookup remote branch ${filer}"

    # clog "[always latest]" "read from remote live"
    # showRUN git ls-remote -h ${GITT_REMOTE} refs/heads/${opt} | more -60

    under "find: sort by recently updated branches by new commit findkey: ${opt:-'*'} (bottom is newest commit added)\n"
    # echo "shows the branches downloaded when git fetch equivalent command was executed"
    # clog "run 'git pull'" "to fetch all latest remote branches"
    #set -o noglob
    #[ -z "${opt}" ] && filter="" || filter="--list *${opt}*"
    #showRUN git branch -rvv --sort=committerdate ${filter} | more -60
    #set +o noglob
    showRUNQ git branch -rvv --sort=committerdate --list ${opt} | tail -60
}


function gittbranch(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 command
# $2 branch name or branch postfix
    local cmd=$1
    local name=$2
    local target=$3

    case $cmd in
       help) cat <<- EOF
				usage) gitt branch info                         # show current branch info
				usage) gitt branch list <''|name-filter>        # show remote recent 20 tag/branches
				   ex) gitt branch list *my*                    # find branches including 'my'
				usage) gitt branch create|new <name>            # create new branch with exact-name, with confirm
				usage) gitt branch delete|remove <name>         # delete branch with exact-name, with confirm 'y'
				   ex) gitt branch create my_temp_branch        # create my_temp_branch, with confirm 'y'

				 info) gitt diff                                # see gitt diff to compare branch
EOF
    ;; create|new)  if [ -z "${name}" ]; then err "branch name must be input" && return 1;fi
                bar inline "create branch: new branch will be created from current HEAD"
                showRUNQ y git push ${GITT_REMOTE} HEAD:refs/heads/${name}
    ;; delete|remove)  if [ -z "${name}" ]; then err "branch name must be input" && return 1;fi
                bar inline "delete branch: branch [${name}] will be removed from REMOTE"
                showRUNQ y git push ${GITT_REMOTE} --delete ${name}
    ;; info)    gittbranch_info
    ;; list)    #test case all) gitt branch list, gitt branch list '*', gitt branch list '*mas*',  exact) gitt branch list m/master, gitt branch list 'm/master'
                #gittbranch_list \'"${name:-*}"\'
                set -o noglob
                gittbranch_list "${name:-*}"
                set +o noglob
    ;; *) gittbranch help
    ;; esac
}



function gittfind(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: regexp or string
# $2: file, dir and area
    local keyword="$1"
    local area="${@:2}"

    case $keyword in
    ''|help) cat <<- EOF
				usage) gitt find '<string>'                     #find <string> in committer, message, code-diff
				                                                #please brace string with single quoat('~~~')
				   ex) gitt find 'docker' dock                  #find string 'docker' in file 'dock'
EOF
             return 0;
    ;; *)   bar outline "search in commit with regexp(${keyword}) in files(${area:-file list or path})"
    esac

    source <(cat <<\EOL
    under "find string(${keyword}) in committer in history(${area:-all})\n"
    echo "ex) git log --author=".*${keyword}.*" ${area}"
    echo "ex) git log --owner=".*${keyword}.*" ${area}"
    checkifSHA ${keyword} &&  git log -1 ${keyword}
    showRUN git log --committer=".*${keyword}.*" ${area}
    

    under "find string(${keyword}) in commit message of history (${area:-all}) with file-changes\n"
    showRUN git log -i --name-status -F --grep="${keyword}" ${area}

    under "find string(${keyword}) in commit diff in file history(${area:-all}) \n"
    echo "ex) git grep -e regexp1 --or -e regexp2"
    echo "ex) git grep -e regexp1 --and -e regexp2"
    showRUN git grep -n "${keyword}" ${area}
    
    under "find function(${keyword}) in file history(${area:-all}) \n"
    read -p "[enter:continue| ctrl+c:break]"
    showRUN git log -L :${keyword}:${area}
EOL
)

    ## show commit diff including keyword
    #git log -p -S"${keyword}" ${area}

    ## find string in function
    #under "find string in :fuction:file\n"
    #showRUN git log -L :"${keyword}":"${area}"
    ##run echo

}



function gittdiff(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 command
# $2 branch name or branch postfix
    local cmd="$1"
    local path="$2"
    local rev1="$3"
    local rev2="$4"

    local cmd_diff="git difftool"

    if command -v icdiff > /dev/null ; then cmd_diff="git difftool --extcmd icdiff";fi
    if [ -z "${path}" ]; then path=.;fi

    case $cmd in
    help) cat <<- EOF
				 info) if default <path> is omitted, . (current dir) will be used
				usage) gitt diff work <path>                        #  staged >>> diff <<< unstaged(workspace)
				usage) gitt diff staged <path>                      #    HEAD >>> diff <<< staged
				usage) gitt diff HEAD <path>                        #    HEAD >>> diff <<< unstaged & staged(add empty path)
				usage) gitt diff HEAD^ <path>                       #    HEAD >>> diff <<< HEAD^
				usage) gitt diff branch <path> <branchA> <branchB>  #branch A >>> diff <<< branch B, <path> is mandatory
				   ex) gitt diff branch . vgit_na/tsu_25.5my_release vgit_na/tcua_release
				usage) gitt diff commit <path> <commitA> <commitB>  #commit A >>> diff <<< commit B, <path> is ignored
				   ex) gitt diff commit . HEAD^ 03c2df

				flow) gitt branch list                              # find remote branch name : origin/master
				      gitt fetch                                    # get all branch for comparing
				      gitt diff branch . HEAD origin/master         # compare current branch to origin/master
				      gitt diff branch . default origin/master      # compare default branch to origin/master
EOF
    ;;  work)   under "      staged >>> diff <<< unstaged\n"
                showRUNQ ${cmd_diff} -- ${path} |more -60
    ;;staged)   under "        HEAD >>> diff <<< staged\n"
                showRUNQ ${cmd_diff} --cached -- ${path} |more -60
    ;;HEAD|head)     under "        HEAD >>> diff <<< unstaged/staged\n"
                warn "automatically 'git add empty path' to show diff untracked new file"
                git add -N . #to compare new untracked file
                showRUNQ  ${cmd_diff} HEAD -- ${path} |more -60
    ;;HEAD^|head^)   under "        HEAD >>> diff <<< HEAD^ \n"
                #= showRUN ${cmd_diff} @ @^ ${path}
                showRUNQ ${cmd_diff} HEAD HEAD^ ${path} |more -60
    ;;branch)   under "    branch A >>> diff <<< branch B \n"
                warn "to see remote branch, run 'gitt branch list'"
                showRUNQ ${cmd_diff} ${rev1} ${rev2} ${path} |more -60
    ;;commit)   under "    commit A >>> diff <<< commit B \n"
                showRUNQ ${cmd_diff} ${rev1}..${rev2} |more -60
    ;;  file)   under "    current >>> diff <<< current-1 \n"
                showRUNQ ${cmd_diff} @:${path} @^:${path} |more -60
    ;;  *|'')   gittdiff help
    ;; esac
}



function gittreset(){
## ---------------------------------------------------------------------------
# reset git repositories
# $1 target

    local cmd=$1
    case ${cmd} in
        clear)   showRUNQ y "git reset --hard @{upstream} && git clean -xdf"
  
    ;; help|*)   cat <<-EOF
				usage) gitt reset clear #remove all changes and reset with comfirm 'y'
				usage) gitt reset       #show detail reset commands below, run manully.

				info) git reset flow
				1) git log: check reset point in repository
				2) git reset <rev> <option>
				   current : workspace index repository | description
				   -----------------------------------------------------------------------------------------------------
				    --soft : workspace index <<<<       | keep commit & file, could retry from 'git push'
				    --mixed: workspace <<<<             | keep only  file, could retry from 'git add' (default)
				    --hard : <<<<                       | remove all, need to retry from scratch
				3) retry from each step
				flow) git log> git reset c3cef36787        > add modification> git add -A> git commit        > git push
				flow) git log> git reset c3cef36787 --soft > add modification> git add -A> git commit --amend> git push
				info) 'git reset --hard' restored by this 'git reflog > git reset --hard <relog rev>'
EOF
    esac
}


## revv ======================================================================================================================
function revvcheck_server(){
## ---------------------------------------------------------------------------
# check gerrit is permitted for input user on git project > branch
# usage) revv connect na joongkeun.kim tiger/tools tiger_release
# $1: target user
# $2: target review system
# $3: gitproject (if it is 'checkapi', it check only API validation)
# $4: branch

    local server=$1
    local user=$2
    local oriproject=$3 ;
    local gitproject=${oriproject//'/'/'%2F'}
    local branch=$4
    local key_id=$(getserver ${server} sub)
    local key=$(ende_code dev ${key_id})
    local status

    #local port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)')
    if [ -z "${server}" ];
    then port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)'); server=$(getserver ${port} http)
    else port=$(getserver ${server} port); server=$(getserver ${server} http);
    fi

    [ "${oriproject}" != "checkapi" ] && (
    bar inline "step2.1-gerritserver: [remote] check if gerrit server is active by $ACCOUNT"
    clog solution "check gerrit service is online from web"
    )
    status=$(curl -su ${ACCOUNT}:${key} ${server}/a/config/server/version )
    case ${status} in
    *[2-9].[0-9].[0-9]*)   echo "ok. version is verified " > /dev/null;;
    *)                     err "gerrit is not working, please check"; return 1;;
    esac

    [ "${oriproject}" = "checkapi" ] && return 0

    bar inline "step2.2-gerritserver: [remote] check if gerrit is accessed by ${user} (default: input>current>vgit-na)"
    clog solution "check gerrit current account in gerrit system"
    if [ -z "${oriproject}" ];then info "usage) repp connect testaccount na tiger/tools tiger_release" && return 1;fi
    if [[ "$oriproject" == *.git* ]]; then err ".git postfix must be removed in [$oriproject]" && return 1; fi
    status=$(curl -su ${ACCOUNT}:${key} ${server}/a/accounts/?suggest\&q=${user})
    [[ "$status" =~ "_account_id" ]] &&  echo "gerrit account existed [${user}]" || ( err "create gerrit account [${user}] by login" && return 1)


    bar inline "step2.3-gerritserver: [remote] check if git project is accessed by ${user} (default: input>current>manifests)"
    clog solution "check git name path is correct and can access"
    status=$(curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject})
    [[ "$status" =~ "ACTIVE" ]] &&  echo "git existed and accessed [${oriproject}]" || ( err "check git project path [${oriproject}]" && return 1)

    bar inline "step2.4-gerritserver: [remote] check if branch is accessed by ${user} (default: input>current>master)"
    clog solution "check branch name path is correct and can access"
    [ -z "${branch}" ] && branch="master"
    status=$(curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject}/branches?m=${branch})
    [[ "$status" =~ "ref" ]] &&  echo "branch existed and accessed [${branch}]" || ( err "check git branch is existed or permission allowed [${branch}]" && return 1)
    
    return 0
}



function revvinfo(){
## ---------------------------------------------------------------------------
# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local server=$(getserver ${1:-na} http)
    local key=$(ende_code dev $1)
    local usercmd=${2-${ACCOUNT}}
    local gitproject=${3//'/'/'%2F'}
    #local branch=$4

    case ${usercmd} in
       help)    cat <<-EOF
				usage) revv info                                   #show gerrit POST command
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) echo "default functionality"
    ;; esac
}



function revvgerrit(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    local server=$(getserver ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local key=$(ende_code dev $(getserver ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub))
    local source=${3:-$USER}
    local target=$4
    local extra=$5
    local file=$(mktemp)


    #local branch=$4

    local SEP='~'
    case ${cmd}${SEP}${subcmd} in
           *~help)
            echo "check your cmd [${cmd}]"; cat <<-EOF
			usage) revv user      na joongkeun.kim                             # check account is existed and its groups
			   ex) revv user      na joon                                      # check all accounts named joon
			usage) revv sshkey    na joongkeun.kim                             # get registered SSH-KEY
			usage) revv group     na sa515m_developer                          # check group existance and list sub-groups & all members            
			   ex) revv group     na sa515m_                                   # find groups named sa515m_
			usage) revv groupadd  na sa515m_developer joongkeun.kim            # add member to group
			usage) revv groupdel  na sa515m_reviewer  joongkeun.kim            # delete member from group
			usage) revv groupmem  na sa515m_reviewer  joongkeun.kim            # check member is in group and its sub-groups
			usage) revv project   na mustang/tm/src                            # find project with project-name
			usage) revv project   na vendor/qct/sa515m/_lge_only               # find project and its child projects
			usage) revv projectadd na sample/target sample/parent              # add git project from parent            
			usage) revv projectadd na sample/target                            # add git project from All-project
			usage) revv projectdel na sample/target                            # get remove page url in gerrit
			usage) revv branch    na mustang/tm/src tsu_25.5my_release         # find branch with branch-name
			usage) revv branchadd na mustang/tm/src tsu_25.5my_release_new     # create branch
			usage) revv branchdel na mustang/tm/src tsu_25.5my_release_new     # remove branch
			usage) revv commit    na 57a4eeeca914                              # get change_id
EOF
    ;;      user~*)
            bar inline "check if account is existed & get account info "
            curl -su ${ACCOUNT}:${key} ${server}/a/accounts/?suggest\&q=${source} |sed '1d'| jq '.'
            bar inline "list group name which account belongs to"
            curl -su ${ACCOUNT}:${key} ${server}/a/accounts/${source}/groups |sed '1d'| jq -cC '.[]|{name, created_on}' | more -60

    ;;    sshkey~*)
            bar outline "get registered SSH-key for account [${source}] in server [$server]"
            curl -su ${ACCOUNT}:${key} ${server}/a/accounts/${source}/sshkeys |sed '1d'| jq -cC '.[]|{ssh_public_key, comment}'

    ;;     group~*)
            bar inline "find group by name"
            curl -su ${ACCOUNT}:${key} ${server}/a/groups/?m=${source} |sed '1d'| jq '.'
            bar inline "list sub-group by ${source} group"
            curl -su ${ACCOUNT}:${key} ${server}/a/groups/${source}/groups/ |sed '1d'| jq -c '.[]|{name, created_on}'
            bar inline "show group member by ${source} group to its decendents"
            curl -su ${ACCOUNT}:${key} ${server}/a/groups/${source}/members?recursive |sed '1d'| jq -cC '.[]|{name, email}'  | more -60

    ;;  groupadd~*)
            bar outline "add member to group"
            curl -su ${ACCOUNT}:${key} ${server}/a/groups/${source}/members/${target} -X PUT

    ;;  groupdel~*)
            bar outline "delete member from group"
            curl -su ${ACCOUNT}:${key} ${server}/a/groups/${source}/members/${target} -X DELETE

    ;; groupmem~*)
            bar outline "find member from group"
            curl -su ${ACCOUNT}:${key} ${server}/a/groups/${source}/members|grep ${target}

    ;;  project~*)
            dlog "[guide] To create/delete project (visit):" "${server}/admin/repos/${source}"
            dlog "[guide] To see project config (run cmd):" "curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'} | sed '1d'| jq  -C '.[]'"
    
            bar inline "find project and show project url"
            curl -su ${ACCOUNT}:${key} ${server}/a/projects/?m=${source} |sed '1d' > $file
            clog "matching project: "  $(cat $file| jq -c 'keys[]')
            cat $file| jq --arg jq_var ${VGIT} -c '"link: http://" + $jq_var + .[].web_links[].url'
            
            bar inline "parent-project info"
            curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'} |sed '1d' | jq -cC '.|{name,parent}'
            curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'}/access |sed '1d' > $file
            cat $file| jq --arg jq_var "${server}/admin/repos/" -c '"link: " + $jq_var + .inherits_from.name'
            cat $file| jq -cC '.inherits_from|{name,parent}'
            
            bar inline "parents group info"
            cat $file| jq -cC .groups[]
            
            read -p "enter to continue"
            bar inline "parents permission info"
            cat $file| jq -C .local

            bar inline "child-project info inherited from ${source}, plz wait..."
            curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'}/children/?recursive| sed '1d'| jq  -cC '.[].name' | more -60
            printf "\n\n"

    ;;projectadd~*)
            bar inline "check if project already existed"
            local temp=$(curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'} |sed '1d' | jq -cC '.name')
            if [ -n "${temp}" ]
            then err "[${temp}] already legacy project existed" && return 1; 
            else clog "passed, no legacy project" "ok, continue to create"
            fi
            
            if [ -n "${target}" ]; then
                temp=$(curl -su ${ACCOUNT}:${key} ${server}/a/projects/${target//'/'/'%2F'} |sed '1d' | jq -cC '.name')
                if [ -z "${temp}" ]; then err "but no parent project, stop to create"; return 1; fi
            fi
            
            bar inline "add new project"
            curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'}  -X PUT |sed '1d' > $file
            clog "result for creaing project: "  
            cat $file| jq -C . 
            [ -z "${target}" ] && (warn "git created whose parent is All-project(default)" && return 0)
            bar inline "changing parent from All-projects(default)"
            curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'}/parent -H "Content-Type: application/json" --data "{\"parent\":\"${target}\"}" -X PUT > $file
            clog "result for changing parent: "
            cat $file| sed '1d'| jq . | more -60
            printf "\n\n"

    ;;projectdel~*)
            bar inline "check if project already existed"
            local temp=$(curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'} |sed '1d' | jq -cC '.name')
            if [ -n "${temp}" ]
            then clog "[${temp}] already legacy project existed" "ok, please remove manually" 
            else err "no existing project, stopped" && return 1
            fi
    
            bar inline "'removing project' by CLI is not supported in gerrit"
            dlog "so only provide url link, you cand remove git project there"
            dlog "[guide] To delete project (visit):" "${server}/admin/repos/${source},commands"
            printf "\n\n"

    ;;   branch~*)
            bar inline "find branches by name"
            curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'}/branches/?m=${target} | sed '1d'| jq  -cC '.[]|{ref,revision}' | more -60

    ;;branchadd~*)
            bar inline "create branch with base revision"
            if [ -z "${extra}" ]; then read -p "input base branch which new branch is created from: ";fi
            showRUNQ y curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'}/branches/${target} -H "Content-Type:application/json" --data "{"revision":"${extra:-${REPLY}}"}"  -X PUT

    ;;branchdel~*)
            bar inline "delete branch by name"
            showRUNQ y curl -su ${ACCOUNT}:${key} ${server}/a/projects/${source//'/'/'%2F'}/branches/${target} -X DELETE
            
    ;;commit~*)
            local change_id=$(curl -su ${ACCOUNT}:${key} ${server}/a/changes/${source} |grep -oP '(?<=change_id": ").*(?=")')
            if [ -z "${change_id}" ]; then 
                err "NOT Found: change_id for commit_id[${source}]"
                echo "this commit is not registered in gerrit system. ex) direct pushed"
                return 1; 
            fi
            curl -su ${ACCOUNT}:${key} ${server}/a/changes/?q=${change_id}
    ;;*)    err "please check command ex)revv project help, revv branch help"
    esac
}



function revvforall(){
## ---------------------------------------------------------------------------
# repoforall for revv
# ex) revv forall branch vgit_na              #check branch ${REPO_RREV}
# ex) revv forall branchadd vgit_na _temp     #check branch ${REPO_RREV}_temp
# ex) revv forall branchdel vgit_na _temp     #check branch ${REPO_RREV}_temp
# $1 account
# $2 server
# $3 gitproject
# $4 branch
###### *는 쓰지말자. 대신 명시적으로 써야 한다. @all, @curr 등으로 사용하자
    local cmd=$1
    local target=$2 #no need * for all file in gerrit, remove
    local source=$3
    local key=$(ende_code dev $(getserver ${GITT_REMOTE:-${REPP_REMOTE}} sub))

    case $cmd in
        help) cat <<-EOF
			usage) revv forall <cmd> <target_branch> <base_branch>
			 info) Pcmd: print all command without run
			       Ocmd: print 1st command without run
			       Dcmd: run 1st command & debug info & exit
			 info) @branch: current branch, @remote: current remote, @project: current project
			 info) use 'revv forall setgit' to apply specific gits, this setting is remained,  
			   ex) revv forall setgit        .                           # repo forall . (for current project)
			   ex) revv forall setgit sample/poky sample/meta-browser    # repo forall some projects (for only input projects)
			   ex) revv forall setgit                                    # reset, therefore all gits is applied

			   ex) revv forall branch        master                      # check if branch(master) exist
			   ex) revv forall Ebranch       master                      # check if branch(master) exist, if error occurred, will stop.
			   ex) revv forall Pbranch       master                      # print command without running
			   ex) revv forall Dbranch       master                      # print debug info with running 1st cmd
			   ex) revv forall branch        @branch                     # check if current branch is existed in remote
			   ex) revv forall branchlist                                # print all branches
			   ex) revv forall branchlist    '*my*'                      # print all branches including 'my'
			   ex) revv forall branchlist    mas                         # print all branches including 'mas'
			   ex) revv forall branchadd     new master                  # create branch 'new' based from 'master'
			   ex) revv forall branchadd     @branch master              # create branch as written in manifest revision from master
			   ex) revv forall branchaddpre  new_ @branch                # create branch with name of new_<current_branch> from current
			   ex) revv forall branchaddpost _new @branch                # create branch with name of <current_branch>_new from current
			   ex) revv forall branchaddpost _new master                 # create branch 'master_new' from 'master'
			   ex) revv forall branchdel     master                      # delete branch 'master'
			   ex) revv forall branchdel     @branch                     # delete current branch (current remote branch)
			   ex) revv forall branchdelpre  new_ @branch                # delete branch with name of new_<current_branch> from current
			   ex) revv forall branchdelpost _new @branch                # delete branch with name of <current_branch>_new from current
EOF
            return 0
    ;; setgit)  info "setgit is delivered to 'repo forall <git list>', this setting is sustain until reset it"
                echo "flow) cat ${REPPFILE_CSV} |awk -F'|' {'print \$4'} > project.list"
                echo "flow) revv forall setgit \$(cat project.list) #select gits" 
                echo "flow) revv forall Pbranch master #do job for any selected gits"
                echo "flow) revv forall setgit #reset, remove selected git setting" 

                echo "flag_forall=${@:2} #print selected gits" ; #setgit is all next cmd from @:2
                source  <(echo 'flag_forall="${@:2}"'); return 0
    ;; *branch*|Ebranch*|Pbranch*|Obranch*|Dbranch*) :
    ;; project|Eproject*|Pproject*|Oproject*|Dproject*) :
    ;;      *)  err "please check usage: not registerd cmd, use 'revv forall help' "; return 1
    esac

    set -o noglob
    local tempr=/tmp/revv.ret
    if [ -f "${tempr}" ]; then rm -f "${tempr}"; touch "${tempr}"; fi
    #test case all) revv forall branchlist, gitt branch list '*', revv forall branchlist '*mas*'
    [[ "${target}" =~ "*" ]] && clog "[warn]" "asterisk * is not permitted in gerrit, automatically removed"
    case ${cmd::1} in
    D|O|E) repo forall ${flag_forall} -evcj4 bash 'revvscript.sh' $cmd ${key} ${target//\*/} ${source}
    ;;P|*) repo forall ${flag_forall}  -vcj4 bash 'revvscript.sh' $cmd ${key} ${target//\*/} ${source}
    esac


    read -p $'\n\nshow result log: [ctrl+c: exit | enter: continue]? '
    bar inline ""
    cat ${tempr} |grep --color=always FAIL | tee /dev/tty | wc -l
    bar inline ""
    cat ${tempr} |grep --color=always OKAY | tee /dev/tty | wc -l
    #pr -2 -t <(cat ${tempr} |grep FAIL)
    set +o noglob
}


function revvcmd(){
## ---------------------------------------------------------------------------
# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local server=$(getserver ${cmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local key=$(ende_code dev $(getserver ${GITT_REMOTE:-${REPP_REMOTE}} sub))
    local usercmd=${2-${USER}}
    local oriproject=${3:-${GITT_PROJECT:-${REPP_PROJECT}}}
    local gitproject=${oriproject//'/'/'%2F'}
    #local branch=$4

    case ${cmd} in
       help)    cat <<-EOF
				usage) revv cmd help                                    #show account info from gerrit server
				usage) revv cmd <server> <account> <gitproject>         #make gerrit POST command
				   ex) revv cmd eu joongkeun.kim mustang/tm/src         #make gerrit POST command with parameter
				   ex) revv cmd eu joongkeun.kim
				   ex) revv cmd eu
				   ex) revv cmd
EOF
            bar outline "info gerritserver: show gerrit account"
            showRUN curl -su ${ACCOUNT}:${key} ${server}/a/accounts/?suggest\&q=${usercmd} |more

    ;; *)
            bar outline "show gerrit account commands"
            cat <<-EOF
			## check if <user> account is existed           ex) curl -su ${ACCOUNT}:${key} ${server}/a/accounts/?suggest\&q=${usercmd}| more
			## list group <user> belongs to                 ex) curl -su ${ACCOUNT}:${key} ${server}/a/accounts/${usercmd}/groups |sed '1d'| jq  '.[].name'| sort |more
			## find group which has string <group-name>     ex) curl -su ${ACCOUNT}:${key} ${server}/a/groups/?m=<group-name>

			## show group member for <group-name>           ex) curl -su ${ACCOUNT}:${key} ${server}/a/groups/<group-name>/members?recursive
			## list sub-group in <group-name>               ex) curl -su ${ACCOUNT}:${key} ${server}/a/groups/<group-name>/groups/
			## add account to group                         ex) curl -su ${ACCOUNT}:${key} ${server}/a/groups/<group-name>/members/${usercmd} -X PUT
			## check account is existed in <group-name>     ex) curl -su ${ACCOUNT}:${key} ${server}/a/groups/<group-name>/members|grep ${usercmd}
			## remote accout from group                     ex) curl -su ${ACCOUNT}:${key} ${server}/a/groups/<group-name>/members/${usercmd} -X DELETE
			## get ssh-key for specific account             ex) curl -su ${ACCOUNT}:${key} ${server}/a/accounts/${usercmd}/sshkeys
EOF
            bar outline "show gerrit project which name has <project-name>"
            cat <<-EOF
			##find git project named <gitproject>           ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/?m=${gitproject:-"<project-name>"}
			##find labels, parents[id], basic info          ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}
			##find child projects of <project name>         ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/children/?recursive| sed '1d'| jq  '.[].name'
EOF
            bar outline "show gerrit branch which name has <branch-name>"
            cat <<-EOF
			##list branches including named <branch>        ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/branches/?m=<branch-name>
			##remove branch                                 ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/branches/<branch-name> -X DELETE
			##create branch with base revision              ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/branches/<branch-name> -H "Content-Type: application/json" --data '{"sha": "049405ab2885e6c6844b212f83b43f835c904"}'  -X PUT
EOF
            bar outline "show gerrit tag which name has ${tag}"
            cat <<-EOF
			##list tag named <tag-name>                     ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/tags?m=<tag-name>
			##show tag date, tag revision, committer        ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/tags/<tag-name>
EOF
            bar outline "show gerrit commit with branch info"
            cat <<-EOF
			##show commit msg with data, author, committer  ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/commits/<full-sha-code>
			##show branches that commit beloings to         ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/commits/<full-sha-code>/in
			##show files that commit has changed            ex) curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/commits/<full-sha-code>/files
			##show all hashtaged commit                     ex) curl -su ${ACCOUNT}:${key} ${server}/a/changes/?q=hashtag
			##show hastag with HITT or TAT2                 ex) curl -su ${ACCOUNT}:${key} ${server}/a/changes/?q=hashtag:HITT+OR+hashtag:TAT2
EOF
    esac
}



function revvserver(){
## ---------------------------------------------------------------------------
# find replication server
# $1 server-url
# $2 port-number
    local server_port=${REPP_URL#*@}
    local server=${1:-${server_port%:*}}
    local user=${2:-${USER}}
    local port=${3:-$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')}

    if [ -z "${server}" ] || [ -z "${port}" ] ; then info "usage) revv server vgit.lge.com 29999"; return 1;fi
    ping $server -s 1016 -c 4 -A
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    if [ $? -ne 0 ]; then continue; fi
    ssh ${user}@$server -p $port -o ConnectTimeout=2 -o ConnectionAttempts=1 gerrit show-caches
    if [ $? -ne 0 ]; then continue;fi
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    echo "please check 1) ipg/ewma from ping, 2) AvgGet from gerrit connection"
}



function revvdebug(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local server=$(getserver ${1:-na} http)
    local key=$(ende_code dev $2)
    local cmd=${2-${ACCOUNT}}
    local gitproject=${3//'/'/'%2F'}
    #local branch=$4

    case ${usercmd} in
       help)    cat <<-EOF
				usage) revv info                                   #show gerrit POST command
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) echo "default functionality"
    ;; esac
}




##==========================================================================================================================
## below functions allow parameter "*, ?, +, ..." with non-globbing option
#__noglob() { $@; set +o noglob ;}
#must enable globbing within fuction at the begining.
#alias revv='set -o noglob; revv'
#alias gitt='set -o noglob; gitt'
#alias repp='set -o noglob; repp'

##==========================================================================================================================
function revv(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1: command
# $2: server
# $3: account

#set +o noglob
local MENU=(
"     info: shows repository info such as manifest path, repo cmd, tree of manifests, etc"
"      cmd: list useful command from gerrit"
"  connect: check if input account can access branch in gitproject on server"
"   server: check delay from server or confirm the server status"
"    debug: show variable REPO, REPP, REPPFILE, GITT variable used in script"
"   forall: repoforal for revv branch commands"
"     user: check if account is existed & get account info "
"   sshkey: get registered SSH-key for an account in server "
"    group: find group by name"
" groupadd: add member to group"
" groupdel: delete member from group"
" groupmem: find member from group"
"  project: find project and show project url"
"   branch: find branches by name"
"branchadd: create branch with base revision"
"branchdel: delete branch by name"
)

local ret=0
case "$1" in
     ##$1:cmd        ${@:2}:parameters
          help)                                            reppmenu help "${MENU[@]}"
    ;;      '')                                            reppmenu revv "${MENU[@]}"
    ;;     cmd)      reppcheck_initvar reppgittrevv    &&  revvcmd "${@:2}"
    ;;  server)      reppcheck_initvar gittrevv        &&  revvserver "${@:2}"
    ;; connect)      reppcheck_initvar gittrevv        &&  revvcheck_server "${@:2}"
    ;;    info)      reppcheck_initvar gittrevv        &&  revvinfo  "${@:2}"
    ;;   debug)      reppcheck_initvar gittrevv        &&  revvdebug "${@:2}"
    ;;  forall)      reppcheck_initvar repprevv        &&  revvforall "${@:2}"
    ;;       *)      reppcheck_initvar repprevv        &&  revvgerrit "${@:1}"
esac
return $ret
}



##==========================================================================================================================
function gitt(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
#set +o noglob
local MENU=(
"   info: shows git path, gerrit info/url/remote, push command, commit info, sync time"
"   show: shows git (default 15) commits history, file change list"
"     go: move dir to repo root, git root, manifest dir or specific git"
" commit: git auto commit or show commit info (change file list and diff view)"
" branch: lookup, create, delete remote branch"
"   find: find string(changes) in commit history by multiple way."
"   diff: compare commit, branch with dir/file"
"  reset: reset git repository by choices"
"  debug: show GITT & REPO variable"
)
local ret=0
case "$1" in
    ##$1:below ${@:2}:parameters
          help)                                     reppmenu help "${MENU[@]}"
    ;;      '')                                     reppmenu gitt "${MENU[@]}"
    ;;    info)     reppcheck_initvar gitt      &&  gittinfo
    ;;    show)     reppcheck_initvar gitt      &&  gittshow "${@:2}"
    ;;      go)     reppcheck_initvar gitt      &&  gittgo "${@:2}"
    ;;  commit)     reppcheck_initvar gitt      &&  gittcommit "${@:2}"
    ;;  branch)     reppcheck_initvar gitt      &&  gittbranch "${@:2}"
    ;;    find)     reppcheck_initvar gitt      &&  gittfind "${@:2}"
    ;;    diff)     reppcheck_initvar gitt      &&  gittdiff "${@:2}"
    ;;   reset)     reppcheck_initvar gitt      &&  gittreset "${@:2}"
    ;;   debug)     reppcheck_initvar gitt      &&  gittdebug "${@:2}"
    ;;       *)     bar outline "call native git"       
                    git "${@}";;                        
esac                                                    
return $ret                                             
}                                                       



##==========================================================================================================================
function repp(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
#set +o noglob
local MENU=(
"   info: shows repository info such as manifest path, repo cmd, tree of manifests, etc"
"   show: shows uncommitted changes, top -1 commits, md5 sum for all repository"
"     go: move to repo root dir, manifest dir, git path nearby with similar depth"
" commit: shows latest commits(git log -1) from all repository (default 20)"
"   find: search(list) string in all (repo revision, remote, branch, project, path)"
" branch: show branch info, push remote branch, look-up remote-branch"
"   mani: repo manifest handling"
"   init: repo init with automatic options"
"   sync: repo sync with optimized multi-job and options"
"  reset: reset all repositories to original state"
"version: check repo & python version and provide repo upgrade"
"connect: check the connection with git host server and accessibilty for branch of git"
"  debug: show variable REPO, REPP, REPPFILE, GITT variable used in script"
)

local ret=0
case "$1" in
     ##$1:cmd       check if validation                          ${@:2}:parameters
       help)                                                reppmenu help "${MENU[@]}"
    ;; '')                                                  reppmenu repp "${MENU[@]}"
    ;; info)        reppcheck_initvar repp              &&  reppinfo  "${@:2}"
    ;; show)        reppcheck_initvar repp              &&  reppshow "${@:2}"
    ;; go)          reppcheck_initvar repp              &&  reppgo "${@:2}"
    ;; commit)      reppcheck_initvar repp              &&  reppcommit "${@:2}"
    ;; find|list)   reppcheck_initvar repp              &&  reppfind "${@:2}"
    ;; branch)      reppcheck_initvar repp              &&  reppbranch "${@:2}"
    ;; mani)        reppcheck_initvar repp              &&  reppmani "${@:2}"
    ;; init)        reppcheck_initvar repp              &&  reppinit "${@:2}"
    ;; sync)        reppcheck_initvar repp              &&  reppsync "${@:2}"
    ;; reset)       reppcheck_initvar repp              &&  reppreset "${@:2}"
    ;; version)     reppcheck_initvar repp              &&  reppversion "${@:2}"
    ;; connect)     reppcheck_initvar reppgittrevv      &&  reppconnect "${@:2}"
    ;; debug)       reppcheck_initvar reppgittrevv      &&  reppdebug "${@:2}"
    ;; *)           bar outline "result of native repo";    repo "${@}"
esac
return $ret
}



function reppmenu(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
# $2 help array for each command
local cmd="$1"
local MENU=( "${@:2}" )


printf ${green}
cat << PREFACE
==============================================================
 welcome to gitt & repp & review
 -------------------------------------------------------------
 command usage: ex) gitt, gitt info, gitt show [currnet git]
 command usage: ex) repp, repp info, repp show [default.xml]
 command usage: ex) revv
 ex) repp info, repp find [string], repp sync 16 --force-sync, etc
 ex) gitt info, gitt find [string], gitt show, etc
 ex) revv info
 help: http://collab.lge.com/main/x/wY6wa
==============================================================
PREFACE
printf ${NCOL}

if [ "$1" = "help" ]; then
    for m in "${MENU[@]}"; do clog "${m%%:*}" "${m##*:}"; done
    return 0;
fi

local COLUMNS=60
PS3=$'\e[00;35m=== Please input command! [enter:menu, number:choice, ctrl+c:exit] === : \e[0m'
select CHOICE in "${MENU[@]}"; do
    $cmd ${CHOICE%%:*}
    if [ -n "$?" ]; then return 1;fi
done
}



function reppdebug(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'

    source <(cat <<\EOL
        bar inline "GITT_VARIABLE && REPP_VARIABLE for all repository"
        for var in \
        '${GITT_PROJECT}' '${GITT_REMOTE}' '${GITT_BRANCH}' '${GITT_REVIEW}' '${GITT_URL}' '${GITT_PATH}' \
        '${REPP_PATH}' '${REPP_ROOT}' '${REPP_REMOTE}' '${REPP_PROJECT}' '${REPP_BRANCH}' '${REPP_URL}' '${REPP_REPOURL}' '${REPP_MIRROR}' '${REPP_GROUPS}' '${REPP_COUNT}' \
        '${REPPFILE_STATUS}' '${REPPFILE_COMMIT}' '${REPPFILE_CSV}' '${REPPFILE_XML}' '${REPPFILE_MANI}'
        do
           dlog "$var\t" $(eval echo $var)
        done

        for (( i=0; i < ${#REPP_REMOTELIST[@]}; i++ )); do
            dlog "\${REPP_REMOTELIST[$i]}\t\t"   "${REPP_REMOTELIST[$i]}"
            dlog "\${REPP_REVIEWLIST[$i]}\t\t"   "${REPP_REVIEWLIST[$i]}"
        done

        bar inline "[${GITT_PROJECT}] print repo variable"
        showRUN repo forall . -c 'echo ${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'

        bar inline "[all repo] print repo variable"
        dlog                '${REPO_I}/${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'
        #repo forall -c 'echo ${REPO_I}/${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}' | more -60
        repo forall -j1 -c 'printf "%9.9s|%.6s|%.7s|%-32.32s|%-74.74s|%.80s\n" "${REPO_I}/${REPO_COUNT}" "${REPO_LREV}" "${REPO_REMOTE}" "${REPO_RREV}" "${REPO_PROJECT}" "${REPO_PATH}"' | more -60
EOL
)
    ##run echo
}



function gittdebug(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'

    source <(cat <<\EOL
        bar inline "GITT_VARIABLE && REPP_VARIABLE for this git"
        for var in \
        '${GITT_PROJECT}' '${GITT_REMOTE}' '${GITT_BRANCH}' '${GITT_REVIEW}' '${GITT_URL}' '${GITT_PATH}'
        do
           dlog "$var\t" $(eval echo $var)
        done

        bar inline "[${GITT_PROJECT}] print REPO variable using repo"
        showRUN repo forall . -c 'echo ${REPO_I}/${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'

EOL
)
    ##run echo
}



function gitthelp(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'

    case ${cmd} in
        help)   echo "print git help"
    ;;  area)   cat <<-EOF
				info) git area
				current : workspace      | index     |   local repository     remote repository
				-----------------------------------------------------------------------------------------------------
				          working area   | cached    |   history              remote
				          unstaged       | staged    |   commit
				          untracked      | tracked   |   tree

EOF
    ;;     *)   echo cat <<-EOF
				usage) gitt help area #show git area
				usage) gitt reset     #show detail reset commands
EOF
esac
}



##============================================================================
## Main
##============================================================================
GITT_REMOTE= &&GITT_PROJECT= &&GITT_BRANCH= &&GITT_REVIEW= &&GITT_URL= &&GITT_PATH=
REPP_PATH= &&REPP_ROOT= &&REPP_REMOTE= &&REPP_PROJECT= &&REPP_URL= &&REPP_BRANCH= &&REPP_REPOURL= &&REPP_MIRROR= &&REPP_GROUPS= &&REPP_COUNT= &&REPP_CMD=
REPP_REMOTELIST=()
REPP_REVIEWLIST=()
REPP_PATH_ALL=()

(return 0 2>/dev/null) && sourced=1 || sourced=0
if [ $sourced -eq 0 ]; then repp $@;
else  ##if sourced
    echo "[WELCOME] repp & gitt utility is applied for current shell"
    ##hide local function, need to implements
fi

