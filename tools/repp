#!/bin/bash
# ==========================================================================
#  readme    : repo utiliies
#  mail      : joongkeun.kim@lge.com, av9300@gmail.com
# ==========================================================================
##---------------------------------------------------------- DEBUG OPTION
#DEBUG=["echo -e"|:], : means no-operation
DEBUG=:
PATH_FULL=$(realpath "$BASH_SOURCE")
PATH_DIR="${PATH_FULL%/*}"
PATH_FILE="${PATH_FULL##*/}"
DIR_CURR=$(pwd)
LC_ALL=C.UTF-8

#suppress print path
pushd() { command pushd "$@" > /dev/null ;}
popd() { command popd "$@" > /dev/null ;}
NJOBS=$(( $(nproc --all) / 4))

$DEBUG "[$_][$BASH_SOURCE][$0]  [${PATH_FULL}][${PATH_DIR}][${PATH_FILE}]"

if [ -e "${PATH_DIR}/prelibrary" ]; then source ${PATH_DIR}/prelibrary;
else source ${proFILEdir}/tools/prelibrary; fi
#user setting
account=vc.integrator
path_mirror="/data001/${account}"/mirror


##--------------------------- Menu Functions --------------------------------
##============================================================================
#### oneline functions
gittis_gitdir(){ git -C "$1" rev-parse --is-inside-work-tree &> /dev/null ;}

function gittcheck_gitpath(){
## ---------------------------------------------------------------------------
    if [ "$1" = "print_y" ]; then git rev-parse --show-toplevel; 
    else git rev-parse --show-toplevel > /dev/null; fi
}


function reppcheck_gerritconnection(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
    echo "\$ $@" ;"$@"

    case $? in
     0) ;;
     1) echo Generic error, usually because invalid command line options or malformed configuration;;
     *) echo Gerrit Connection Error;;
    esac
}



function reppcheck_sshconnection(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
    local file_error=$(mktemp)
    echo "\$ ssh -T $1 -p $2" ;
    echo . | ssh -T $1 -p $2 2> ${file_error}

    case $(cat $file_error) in
     *success*) echo good, it works;;
     *publickey*) echo check publickey;;
     *) echo unknown error is occured;;
    esac

    #rm -f ${file_error}
}



function reppfind_initerror(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
    local file_error=$(mktemp)
    local ret=1 #return 1 is success, 0 is fail
    echo "\$ $@"
    time "$@" 2> >(tee -a ${file_error})
    #"$@" | tee -a ${file_error}

    grep -nEe "(fatal|fail|error)" ${file_error} >/dev/null
    if [ $? -eq 0 ]; then
        bar outline "check error"
        err "${file_error}"
        ret=0
    fi

    grep 'Permission denied (publickey)' ${file_error} >/dev/null
    if [ $? -eq 0 ]; then
        err "http://collab.lge.com/main/display/SWIFR/repo#publickey"
        ret=0
    fi

    #if [ $? -ne 0 ];then reppcheck_sshconnection ssh -p vc.integrator@vgit.lge.com:29430;fi

    return $ret
}



function reppfind_syncerror(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
# ex) reppfind_syncerror
    if [ -z "$1" ]; then
        read -p "Please input job number to repo sync [enter:auto| number:ex)16| ctrl+c:exit]: " njobs;
        if [ -z $njobs ]; then  njobs=${NJOBS}; fi
    else
        njobs=$1
    fi

    showRUN repo sync --no-tags --no-clone-bundle --fail-fast -qcj${njobs:-16} $2

    #"$@" 2> >(tee -a ${file_error})
    "$@" > >(tee -a ${file_error})
    case $? in
     0) ;;
     1) echo Generic error, usually because invalid command line options or malformed configuration;;
     2) echo Connection failed;;
     *) echo Unknown Error;;
    esac
}



function reppfind_repodir(){
## ---------------------------------------------------------------------------
## find input-path up and down,
## $1:path name, $2:max depth to sub dir
## ex) reppfind_repodir .repo 5
## ex) reppfind_repodir .git 2
    local T=$PWD
    local target=${1:-.repo}
    local down_depth=${2:-2} #default value:2
    local print=$3

    # find in sub directory with depth
    readarray -t REPO_PATH_ALL < <(find . -maxdepth ${down_depth} -path "*${target}" |sort)
    case ${#REPO_PATH_ALL[@]} in
    1)  # found sub dir
        REPO_PATH=$(readlink -f ${REPO_PATH_ALL[0]})
        ;;
    0)  # not found, so find in parent directory upto $HOME
        while [[ "${PWD}" =~ "${HOME}" ]]; do
            if [ -d ${target} ]; then break; fi
            pushd ..
        done
        if [ -d ${target} ]; then REPO_PATH=$(readlink -f ${target});else REPO_PATH='';fi
        pushd -0 && dirs -c
        cd $T
        ;;
    *)  # found multiple dir in sub dir
        if [ "$print" = "print_y" ]; then
            printf "subdir [%s]\n" ${#REPO_PATH_ALL[@]}
            printf "%s\n" ${REPO_PATH_ALL[@]};
        fi
        REPO_PATH=''
        ;;
    esac
}



function reppget_repcmd(){
## ---------------------------------------------------------------------------
# get repo command from exising repo project
# $1 show repo command (default: save info to each variable such as REPO_REMOTE, REPO_BRANCH, ...)
    local count file_tempa file_tempb

    if [ -z "${REPO_BRANCH}" ]; then
        printf "${RED}[warning] please check if you have switched to a topic branch from after repo init${NCOL}\n"
        printf "${RED}[warning] temporarily set to local branch name${NCOL}\n"
        printf "\tyou can set-up upstream branch with: git branch -u %s <branch-name>\n" "$(echo $(git remote -v |cut -f1))"
        REPO_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    fi

    # find using manifest.xml
    file_tempa=$(command ls -Art ../*.xml | tail -n 1)
    count=$(grep -c include ${file_tempa})
    if [ -L "${file_tempa}" ];then
        file_tempb=$(readlink "${file_tempa}")
        FILE_MANI=${file_tempb#*/}
    elif [ $count -eq 1 ]; then
        file_tempb=$(grep include $file_tempa |sed -E 's/<.*name="(.*)".\/>/\1/')
        FILE_MANI=${file_tempb// /}
    else
        FILE_MANI=default.xml
    fi

    if [ -n "$REPO_MIRROR" ];then EXTRA_OPTION="--reference=$REPO_MIRROR"; fi
    if [ "$1" = "info" ];then
        bar inline "repo-init cmd"
        log "repo init -u $REPO_REMOTE -b $REPO_BRANCH -m $FILE_MANI --repo-url=$REPO_URL $EXTRA_OPTION"
    fi
    return 0
}



function reppgo() {
## ---------------------------------------------------------------------------
# return git root path or return near git path
    local T=$(pwd)
    if [ "${REPO_ROOT}" = "${T}" ]; then 
        echo "your are in repo root, use 'repp find @path' to list up all repositories" && return 0; 
    fi
    
    #find path to upper dirs until HOME or ROOT.
    dirs -c
    while [ "$T" != "$HOME" ] && [ "$T" != "/"  ]; do
        T=$PWD
        if [ -d "$T/$1" ]; then cd $T && return 0; fi
        pushd .. > /dev/null
    done
    
    #not found in partents, now findout in child
    pushd -0 && dirs -c > /dev/null
    #echo "no .git found, stay HERE"

    local INPUT=( $(find ../.. -maxdepth 4 -name "$1" 2> /dev/null |head -60))
    #local INPUT=( $(reppfind @path) )

    if [ -n "${INPUT}" ];then run_menu "${INPUT[@]}" ;  fi
    cd "${menu_selected}/.."
}



function reppinit(){
## ---------------------------------------------------------------------------
# repo init helper
# $1 short repo init command
    #option handle
    local url revision manifest platform reference depth repo_url extra ret=0
    if ! options=$(getopt -l reference:,depth:,repo-url:,no-clone-bundle,partial-clone,no-tags,mirror -o b:m:p:u: -- "$@")
    then err 'please check "repo init --help"'; exit 1; fi

    if [ -z $1 ]; then printElement 'please refer http://collab.lge.com/main/x/wY6wa' && exit 1;fi

    #reset legacy positional parameter except $options
    eval set -- "$options"
    while true; do
        case $1 in
            #when option has sub option, should shift 2 or just shift
            -u|--manifest-url)                                          url=$2;         shift 2;;
            -b|--manifest-branch)                                       revision=$2;    shift 2;;
            -m|--manifest-name)                                         manifest=$2;    shift 2;;
            -p|--platform)                                              platform=$2;    shift 2;;
            --reference)                                                reference=$2;   shift 2;;
            --depth)                                                    depth=$2;       shift 2;;
            --repo-url)                                                 repo_url=$2;    shift 2;;
            #single option that need no additional sub value
            #skip single option and remove getopt cmd
            -c|--current-branch)                                  extra="${extra} $1";  shift 1;;
            --no-clone-bundle|--partial-clone|--no-tags|--mirror) extra="${extra} $1";  shift 1;;
            --|*)                                                                  shift; break;;
        esac
    done

    #revision handle, if url has lamp
    if [ -z "${revision}" ] && [ "${url}" != "${url/lamp/}" ]; then
        printf "usage: repp init -b [branch] [-m manifest.xml] \n";
        bar outline
        printf "ex: repp init -b lampauto_s_release -m all.xml \n";
        printf "ex: repp init -u https://android.googlesource.com/platform/manifest -b android-12.1.0_r1 \n";
        printf "ex: repp init -u ssh://lampgd1.lge.com:29418/platform/manifest.git -b lampauto_r_release \n -m lampauto/lampauto-gm-recent.xml --reference=/data001/vc.integrator/mirror/lampauto_r_release/ \n --repo-url=ssh://lamp.lge.com:29418/repo/git-repo.git \n";
        exit
    fi

    #url handle with replication server
    local file_info=$(mktemp)
    if [ -z "${url}" ] || [ "${url}" != "${url/lamp/}" ]; then
        url="ssh://lamp.lge.com:29418/platform/manifest.git";
    fi
    if [ -z "${reference}" ];then reference="${reference:-${path_mirror}/${revision}}"; fi
    if [ -z "${repo_url}" ] && [ "${url}" != "${url/lamp/}" ];then repo_url='ssh://lamp.lge.com:29418/repo/git-repo.git';fi;

    cmd_repoinit="repo init ${url:+-u ${url}} ${revision:+-b ${revision}} ${manifest:+-m ${manifest}} ${platform:+-p ${platform}} ${reference:+--reference=${reference}} ${depth:+--depth=${depth}} ${repo_url:+--repo-url=${repo_url}} ${extra} $@"

    #make final repo init cmd
    bar outline "executed command:" >> ${file_info}
    printf "${cmd_repoinit}\n" >> ${file_info}

    #execute cmd
    if reppfind_initerror ${cmd_repoinit}; then ret=1; fi

    #show repo info
    bar outline >> ${file_info}
    cat ${file_info}; rm -f ${file_info}

    return $ret
}



function reppshow_manifesttree(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest file name
# $2 treedepth to display sub manifest
    local file
    local path='|--|--|--|--|--|--'
    local treedepth=${2:-0}

    #name of manifest
    printf "%s$1 \n" "${path::${treedepth}}"

    (( treedepth=treedepth+3 ))
    #name of branches
    cat $1| sed -n 's/.*revision="\([^ |\t]*\)".*/\1/p' |sort|uniq| xargs -n1 -I {} printf "%60s {}\n"

    #sub manifests
    cat $1 | sed -n 's/.*include name="\(.*\)".*/\1/p' | \
    while read -r file; do
    if [ -n "${file}" ];then reppshow_manifesttree ${file} ${treedepth}; fi
    done
    (( treedepth=treedepth-3 ))
}



function reppinfo(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    pushd ${REPO_PATH} 
    oldIFS=${IFS}; IFS='';

    #show repo dir path
    bar inline "repo path"
    log "${REPO_PATH}"

    #get global variable and repo init command.
    reppget_repcmd info

    #show manifest file with included sub manifests.
    local manifest=${1:-${FILE_MANI}}
    bar inline "manifests"
    clog  "    <name of manifest>                                      <including branches>"
    reppshow_manifesttree ${manifest} 0

    #show count of repository
    ## block infomation
    bar inline "misc information for this repositories"
    clog "number of repositories: " $REPO_COUNT

    clog "md5 sum for all repositories:"
    repo forall -j16 -c git log -1 --pretty=format:%H | md5sum

    #show last synced time
    if [ -f .git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y .git/FETCH_HEAD );
    else clog "last manifest-synced time(check date of files below): " $(ls -lct | tail -10);fi

    IFS=${oldIFS}
    popd
}



function reppshow(){
## ---------------------------------------------------------------------------
# print information(changes, recent commits) of current repository#
    #topic/working branch
    bar inline "repo branch: check if working branch existed (WAIT: It takes time) "
    repo branch

    #run command "repo info"
    bar outline "it takes time to get information..."
    bar inline "repo status: uncommitted changes list saved to [ repo.status ]"
    echo "repo status" > ${REPO_ROOT}/repo.status

    #remove colored output with 1) sed command, 2) --color option
    #repo status -j8 |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPO_ROOT}/repo.status 
    repo --no-pager --color=never status -j8 >> ${REPO_ROOT}/repo.status 
    
    #list up repo commit, remote, branch, project, path
    reppfind |more

    #### repo info command is duplicated with reppfind functionality, so remove it.
    #bar inline "repo info: git repo/source path /branch rev saved to [ ${REPO_ROOT}/repo.status ]"
    #echo "repo info" >> ${REPO_ROOT}/repo.status
    #repo info |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPO_ROOT}/repo.status 
}



function reppfind_recentcommit(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local count=$1
    local out

    #echo "[$1][$count][$out]"
    if [ -z $1 ]; then read -p "how many commit want to read? [#:number| enter:20| save:savefile| ctrl+c/q:exit]: " count; fi

    case $count in
        *[0-9]*) out='/dev/stdout';;
        '') out='/dev/stdout'
            count=20
            log "\nonly shows recent maxium 20 first-commits(git log -1) from all repository"
            ;;
        *)  out=${REPO_ROOT}/repo.commit
            count=${REPO_COUNT}
            log "\check file [$out], all -1 commits are saved"
            ;;
    esac

    echo "repo forall -c \"git log -1 --abbrev=6 --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%ad  %h  [%an] %d %s%n'\" |sort -r |head -${count:-50}"
    echo "> $out"

    bar outline "repo get recent commit"
    bar inline "date:YMD HMS]       [sha]   [author]      [commit title]                                            [git project                            branch"
    repo forall -j16 -c 'printf "%-100.100s %-80s \n" "$(git log -1 --abbrev=6 --date=format:"%Y-%m-%d %H:%M:%S" --pretty=format:"%ad  %h  [%an] %s")" "[${REPO_PROJECT}  ${REPO_RREV}]"' |sort -r |head -${count:-50} > $out
    #repo forall -c "git log -1 --abbrev=6 --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%ad  %h  [%an] %d %s%n'" |sort -r |head -${count:-50} > $out

}



function reppfind(){
## ---------------------------------------------------------------------------
# find git repository with path and project name with regexp
# $1 path or project
# usage: reppfind [path|project]
    bar inline "all repository info is save to repo.csv" > /dev/stderr
    file_log=${REPO_ROOT}/repo.csv
    repo forall -j1 -c 'printf "%.6s|%.7s|%-22.22s|%-74.74s|%.80s \n" "${REPO_LREV}" "${REPO_REMOTE}" "${REPO_RREV}" "${REPO_PROJECT}" "${REPO_PATH}"' \
     > $file_log
     
    case $1 in 
      comment) @로 시작하면 coloume을 출력
    ;; @rev)      echo "REPO_LREV";    awk -v FS="|" '{print $1}' $file_log 
    ;; @remote)   echo "REPO_REMOTE";  awk -v FS="|" '{print $2}' $file_log |sort |uniq
    ;; @branch)   echo "REPO_RREV";    awk -v FS="|" '{print $3}' $file_log |sort |uniq
    ;; @git)      echo "REPO_PROJECT"; awk -v FS="|" '{print $4}' $file_log |sort 
    ;; @path)     echo "REPO_PATH" > /dev/stderr;   awk -v FS="|" '{print $5}' $file_log |sort 
    ;; "")        printf "\e[1;33m%6.6s %7.7s %-22.22s %-74.74s %.80s \e[0m\n" "REPO_LREV" "REPO_REMOTE" "REPO_RREV" "REPO_PROJECT" "REPO_PATH"
                  cat $file_log | tee  >(wc -l) 
    ;; *)         printf "\e[1;33m%6.6s %7.7s %-22.22s %-74.74s %.80s \e[0m\n" "REPO_LREV" "REPO_REMOTE" "REPO_RREV" "REPO_PROJECT" "REPO_PATH"
                  cat $file_log | grep -i --color=always $1
    ;;
    esac
}



function reppdebug(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    echo "this version is expected to used, please check this version is matched to your local version"

    bar inline "expected"
    info "warning: this is the repo packaged with this project."
    $REPO_PATH/../repo/repo version

    printf "\n\n"
    bar inline "found"
    info "the local version currently you are using"
    bar inline "what"
    repo --version

    echo
    py_path=$(which python) >/dev/null
    py_ver="$(python --version 2>&1)"
    printf "[check] %s is working in [%s]\n" "${py_ver}" "${py_path}"

    bar inline "where"
    which repo
    which git

}



function reppcheck_serverdelay(){
## ---------------------------------------------------------------------------
# find replication server
# $1 server-url
# $2 port-number
    local server_port=${REPO_REMOTE#*@}
    local server=${1:-${server_port%:*}}
    local port=${2:-$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')}

    ping $server -s 1016 -c 4 -A
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    if [ $? -ne 0 ]; then continue; fi
    ssh $server -p $port -o ConnectTimeout=2 -o ConnectionAttempts=1 gerrit show-caches
    if [ $? -ne 0 ]; then continue;fi
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    echo "please check 1) ipg/ewma from ping, 2) AvgGet from gerrit connection"
}



function reppcheck_connection(){
## ---------------------------------------------------------------------------
# check connection and report error
# $1 server
# $2 port
# $3 password
    local server_port=${REPO_REMOTE#*@}
    local server=${1:-${server_port%:*}}
    local port=${2:-$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')}
    local manifest=${3:-${server_port#*/}}
    local branch=${4:-${REPO_BRANCH}}
    local ret


    #local port=$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')
    bar inline "step1: check if ssh is installed"
    if [ -x "$(command -v ssh)" ]; then  log "ssh is installed in [$(which ssh)]"; else err "ssh is not installed"; fi

    if [ -z $server ] || [ -z $port ];then warn "usage) repp check vgit.lge.com 29420 tiger/tools tiger_release" && return 1;fi
    bar inline "step2: check if server tcp port is well listened"
    timeout 5 bash -c "</dev/tcp/$server/$port"
    if [ $? == 0 ];then echo "server $server over port $port is listened"
    else echo "server $server over port $port is not listened"; fi

    bar inline "step3: check if sshd is serviced on this port $port"
    reppcheck_sshconnection $server $port

    bar inline "step4: check if gerrit service is valid"
    reppcheck_gerritconnection ssh $server -p $port gerrit version

    if [ -z $manifest ];then warn "usage) repp check vgit.lge.com 29420 tiger/tools tiger_release" && return 1;fi
    bar inline "step5: check if I can access git (default: manifest)"
    ret=$(ssh $server -p $port gerrit ls-projects --prefix ${manifest} -b ${branch})

    echo "can accessed [${ret#* }]"
    set +x

}




function reppmenu(){
## ---------------------------------------------------------------------------
# show ui menu for this script
MENU_REPP=(
"info: shows repository info such as manifest path, repo cmd, tree of manifests, etc
    ex) repp info, repp info default.xml, repp info event/manifest.xml"
"show: shows uncommited changes, top -1 commits, md5 sum, repo info for all repositories
    ex) repp show, repp show|more, repp show| grep build, cat repo.status"
"go: move path to repo root dir, manifest dir, git path nearby with similar depth.
    ex) repp go (selcetion menu popup)"
"commit: shows lastest commits(git log -1) from all repository (default 20)
    ex) repp commit, repp commit 4, repp commit log.txt(save as)"
"find: (list) search string in all [repo path] : [repo revision] : [repo name]
    ex) repp find, repp list|more, repp find build, repp list|grep -v build
    ex) repp find @rev [@rep| @remote| @branch| @git| @path)"
"init: repo init with automatic options
    ex) repp init -u ssh://${USER:+${USER}@}vgit.lge.com:29420/linux/manifest.git -b mib3_release
    ex) repp init -b lampauto_s_release -m all.xml
    ex) repp init -b lampauto_r_release -m lampauto/lampauto-gm-recent.xml
    ex) repp init -u https://android.googlesource.com/platform/manifest -b android-12.1.0_r1"
"sync: repo sync with optimized multi-job and options
    ex) repp sync, repp sync 8, repp sync 16 --force-sync(more options)"
"reset: reset all repositories to original state
    in case) use this, when repository has dirty commits."
"debug: shows repo/git/python version info used in current repo"
"check: find accessibility for manifest git or normal git
    ex) repp check, repp check vgit.lge.com 29420 tiger/tools tiger_release
                   repp check [git-server] [port] [project]  [branch]"
"server: check delay from server or confirm the server status
    ex) repp server, repp server lamp.lge.com 29418"
)


printf ${green}
cat << PREFACE
==============================================================
 welcome to repp & gitt
 -------------------------------------------------------------
 command usage: ex) repp, repp info, repp show [default.xml]
 command usage: ex) gitt, gitt info, gitt show [currnet git]
 ex) repp find [string], repp sync 16 --force-sync, etc
 help: http://collab.lge.com/main/x/wY6wa
==============================================================
PREFACE
printf ${NCOL}

local COLUMNS=60
PS3=$'\e[00;35m=== Please input command! [enter:menu, number:choice, ctrl+c:exit] === : \e[0m'
select CHOICE in "${MENU_REPP[@]}"; do
    repp "${CHOICE%%:*}";
    if [ -n "$?" ]; then return 1;fi
done
}



function gittmenu(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
MENU_GITT=(
"info: shows git path, gerrit info/url/remote, push command, commit info, sync time.
    ex) gitt info"
"show: shows git (default 15) commits history, diff history
    ex) gitt show, gitt show 20 --all"
"go: move to current .git path
    ex) gitt go"
"reset: clean with 'git reset --hard  && git clean -xdf'
    ex) gitt reset"
"find: branch, commit(author, rev, commit msg)
    ex) repp find, repp list|more, repp find build, repp list|grep -v build
    ex) repp find @rev [@rep| @remote| @branch| @git| @path)"
)


printf ${green}
cat << PREFACE
==============================================================
 welcome to gitt & repp
 -------------------------------------------------------------
 command usage: ex) gitt, gitt info, gitt show [currnet git]
 command usage: ex) repp, repp info, repp show [default.xml] 
 ex) gitt find [string], gitt show, etc
 help: http://collab.lge.com/main/x/wY6wa
==============================================================
PREFACE
printf ${NCOL}

local COLUMNS=60
PS3=$'\e[00;35m=== Please input command! [enter:menu, number:choice, ctrl+c:exit] === : \e[0m'
select CHOICE in "${MENU_GITT[@]}"; do
    gitt "${CHOICE%%:*}";
    if [ -n "$?" ]; then return 1;fi
done
}



function gittinfo(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
    local TEMP
    bar inline "git path"
    if ! gittcheck_gitpath print_y ;then echo "we are not in git project" && return 1; fi
    
    #readarray -t GIT_REMOTE < <(git remote -v |cut -f1|uniq)
    GIT_REMOTE=$(git remote|head -1) 
    bar inline "show all remote info"    
    showRUN git config --get-regexp remote.$GIT_REMOTE |sort|grep -Ee "(projectname|review|url)"
    
    TEMP=$(printf "%s/admin/repos/%s" \
        $(git config --get-regexp remote.$GIT_REMOTE.review|cut -d' ' -f2) \
        $(git config --get-regexp remote.$GIT_REMOTE.projectname|cut -d' '  -f2)  )
    clog "review system url:" $TEMP
    
    TEMP=$(printf "git push $GIT_REMOTE HEAD:refs/for/%s" \
        $(git branch -ar |grep m/ |sed -E 's#.*/(.*)$#\1#') )
    bar inline "git push commands"
    clog " git push direct:" ${TEMP/\/for/\/heads}
    clog " git push review:" $TEMP
    
    
    bar inline "recent commit info"
    git show --stat --oneline HEAD
    
    bar inline "last synced time"
    #show last synced time
    oldIFS=${IFS}; IFS='';
    if [ -f .git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y .git/FETCH_HEAD );
    else clog "last manifest-synced date(check date of files below): " $(ls -lct .git| tail -5);fi
    IFS=${oldIFS}

}



function gittshow(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: number of commit
# $2: other option such as --all (all branch)    
    #topic/working branch
    bar outline "gitt show is based on command: git log "    
    bar inline "git commit history with option (to see all branche, gitt show 20 --all)"
    git log --decorate --graph -n${2:-15} --pretty=format:'%Cred%h -%C(yellow)%s %Cgreen(%ci) %C(blue)<%an>%Creset' $1

    bar inline "git commit diff history"
    echo "--since(=after), --before(=until)"
    echo "6 hour, 2-day, 2-week, 1-month, 1-year"
    clog "ex:" "--since=2-weeks, --since=04:24, --before=6-hours, --after=2022-11-10 --before=2022-11-20-23"
    read -p "input add option [enter(default):--pretty="short" --name-only | input option with default]" 
    
    git log --pretty="short" --name-only ${reply} |more
}



function gittreset(){
## ---------------------------------------------------------------------------
# reset git repositories
# $1 target

    case $1 in
      all)  repo forall -cj${NJOBS} 'git reset --hard ; git clean -xdf'
            echo "reset all repositories" ;;
      ''|*) if gittis_gitdir; then 
                
                showRUN git reset --hard; showRUN git clean -xdf
            else 
                warn "this is not a git directory"; 
            fi  ;;
    esac
}



function gittfind(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: number of commit
# $2: other option such as --all (all branch)    
    bar outline "search in commit with regexp(\$1) in files(\$2)"    

    under "git log --committer=\"$1\""
    clog 'committer history' "ex) git log --committer='.*joongkeun' "    
    git log --committer="$1"

    under "git log -i --grep=\"$1\" " 
    clog 'commit message history' "ex) git log -i --grep='.*debugprint' " 
    git log -i --grep="$1"
    
    under "git log -i -G\"$1\" ${@:2}" 
    clog 'commit contents history' "ex) git log -i -G'.*debugprint' zlib.c" 
    git log -i -G"$1" "${@:2}"

    under "git grep -n \"$1\" ${@:2}" 
    clog 'current files tracked in git' "ex) git grep -n '.*debugprint' *.c" 
    git grep -n "$1" "${@:2}"

    under "git log -L :\"$1\":${@:2} " 
    clog 'function in git history' "ex) git log -L :func_debugprint:zlib.c"
    git log -L :"$1":"${@:2}"
}



function gitt(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
local ret=0
if ! gittcheck_gitpath print_n;then err "we are not in git project" && return 1; fi

case "$1" in
    #$1:below ${@:2}:parameters
    info)       gittinfo ;;
    show)       gittshow "${@:2}";;
    go)         cd "$(gittcheck_gitpath)" ;;
    reset)      gittreset "${@:2}";;
    find)       gittfind "${@:2}";;    
    '')         gittmenu "${@:2}";;
    *)          git "${@}";;    
esac    
return $ret
}




function repp(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
local ret=0
case "$1" in
    #$1:below ${@:2}:parameters
    info)       reppcheck_precondition print_y || return 1
                reppinfo  "${@:2}";;
    show)       reppcheck_precondition print_y || return 1
                #reppinfo "${@:2}"  2>&1 | tee ${REPO_ROOT}/repo.status
                reppshow "${@:2}"  2>&1 
                info "please check file [${REPO_ROOT}/repo.status]"
                warn "you can use this file to compare other repo.";;                
    go)         reppcheck_precondition print_y || return 1
                local menu_items=('go ROOT　dir' 'go Manifests　dir' 'go GIT　root dir' 'exit')
                run_menu "${menu_items[@]}"
                case "$?" in
                    1|11)  cd "${REPO_ROOT}"        ;;
                    2|12)  cd "${REPO_PATH}"        ;;
                    3|13)  reppgo .git              ;;
                    *)  echo 'exit) stay here'      ;;
                esac;;
    commit)     reppcheck_precondition print_y || return 1
                reppfind_recentcommit "${@:2}";;
    find|list)  reppcheck_precondition print_y || return 1
                reppfind "${@:2}";;

    init)       reppinit "${@:2}"
                if [ $? -eq 0 ]; then
                    info "To RUN next command:"
                    reppfind_syncerror
                fi;;
    sync)       reppcheck_precondition print_y || return 1
                reppfind_syncerror "${@:2}";;
    reset)      reppcheck_precondition print_y || return 1
                gittreset all ;;

    debug)      reppcheck_precondition print_y || return 1
                reppdebug "${@:2}";;
    check)      reppcheck_precondition print_n || return 1
                reppcheck_connection "${@:2}";;
    server)     reppcheck_precondition print_n || return 1
                reppcheck_serverdelay "${@:2}";;
    '') 
                reppmenu "${@:2}";;
    *) 
                repo "${@}";;
esac
return $ret
}



function reppcheck_precondition(){
## ---------------------------------------------------------------------------
# pre-check
# $1 command
    #find & move manifest dir
    local ret=1

    reppfind_repodir .repo/manifests 5 print_n
    if [ -d "${REPO_PATH}" ];then 
        pushd ${REPO_PATH}; REPO_ROOT=${REPO_PATH%/.repo*}
            #set global variable
        REPO_REMOTE=$(git remote -v |grep fetch |awk '{print $2}')
        REPO_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}| sed 's:.*/::')
        REPO_URL=$(cat ../repo/.git/config |grep url|sed 's/.*= \(.*\)/\1/')
        REPO_MIRROR=$(cat ../manifests.git/config |grep reference|sed 's/.*= \(.*\)/\1/')
        REPO_COUNT=$($REPO_PATH/../repo/repo list |wc -l)
        
        popd
        ret=0
    fi

    if [[ $ret -eq 1 && "$1" = "print_y" ]]; then 
        printf "%s\n" ${REPO_PATH_ALL[@]};
        bar inline "WARNING"
        warn "you are not in repo project, please check !";      
    fi
    return $ret
}



##============================================================================
## Main
##============================================================================
#set -x
REPO_PATH='' && REPO_ROOT='' && REPO_REMOTE='' && REPO_BRANCH='' && REPO_URL='' && REPO_MIRROR='' && REPO_COUNT=''
REPO_PATH_ALL=()

(return 0 2>/dev/null) && sourced=1 || sourced=0
if [ $sourced -eq 0 ]; then repp $@;
else  #if sourced 
    echo "[WELCOME] repp utility is applied for current shell" 
    #hide local function, need to implements
fi

