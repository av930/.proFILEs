#!/bin/bash
## ==========================================================================
##  readme    : repo wrapper utility
##  mail      : joongkeun.kim@lge.com, av9300@gmail.com
## ==========================================================================
###---------------------------------------------------------- DEBUG OPTION
#DEBUG=["echo -e"|:], : means no-operation
#DEBUG=[ : | "printf ${RED}%s${NCOL}\n" ]
DEBUG=:
#DEBUG="printf ${RED}%s${NCOL}\n"

PATH_FULL=$(realpath "$BASH_SOURCE")
PATH_DIR="${PATH_FULL%/*}"
PATH_FILE="${PATH_FULL##*/}"
DIR_CURR=$(pwd)
LC_ALL=C.UTF-8
$DEBUG "[$_][$BASH_SOURCE][$0][${PATH_FULL}][${PATH_DIR}][${PATH_FILE}]"


if [ -e "${PATH_DIR:-.}/prelibrary" ]; then source ${PATH_DIR:-.}/prelibrary;
else source ${proFILEdir}/tools/prelibrary; fi
## custom builtin variable setting
ACCOUNT=vc.integrator
PATH_MIRROR="/data001/${ACCOUNT}"/mirror


##------------------------ alias & oneline func ------------------------------
##============================================================================
#### when running script, register git alias automatically
## load direct from below
source <(cat <<'EOF'
## alias
    #suppress repo update log: alias repp='_repp(){ repp $@ 2> >(sed '/.../,/cp/d') ;}; _repp'
## git alias
    git config --global alias.alias 'config --get-regexp ^alias\.'
    git config --global alias.st 'status'
    git config --global alias.ci 'commit --verbose'
    git config --global alias.loga 'log --color=always --oneline --decorate --graph -n 20 --all'
    git config --global alias.logo "log --color=always --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset %C(blue)<%an>%Creset' --abbrev-commit --date=relative"
    git config --global alias.tagcur 'describe --tags --abbrev=0 --match'
    git config --global alias.diffc 'difftool -t bc'
    git config --global alias.diffv 'difftool -t vimdiff'
    git config --global alias.difft 'difftool --dir-diff -t vimdiff'


## NEEDTO: sudo apt-get install icdiff
    #git config --global alias.diffi "difftool --extcmd 'icdiff'"
     git config --global alias.diffi "!_gitdiff() { git difftool --extcmd 'icdiff'; }; _gitdiff"
    #git config --global alias.diffi '!_gitdiff() { git difftool --extcmd "icdiff $@"; }; _gitdiff' --replace-all
     git config --global alias.clear "!_gitclear() { git reset --hard $1; git clean -xdf; }; _gitclear"
EOF
) 2> /dev/null


## oneline function defined below
## suppress print path
pushd() { command pushd "$@" > /dev/null ;}
popd() { command popd "$@" > /dev/null ;}
NJOBS=$(( $(nproc --all) / 4))
gittcheck_isgitproject(){ git -C "$1" rev-parse --is-inside-work-tree &> /dev/null ;}

##--------------------------- Menu Functions --------------------------------
##============================================================================

function tempfunc(){
## ---------------------------------------------------------------------------
# template for bash fuction
# $1 parameter explanation
# $2 parameter explanation
    local cmd=$1
    local opt=$2

    case $cmd in
       help) cat <<- EOF
				usage) gitt branch list <''|name-filter>
				usage) gitt branch create|new <name>
				usage) gitt branch delete|remove <name>
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) echo "default functionality"
    ;; esac
}



## repp ======================================================================================================================
function reppshow_manifesttree(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest file name
# $2 treedepth to display sub manifest
    local file
    local manifest=$(mktemp)
    local path='|--|--|--|--|--|--'
    local treedepth=${2:-1}
    local string=$3

    cat $1| sed '/<!--.*-->/d' | sed '/<!--/,/-->/d' > ${manifest}

    ##print name of manifest
    printf "%s$1 \n" "${path::${treedepth}}"

    (( treedepth=treedepth+3 ))
    if [ -n "${string}" ] ; then
        if grep -ne "$string" ${manifest}; then wave; fi
    else
    ##print name of branches not revision
    cat ${manifest}| sed -n 's/.*revision="\([^ |\t]*\)".*/\1/p'| grep -v '^[a-f0-9]*$'| sort| uniq| xargs -I {} printf "%60s {}\n"
    ##print only 10 revision for notice
    cat ${manifest}| sed -n 's/.*revision="\([^ |\t]*\)".*/\1/p'| grep -e '^[a-f0-9]*$'| head -10| xargs -I {} printf "%60s {}\n"
    fi

    ##sub manifests
    cat ${manifest}| sed -nE 's/.*include name="([^"]*)".*/\1/p' | \
    while read -r file; do
        if [ -n "${file}" ];then reppshow_manifesttree ${file} ${treedepth} ${string}; fi
    done
    (( treedepth=treedepth-3 ))
}



function reppmani(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest output file name
# $2 command
# $3 branch name or branch postfix
    local cmd=$1
    local item=$2
    local str=$3
    local filter=$4

    case ${cmd} in
        info|gen|find|change|diff|diffcheck) if [[ ! "${PWD}" =~ "${REPP_PATH}" ]]; then
            warn "you must move to manifest dir, path is changed automatically ${REPP_PATH}"
            info "you can go by 'repp go mani' or 'git go mani'"
            cd ${REPP_PATH}; fi
        ;; *)
    esac

    case ${cmd} in
        init)   ##remove repp.csv and all related files
                if  ! repp_initdb init ; then
                    warn "DB is not generated well, please check error"
                    bar inline "${REPPFILE_TXT}"
                    echo "you can use this for simple use, it generated only from manifest git"
                    #repo manifest --json 2> /dev/null | jq -jr '.project[]|.revision,"|",.groups,"|",.remote,"|",.upstream,"|",."dest-branch","|",.name,"|",.path,"|\n"' > ${REPPFILE_TXT}
                fi
    ;;    go)   gittgo mani
    ;;  find)   reppshow_manifesttree ${manifest:-${REPPFILE_MANI}} 0 ${item}
    ;;  info)   ##get global variable and repo init command.
                reppget_repcmd info

                bar inline "current manifest file"
                echo "${REPP_ROOT}/.repo/${REPPFILE_MANI}"

                ##show manifest file with included sub manifests.
                bar inline "manifests"
                clog  "    <name of manifest>                                      <including branches>"
                reppshow_manifesttree ${manifest:-${REPPFILE_MANI}} 0
                info "to see specific xml, run 'repp info <xml>'"

                ##show count of repository
                ### block infomation
                bar inline "misc information for this repositories"
                clog "number of repositories: " $REPP_COUNT

                bar inline "recently changed history [git log 10]"
                showRUN git log -10 --name-status --abbrev=6 --date=format:"%Y-%m-%d %H:%M" --pretty=format:"%C(yellow)%ad %C(red)%h %C(green)%s%C(reset)"

                bar inline "file name & only modified file, not add/delete files (press 'q' to stop)"
                info "you can find add/delete git projects here recent 12 weeks"
                showRUNQ "git log -p --color=always --pretty=oneline --diff-filter=M --since=12-weeks  |more -30"

    ;;   gen)   bar inline "current manifest.xml [${REPPFILE_MANI}] regnerated with option"
                echo 'ex) <project groups="qcos" name="common/nad/ntc" path="nad/tsu-src/ntc" remote="devops" revision="master"/>'
                echo "upper format will be generated by no option(enter)"
                clog "no-option" "generate revision as branch"
                clog "-r" "generate revision as HEAD rev"
                if (( "$(reppversion ver)" > 230 )); then
                    clog "-r --suppress-upstream-revision --suppress-dest-branch" "generate revision without upstream-revision or dest-branch"
                    clog "-m default.xml" "use default.xml as input"
                    clog "--json" "generate manifest to json format"
                fi
                read -p "input option :" opt
                if [[ ! "${opt}" =~ "--json" ]] || [[ ! "${opt}" =~ "-o" ]]; then opt+=" -o ${item:-${REPPFILE_XML}}"; fi
                showRUN repo manifest ${opt} 2> /dev/null

    ;;change)   under "please run one of these 'repp mani change' commands to generate cmd to change manifest easily\n"
                clog "usage)" "repp mani change <revision|name|path|remote|upstream|dest-branch|groups|dest|src|etc> <change-string> <filter>"
                clog "\n   verifiy :" "cat \${REPPFILE_XML} | <cmd> | grep --color=auto ${str}"
                clog "   preview :" "icdiff <( cat \${REPPFILE_XML} ) <( <cmd> )\n"
                cat <<- CHANGE
				   flow(input cmd): $ repp mani change remote vgit_new vgit_as
				   flow(generated): select postfilter cmd $ cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#'
				   flow(verify   ): cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#' | grep --color=auto vgit_new
				   flow(compare  ): $ icdiff <( cat ${REPPFILE_XML} ) <( cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#' )
				   flow(ok? save ): $ cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#' > repp.xml
CHANGE

                bar inline "repp mani change revision migration_today"
                clog "change field<revision> to value<migration_today>" "generate 3 type <cmd>"
                cat <<- CHANGE
				     infix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="${str}"#'
				    prefix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="${str}\1"#'
				   postfix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="\1${str}"#'
CHANGE
                printf "\n"
                bar inline "repp mani change remote vgit_new vgit_as"
                clog "change field<remote> its contents is matching <vgit_as> to value <vgit_new>" "generate 3 type <cmd>"
                cat <<- CHANGE
				  infilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="${str}"#'
				 prefilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="${str}\1"#'
				postfilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="\1${str}"#'
CHANGE

    ;;  diff)   bar inline "compare 2 different manifests what project is changed"
                clog 'ex)' 'repp mani diff <old manifest.xml> <new manifest.xml>'
                clog 'ex)' 'repp mani diff event/230426_mig.xml event/230712_upstream.xml'
                reppdiff diff "$item" "$str" "$filter"

    ;;  diffcheck)
                bar inline "after repp mani check, if branch changed, find missing commits (this is useful in migration)"
                reppdiff check "$item" "$str" "$filter"

    ;; help|*)   cat <<- EOF
				usage) repp mani info                                     #show manifest info,structure,log,diff
				usage) repp mani init                                     #force regenerate db by current manifest not reusing
				usage) repp mani go                                       #cd to manifest dir
				usage) repp mani gen <outfile>
				   ex) repp mani gen current.xml                          #default out: ${REPPFILE_XML}
				usage) repp mani find <string>                            #find string in current manifest-tree
				usage) repp mani change <revision|name|path|remote|upstream|dest-branch|groups|dest|src|etc> <str> <filter>
				   ex) repp mani change                                   #show command how to change manifest in detail, not change directly
				   ex) repp mani change remote vgit_new                   #show command: change "any string" to "vgit_new" in all remote field
				   ex) repp mani change remote vgit_new vgit_as           #show command: change only from "vgit_as" to "vgit_new" in remote field
				usage) repp mani diff event/old.xml <new.xml>             #compare old manifest to new manifest
				   ex) repp mani diff event/compare.xml                   #compare history event/compare.xml to current.xml
				   ex) repp mani diff default.xml event/230712_mig.xml    #compare history from 2 different manifests
				   ex) repp mani diff                                     #can choose manifest in recent 3 weeks, comparing to current manifest
				usage) repp mani diffcheck                                #post analysis after 'repp mani diff' for missed commits checking
EOF
    ;; esac
}



function csv_fromlnx_towin(){
## ---------------------------------------------------------------------------
## linux CSV fileì„ windows CSV fileë¡œ ë³€ê²½í•œë‹¤.
## ""ë¡œ ë¬¶ì—¬ìˆëŠ” field(ì—¬ëŸ¬ì¤„ê°€ëŠ¥)ì˜ LFëŠ” ìœ ì§€í•˜ê³ , ê·¸ì™¸ì˜ LFëŠ” CRLFë¡œ ë³€ê²½í•œë‹¤.
local tfile=$(mktemp)
awk 'BEGIN {
    RS=""
    FPAT="([^,\"]+)|(\"([^\"]|\"\")*\")|";  # í•„ë“œ íŒ¨í„´ ì •ì˜
    OFS=",";                                # ì¶œë ¥ í•„ë“œ êµ¬ë¶„ì
    ORS="\r\n";                             # ì¶œë ¥ ë ˆì½”ë“œ êµ¬ë¶„ì (CRLF)
}{
    for (i = 1; i <= NF; i++) {         # í•„ë“œê°€ double quoteë¡œ ë¬¶ì—¬ìˆì§€ ì•Šì€ ê²½ìš°ì—ë§Œ gsub ìˆ˜í–‰
         if ($i !~ /^".*"$/) {
            gsub(/\r?\n/, "\r\n", $i);  # CRLF ì•„ë‹Œê²ƒë§Œ LFë¥¼ "\n"ìœ¼ë¡œ ë³€ê²½
        }
    }
    print $0;                           # ìˆ˜ì •ëœ ë ˆì½”ë“œ ì¶œë ¥
}' "$1" > $tfile
cat $tfile > "$1"

diff -uN $tfile "$1"
}



function reppforgen_csv(){
## ---------------------------------------------------------------------------
# repp forall genìœ¼ë¡œ ê¸°ë³¸ csvë¥¼ ìƒì„±í•˜ê±°ë‚˜
# ì…ë ¥ëœ repp forall <project -c 'cmd' option> ë¶„ì„í•˜ì—¬, reppforall.csv, repp_inscript.sh íŒŒì¼ì„ ìƒì„±í•œë‹¤.

    under "Welcome to reppforall generator\n"
    clog "${REPPFILE_FORALL},\n${REPPSCRIPT_IN}" "will be generated, please wait a few seconds"

    local ret=0 cmd=$1
    local tempf=$(mktemp)
    ## repo forall . -cj4 ' ~~~ ' ëª…ë ¹ì–´ parsing
    reppcheck_initvar reppgitt

    ## reppforall.csv heading ìƒì„±
    ## (CSV fileì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ìµœì¢… ì²˜ë¦¬ì „ê¹Œì§€ëŠ” windows formatìœ¼ë¡œ ì²˜ë¦¬)
    ## ì¶”í›„ REPO_UPSTREAM,REPO_DEST_BRANCHê°€ í•„ìš”í•˜ë©´ $4,$5ë¥¼ ë„£ì–´ì•¼ í•œë‹¤.
    printf "http://collab.lge.com/main/display/~joongkeun.kim/reppforall,Refer please,,REPPSCRIPT_V1,NONE,REPPSCRIPT_V2,NONE,\r\n\
,,,REPPSCRIPT_PRE,NONE,REPPSCRIPT_POST,NONE,\r\n\
REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_RREV,REPO_PROJECT,REPO_PATH,REPP_SCRIPT,\r\n" > $REPPFILE_FORALL

    ## repoforall.csvì˜ bodyë¥¼ ìƒì„±
    if [ ! "$cmd" = "gen" ]; then
        local arg opt pro sep cmd=
        for arg in "$@"; do
            $DEBUG "[$arg]"
            case $arg in
               ## -cë¥¼ ê¸°ì¤€ìœ¼ë¡œ cmdì™€ projectë¥¼ êµ¬ë¶„í•œë‹¤.
            -*c*)   [ -z "$pro" ] && { sep="$arg"; pro="$opt"; [ -z "$pro" ] && pro=all; opt= ; } || { opt+="$arg"; continue; }
            ;; ## '~~~'ë¡œ ê°ì‹¸ì§„ commandë¥¼ ì¶”ì¶œí•œë‹¤.
            *\ *) cmd=$(printf "'%s' " "$arg"); cmd+="$opt"; opt=
            ;; ## ë“¤ì–´ì˜¤ëŠ” ëª¨ë“  textëŠ” ë¨¼ì € optì— ì €ì¥ëœë‹¤.
            *)    opt+=$(printf "%s " "$arg");
            esac
        done

        ## '~'ë¡œ ë¬¶ì¸ê²ƒì´ ì—†ë‹¤ë©´ ëª¨ë‘ cmdë¡œ ì²˜ë¦¬í•œë‹¤.
        [ -z "$cmd" ] && { cmd="$opt"; opt=""; }

        ## ëª…ë ¹ì–´ì— ì¡´ì¬í•˜ëŠ” single quote ì²˜ë¦¬
        #cmdì˜ ë§¨ì•ì— single quoteê°€ ì¡´ì¬í• ë•Œë§Œ, ë§¨ì•/ë§¨ë’¤ì— single quoteë¥¼ ì œê±°í•œë‹¤.
        cmd=${cmd#\'} && cmd=${cmd%\'*}
        printf "%s\n" "${cmd}" > $REPPSCRIPT_IN
        chmod +x "$REPPSCRIPT_IN"

        [ "$pro" = ". " ] && pro=${GITT_PROJECT}  #set as current git project
        [ "$pro" = "all" ] && pro='.'             #match all git project

        ## í˜„ì¬ëŠ” case2ë¡œ parsingí•˜ê³  ìˆìŒ. case1ê²½ìš°ì—ëŠ” ë³µì¡ë„ê°€ ë†’ì•„ case2ë¡œ ê°œì„ í•¨
        ##repp forall tiger/services/ethmgr tiger/metas/meta-tiger  -cj1 bash -c '[ -z "${REPO_RREV}" ] && echo ${REPO_PROJECT}' $USER $PWD
        ##pcase2)      project                                        sep cmd

        $DEBUG "pro~~~~~~" "$pro"; $DEBUG "sep~~~~~~" "$sep";
        $DEBUG "cmd~~~~~~" "$cmd"; $DEBUG "opt~~~~~~" "$opt"; $DEBUG "script~~~~~~" "$REPPSCRIPT_IN"
        [ -z "$sep" ] && { err "please check your command, you must input 'repp forall [-cj4]'"; return 1; }

        ## csvì—ì„œ repo forallë¡œ ë“¤ì–´ì˜¨ projectë§Œ ì¶”ì¶œí•˜ì—¬ reppforall.csv ìƒì„±
        for arg in $pro; do
            ## projectê°€ ì¡´ì¬í•˜ë©´ ì¶”ì¶œí•˜ê³ , ëª…ë ¹ì–´(script)ë„ ê°™ì´ ê¸°ìˆ í•œë‹¤.)
            #cat "${REPPFILE_CSV}"| awk -F'|' -v vp="$arg" -v vc="$pre '$REPPSCRIPT_IN' $opt" '$7 ~ vp {print $0 script}' >> "$tempf"
            ##awkì—ì„œ success or failureë¥¼ returní•˜ë ¤ë©´ ì•„ë˜ì™€ ê°™ì´ ì§ì ‘ì ìœ¼ë¡œ exit êµ¬ë¬¸ìœ¼ë¡œ ëª…ì‹œí•´ì¤˜ì•¼ í•œë‹¤.
            ##pcase1 cat "${REPPFILE_CSV}"| awk -F'|' -v vp="$arg" -v vc="$pre $REPPSCRIPT_IN $opt" '$7 ~ vp {print $0 vc; found=1} END {if (found) exit 0; else exit 1}' >> "$tempf"
            ##pcase2
            cat "${REPPFILE_CSV}"| awk -F'|' -v vp="$arg" -v vc="$REPPSCRIPT_IN" '$7 ~ vp {print $0 vc; found=1} END {if (found) exit 0; else exit 1}' >> "$tempf"
            if [ $? -ne 0 ]; then err "project [$arg] is not existed, if force to continue, edit direct : ${REPPFILE_FORALL}"; return 1; fi
        done
    fi
    ## excelì—ì„œ í¸ì§‘í• ìˆ˜ ìˆë„ë¡ repoforall.csv body ìƒì„±
    ## txt íŒŒì¼ì¸ $REPPFILE_CSVë¡œ ë¶€í„° sha-codeë¥¼ 6ìë¦¬ë¡œ ì¤„ì´ê³ 
    ##                                êµ¬ë¶„ìì¸ '|'ì™€ ì½¤ë§ˆ(,)ë¥¼ í¬í•¨í•˜ëŠ” íŒŒì¼ì„
    ##                                êµ¬ë¶„ìë¡œ ','ë¡œ í•˜ê³  ì½œë¡ (:)ì„ í¬í•¨í•˜ëŠ” csvë¡œ fileë¡œ ë§Œë“œëŠ” ì‘ì—…
    #cat "$REPPFILE_CSV"| colrm 7 40| awk 'BEGIN{FS="|"; OFS=","; ORS="\n";}{print "\042\042\075\042"$1"\042","\042"$2"\042,"$3","$6","$7","$8}' >> "$REPPFILE_FORALL"
    #cat "$REPPFILE_CSV"| colrm 7 40| awk 'BEGIN{FS="|"; OFS=",";}{gsub(/,/,":",$2);print $1","$2","$3","$6","$7","$8}' >> "$REPPFILE_FORALL"
    ##RS='\n'ëŠ” ctrl+Mì„ ì œê±°í•˜ê³  \r\në¡œ ëŒ€ì²´í•˜ê¸° ìœ„í•´ì„œ ì‚¬ìš©
    [ ! -s $tempf ] && cp "${REPPFILE_CSV}" $tempf
    cat $tempf| awk 'BEGIN{FS="|"; OFS=","; ORS="\r\n"}{gsub(/,/,":",$2);print "\042\042\075\042"$1"\042",$2","$3","$6","$7","$8","$9","}' >> "$REPPFILE_FORALL"
    ## column 2ì— ì¡´ì¬í•˜ëŠ” :ë¥¼ ,ìœ¼ë¡œ ë°”ê¾¼ë‹¤.
    #cat $tempf| awk 'BEGIN{FS="|"; OFS=","; ORS="\r\n"}{if ($2~/,/) {$2="\""$2"\""};print "\042\042\075\042"$1"\042",$2","$3","$6","$7","$8","$9","}' >> "$REPPFILE_FORALL"

    [ -f "$REPPFILE_FORALL" ] && bar inline "$REPPFILE_FORALL"
    [ -f "$REPPFILE_FORALL" ] && clog "${REPPFILE_FORALL##*/}:" "you can put your commands ${REPPFILE_FORALL##*/} and then run by 'repp forall'"
    [ -f "$REPPSCRIPT_IN" ] && bar inline "$REPPSCRIPT_IN"
    [ -f "$REPPSCRIPT_IN" ] && clog "${REPPSCRIPT_IN##*/}:" "${REPPFILE_FORALL##*/} can call script ${REPPSCRIPT_IN##*/} by describing."
    return 0
}



function reppforgen_sh(){
## ---------------------------------------------------------------------------
## reppforgen_sh ë’¤ì— ì˜¤ëŠ” ëª¨ëŠ” parameterë¡œ scriptë¥¼ ë§Œë“¤ì–´ì¤€ë‹¤.
## ì´ë¥¼ ìœ„í•´ ë¨¼ì €, ì…ë ¥ëœ commandì˜ íŠ¹ìˆ˜ë¬¸ìë‚˜ ì˜ëª»ëœ quoteë‚˜ error êµ¬ë¬¸ì´ ìˆëŠ”ì§€ ê²€ì‚¬í•˜ê³  ìˆ˜ì •í•œë‹¤.
## '~~~', "~~~", ?ë¥¼ ì œê±°í•˜ê³  ëª…ë ¹êµ¬ë¬¸ì´ ì˜¬ë°”ë¥¸ì§€ testí•´ì¤€ë‹¤.
## ìƒì„±ëœ ëª…ë ¹ì„ CRLFë¥¼ ì œê±°í•˜ì—¬ $REPPFILE_OUTì— ë„£ì–´ ì‹¤í–‰í• ìˆ˜ ìˆë„ë¡ ë§Œë“¤ì–´ ë†“ëŠ”ë‹¤.
#echo "${cmd}"| awk 'BEGIN {RS=""; FS="\n"} {gsub(/^['\''"]|['\''"]$/, ""); print}'   #"~~~"ë§Œ ì‚­ì œ
#"~~~", '~~~'ë‘˜ë‹¤ ì‚­ì œ
    ##RS=""//ì—¬ëŸ¬ì¤„ì„ í•˜ë‚˜ì˜ recordë¡œ ì²˜ë¦¬; FS="\n" //í•œì¤„ì„ í•˜ë‚˜ì˜ fieldë¡œ ì²˜ë¦¬
    wave
    [[ -z "$REPPFILE_OUT" ]] && { err "generated file name must be ready"; return 1; }
    [ "${@}" = "NONE" ] &&  return 0;
    local cmd=$(echo "${@}"| awk 'BEGIN {RS=""; FS="\n"} {gsub(/^["'\''"]|["'\''"]$/, ""); print}')

    #declare -p cmd
    if [ -z "${cmd%%\'*}" ]; then
        err "remove wrapping single quotes('~~~') from command\n"
        wave; echo $cmd; return 1
    fi
    if [ -z "${cmd%%\"*}" ]; then
        err "remove wrapping double quotes(\"~~~\") from command\n"
        wave; echo $cmd; return 1
    fi
    if  echo "${cmd}" |grep '? '; then warn "remove special character from command" ; fi
    if ! echo "${cmd}" | bash -n; then err "input command is not correct!"; return 1; fi

    ## ë¬¸ì œê°€ ì—†ìœ¼ë©´ REPPFILE_OUTì„ ìƒì„±í•œë‹¤.
    echo "${cmd}" > $REPPFILE_OUT; #"~~~", '~~~'ë‘˜ë‹¤ ì‚­ì œ
    sed -i 's/\r$//' "$REPPFILE_OUT"
}



function reppforall(){
## ---------------------------------------------------------------------------
# repp forall -cì¼ë•ŒëŠ” reppforgenë¡œ ì—°ê²°í•˜ê³ 
# repp forall ì¼ë•ŒëŠ” reppforall.csv ë¥¼ ì½ì–´ ì‹¤í–‰í•œë‹¤.

    REPPFILE_OUT=
    local fileincmd=$(mktemp)
    local opt

    #terminalì—ì„œ ì§ì ‘í•¨ìˆ˜ í˜¸ì¶œí•˜ëŠ”ê²ƒì„ ë°©ì§€
    if [[ "${FUNCNAME[1]}" == "" || "${FUNCNAME[1]}" == "main" ]]; then warn "You can use 'repp forall'"; return 1; fi
    if [[ "$@" =~ '`' ]]; then
        clog "backquote(\`)" "is not supported 'repp forall' command"
        err "you can't use backquote, use \$(cmd)" instead of \`cmd\`;
        return 1;
    fi
    ## change from csv file with separator ',' but containing semi-colon in item.
    ##          to txt file with separator '`' but containing seme-colon in item.

    local cmd=$1
    case $cmd in
        help) cat <<- 'EOF'
			usage) repp forall gen                                               #generate default reppforall.csv to edit command
				    1. 'repp forall gen' will save reppforall.csv into .repp dir in root path
				    2. put muli-cmds in REPO_SCRIPT column like cmd1;cmd2|cmd3;cmd4;
				    3. run by 'repp forall'. it will ask how to run it ex) run all at once or run 1 by 1.

			        info) repo variables: $REPO_LREV, $REPO_GROUP, $REPO_REMOTE, $REPO_RREV, $REPO_PROJECT, $REPO_PATH, $REPO_ROOT
			              #not supported: REPO_I, REPO_COUNT, REPO_INNERPATH, REPO_OUTERPATH, REPO_UPSTREAM, REPO_DEST_BRANCH
			usage) repp forall -c '<cmd>'                                        #generate reppforall.csv and repp_inscript.sh including <cmd>
			usage) repp forall testcase                                           #copy reppforall.test.csv to reppforall.csv to test repp forall functionality
			usage) repp forall                                                   #run repo forall by using reppforall.csv
			usage) repp forall g|go|goo                                          #run repo forall without asking, with No-info, Project, Project&Command

			guide) example cmds REPO_SCRIPT column in reppforall.csv
			        echo REPO_PROJECT|xargs -n1 -I% sh -c 'echo $%'              #xargs
			        echo ${REPO_REMOTE} ; echo ${REPO_RREV}                      #multiple commands with ;
			        echo ${REPO_REMOTE} |grep -o vgit; echo ${REPO_REMOTE}       #multiple commands with |
			        echo ${REPO_REMOTE} && echo ${REPO_RREV}                     #multiple commands with &&
EOF
            return 0
        ;; testcase) local sfile="$PATH_DIR/reppforall.test.csv"
                cat "$sfile"| awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="\n";}  NR>=1 && NR<=3 {printf "%s\r\n", $0}' > "$REPPFILE_FORALL"
                for i in $(seq 4 1 $(awk 'BEGIN{RS="\r\n"} END{print NR}' "$sfile") ); do
                    awk 'BEGIN{FS="|"; RS="\n"; OFS=","; ORS=",";}       NR=='$i' {gsub(/,/,":",$2);print $1","$2","$3","$6","$7","$8}' ${REPPFILE_CSV}
                    awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="\r\n";}  NR=='$i' {if ($7!="") {print $7} else {print ""}}'             "$sfile"
                done >> "$REPPFILE_FORALL"
                info "Now, you can test repp forall functionality by 'repp forall' command"; return 0
        ;;  g|go|goo) opt=$cmd
        ;; '') :
        ;;  *) reppforgen_csv "$@";  return 0
    esac

    local fileencoding
    [ ! -f "$REPPFILE_FORALL" ]  && { err "file[${REPPFILE_FORALL}] is not existed!"; return 1; }

    ## change reppscript.sh to linux file format, same to sed -i 's/\x0D$//' file
    grep -q $'\r' "$REPPFILE_FORALL" && fileencoding=windows || fileencoding=linux
    [ "$fileencoding" = "linux" ] && csv_fromlnx_towin "$REPPFILE_FORALL"


    ## ê³µí†µ custom ë³€ìˆ˜ë° ê³µí†µ pre/post script í™•ì¥
    ## define custom variable REPPSCRIPT_V1, REPPSCRIPT_V2
    readarray -d\` -t array_var < <(cat "$REPPFILE_FORALL"| awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="`";} \
    NR>=1 && NR<=2 {gsub(/""/,"\"",$0); gsub(/\r/,"",$7);print $4"`"$5"`"$6"`"$7}')
    eval "${array_var[0]}=${array_var[1]}"
    eval "${array_var[2]}=${array_var[3]}"
    #REPPFILE_OUT=${REPPSCRIPT_PRE} ; reppforgen_sh "${array_var[5]}"
    #REPPFILE_OUT=${REPPSCRIPT_POST}; reppforgen_sh "${array_var[7]}"

    local reppscript_pre="${array_var[5]%$'\n'}"; #ë§¨ë’¤ì— \nì€ ì‚­ì œ
    reppscript_pre="${reppscript_pre#\$'}" ; reppscript_pre="${reppscript_pre%'}"    # '~~~'' ì‚­ì œ
    reppscript_pre="${reppscript_pre#*\"}" ; reppscript_pre="${reppscript_pre%\"*}"  # "~~~" ì‚­ì œ
    local reppscript_post="${array_var[7]%$'\n'}" #ë§¨ë’¤ì— \nì€ ì‚­ì œ
    reppscript_post="${reppscript_post#\$'}" ; reppscript_post="${reppscript_post%'}"    # '~~~'' ì‚­ì œ
    reppscript_post="${reppscript_post#*\"}" ; reppscript_post="${reppscript_post%\"*}"  # "~~~" ì‚­ì œ


    ##ì „ì²´ csvë¥¼ ì½ì–´ arrayë¡œ ë°”ê¾¸ëŠ” ì‘ì—…ìœ¼ë¡œ ì´ë¥¼ ìœ„í•´ ë¨¼ì € reppforall.csvì˜ êµ¬ë¶„ìë¥¼ comma(,)ì—ì„œ backquote(``)ë¡œ ë°”ê¾¼ë‹¤.
    #REPO_LREV ì°¾ìœ¼ë©´ ê·¸ ë‹¤ìŒì¤„ë¶€í„° ì²˜ë¦¬í•˜ê²Œ ë˜ëŠ”ë°, ì´ë¥¼ìœ„í•´ awkì—ì„œ found=1ë¡œ ì„¤ì •í›„ ë‹¤ìŒì¤„ë¡œ ì´ë™
    #REPO_LREV (found 1ì´ê³ ) REPP_SCRIPTê°€ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´
    #gsub(/("|=)/,"",$1)          : change number to text
    #sed 's/,/`/g'                : change csv to txt
    #gsub(/""/,"\"",$7)           : change csv string "" to normal "
    #gsub(/\r/,"",$7)             : remove carrige return
    #ê·¸ëŸ°í›„ ë§ˆì§€ë§‰ìœ¼ë¡œ ì¶œë ¥, ì¦‰ REPP_SCRIPTê°€ ìˆëŠ” lineë§Œ ì¶œë ¥
    #cat "$REPPFILE_FORALL"| awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="\n"; found=0} /^REPO_LREV/ {found=1; next} found && ($1 !~ /^[0-9a-f]{10,}/ || $7 ~ /[[:print:]]+/) \
    #{gsub(/("|=)/,"",$1); gsub(/""/,"\"",$7); gsub(/\r/,"",$7);print $1"`"$2"`"$3"`"$4"`"$5"`"$6"`"$7}'> "$REPPFILE_FORALL".tmp
    #readarray -t arrayline < <(awk 'BEGIN{RS="\r\n"} {print}' "$REPPFILE_FORALL.tmp")
    readarray -d $'\r\n' -t arrayline < <(cat "$REPPFILE_FORALL"| awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="\r\n"; found=0} \
    /^REPO_LREV/ {found=1; next} found && ($1 !~ /^[0-9a-f]{10,}/ || $7 ~ /[[:print:]]+/) \
    {gsub(/("|=)/,"",$1); gsub(/""/,"\"",$7); gsub(/\r/,"",$7);print $1"`"$2"`"$3"`"$4"`"$5"`"$6"`"$7}')

    ## ê²°ê³¼ê°’ì„ reppforall_result.csvì— writeí•˜ë ¤ê³  í–ˆìœ¼ë‚˜, ë‹¤ì¤‘ scriptë¥¼ í˜¸ì¶œí•˜ëŠ” êµ¬ì¡°ë¡œ returnê°’ ì²˜ë¦¬ê°€ ì–´ë ¤ì›Œì„œ ë³´ë¥˜
    ## cat "$REPPFILE_FORALL"| awk '$1~/REPO_LREV/ {print; exit} {print}' > ${REPPFILE_FORALL%\.*}_result.csv

    ##REPO_XXXë¡œ ì‹œì‘í•˜ëŠ” heading ì„ ì œì™¸í•˜ê³  ê·¸ ë‹¤ìŒì¤„ ë¶€í„° ì²˜ë¦¬, count=1
    ##ë¨¼ì € ì‹¤í–‰í•  ë‚´ìš©ì„ ë³´ì—¬ì¤€ë‹¤. ì´ë•Œ ì‹¤í–‰ë¶ˆê°€ëŠ¥í•œ cmdê°€ ìˆìœ¼ë©´ ë©ˆì¶˜ë‹¤.
    bbar cyan "check user input commands" "â–¼â–¼â–¼ show only 100 char \n"
    local count total pcmd cmd pro tmp=
    local oneline=()
    #laptime reset

    for ((count=0,total=0; count<${#arrayline[@]}; count++ )); do
        ##read oneline to array
        readarray -t -d\` oneline <<< "${arrayline[$count]}"
        #IFS='`' read -d'\n' -r -a oneline <<< "${arrayline[$count]}"
        #declare -p oneline | sed 's/\[/\n[/g'

        cmd=$(echo ${oneline[6]} | xargs -0)
        pro=${oneline[4]};

        if [[ "$pcmd" == "$cmd" ]]; then
            printf -v tmp "%s%s " "$tmp" "$pro"
            progress "magenta" "cmd is same to above [$count]"
            continue
        else
            # ì´ì „ì— ëˆ„ì ëœ tmpë¥¼ í•œ ë²ˆì— ì¶œë ¥
            printf "${cyan}%s${NCOL}\n" "$tmp"
            tmp=""
        fi
        pcmd=$cmd
        [ -z "$pro" ] && break

        #debug (( "$count" == 4 )) && break
        ## ë§Œì•½ 6ë²ˆì§¸ itemì´ printê°€ëŠ¥í•œ ëª…ë ¹ì´ ì¡´ì¬í•˜ë©´ ëª…ë ¹ì„ ë³´ì—¬ì¤˜ë¼.
        if [[ -n "${cmd}" ]]; then
            printf -v cmd "%-.100s" "${cmd//\\n/}"
            bbar cyan "[$((total=total+1))] ${pro}" "${cmd}\n"
        fi

        if [[ "$cmd" =~ "repp forall" ]]; then err "csv must not include 'repp forall' cmd. it's recursive" ; return 1; fi

        (( $total == 0 )) && { err "No target git project is found in $REPPFILE_FORALL
        If create above file by 'repp forall gen', Please add <your command> in REPP_SCRIPT column using excel" ; return 1; }
    done
    #laptime
    ## REPPSCRIPT_V1, REPPSCRIPT_V2ì˜ ê°’ì„ ë³´ì—¬ì¤€ë‹¤.
    echo
    bbar yellow "check user input variables" "â–¼â–¼â–¼ show full\n"
    bbar yellow "REPPSCRIPT_V1" "$REPPSCRIPT_V1\n"
    bbar yellow "REPPSCRIPT_V2" "$REPPSCRIPT_V2\n"

    ##REPPSCRIPT_PRE, REPP_POSTSCRIPTë¥¼ ë¨¼ì € ë³´ì—¬ì¤€ë‹¤.
    ## leading, trailing space ì œê±°
    echo
    bbar magenta "check user common pre/post script" "â–¼â–¼â–¼ show full\n"
    bbar magenta "REPPSCRIPT_PRE"  "$( printf "\n%s" "${reppscript_pre:-not-defind}"  )\n"
    bbar magenta "REPPSCRIPT_POST" "$( printf "\n%s" "${reppscript_post:-not-defind}" )\n"

    ## repp forall ì…ë ¥ì‹œ ì „ì²´ë¥¼ ì–´ë–»ê²Œ ì‹¤í–‰í• ì§€ 1íšŒ ë¬¼ì–´ë³¸í›„, ê° ëª…ë ¹ì–´ ì‹¤í–‰ì‹œë¯¸ë‹¤ ë‹¤ì‹œ ë¬¼ì–´ë³¸ë‹¤.
    local i ccmd cmd= pro= lrev from
    case "$opt" in    g|go|goo) :
        ;; '') read -p "$(echo -e "\n\n${cyan}[enter:execute by asking |g |go |goo: run all with log level |ctrl+c:break]:${NCOL}")" opt
        ;;  *) err "wrong option" ; return 1
    esac
    case "$opt" in ''|g|go|goo) :
        ;; *) err "you have to input either 'enter', 'g', 'go', or 'goo'";  return 1
    esac


    touch $REPPSCRIPT_OUT && chmod +x $REPPSCRIPT_OUT
    for ((count=0,total=0; count<${#arrayline[@]}; count++ )); do
        readarray -t -d\` oneline <<< "${arrayline[$count]}"

        ## projectê°€ ë¹„ì›Œìˆìœ¼ë©´ skip
        pro=${oneline[4]}; [ -z "$pro" ] && break

        ## debug show command
        #for i in "${!oneline[@]}"; do printf "[%d]=%q\n" "$i" "${oneline[$i]}"; done

        ## leading, trailing space ì œê±°
        lrev=$(echo "${oneline[0]}" | xargs)
        cmd="${oneline[6]%$'\n'}" #ë§¨ë’¤ì— \nì€ ì‚­ì œ

        if [ -z "$cmd" ];then continue; fi
        cmd="${cmd#\$'}" ; cmd="${cmd%'}"    # '~~~'' ì‚­ì œ
        cmd="${cmd#*\"}" ; cmd="${cmd%\"*}"  # "~~~" ì‚­ì œ

        ## í˜„ì¬ contextì—ì„œ ì‹¤í–‰ì„ ìœ„í•´ sourceë¡œ fileë¡œ ë³€í™˜í•˜ì—¬ í˜¸ì¶œí•œë‹¤.
        ## pre script + user command script + post scriptë¥¼ í•©ì³ ì‹¤í–‰íŒŒì¼ì„ ë§Œë“¤ê³  ì´ë¥¼ sourceë¡œ ì‹¤í–‰í• ìˆ˜ ìˆë„ë¡ cmdì— í• ë‹¹í•œë‹¤.
        ## csvì— ì½ì–´ì˜¨ scriptê°€ fileì´ë©´ catìœ¼ë¡œ outìœ¼ë¡œ ë„£ê³ , cmdì´ë©´ printfë¡œ outìœ¼ë¡œ ë„£ëŠ”ë‹¤.
        : > $REPPSCRIPT_OUT ##íŒŒì¼ ë‚´ìš© ì§€ìš°ê¸°
        [ "${reppscript_pre}" != "NONE" ] && printf "%s\n" "${reppscript_pre}" >> $REPPSCRIPT_OUT
        if [[ -f "${cmd}" ]]; then from=file
            #cmdë¥¼ íŒŒì¼ê³¼ ë³€ìˆ˜ ì–‘ìª½ìœ¼ë¡œ ì €ì¥
            ccmd=$(tee -a $REPPSCRIPT_OUT < "${cmd}")
        else from=' cmd'
            #REPPFILE_OUT=${REPPSCRIPT_OUTP}; reppforgen_sh "${cmd}";
            printf "%s\n" "${cmd}" >> $REPPSCRIPT_OUT
            #cmdì•ˆì— ì¡´ì¬í•˜ëŠ” fileì´ ìˆëŠ”ê²½ìš°, ëª¨ë‘ ëª¨ì•„ ê·¸ ë‚´ìš©ì„ ë³´ì—¬ì£¼ê¸° ì¤€ë‹¤.
            for i in ${cmd}; do eval "[[ -f "$i" ]] && cat "$i" >> $fileincmd" 2> /dev/null; done
            ccmd=$(cat $fileincmd)
            : > $fileincmd
        fi
        [ "${reppscript_pre}" != "NONE" ] && printf "%s\n" "${reppscript_post}" >> $REPPSCRIPT_OUT

        #if ! shellcheck -s bash -S error $REPPSCRIPT_OUT ; then err "input command is not correct!"; return 1; fi

        #g, go(with msg), goo(with fullmsg), enter, otherë¥¼ ë¬¼ì–´ë³¸ë‹¤.
        if [ "$opt" != "g" ]; then under "[$((total=total+1))] ${oneline[4]}\n"; fi
        if [ "$opt" != "g" ] || [ "$opt" != "go" ]; then bbar cyan "${oneline[5]}" "\n[ csv] ${cmd}\n[$from] ${ccmd:=same}\n"; fi
        if [ -z "$opt" ] || [ "$opt" = "debug" ] || [[ $opt =~ ^g[o]*$ ]]; then
            #debug echo ${REPPSCRIPT_OUT}
            #cmd="source $REPPSCRIPT_OUT";
            #run command
            ## ê° repositoryë§ˆë‹¤ ë‹¤ì‹œ í•œë²ˆì”© ë¬¼ì–´ë³´ê²Œ ëœë‹¤. g|go|gooë¥¼ ì…ë ¥í•˜ë©´ ë‚˜ë¨¸ì§€ëŠ” ë¬¼ì–´ë³´ì§€ ì•Šê³  ë°”ë¡œ ì‹¤í–‰í•œë‹¤.
            [[ $opt =~ ^g[o]*$ ]] || read -p "$(echo -e "${yellow}[enter: run next |g |go |goo: run all with log level |debug:show log| other: skip next |ctrl+c: break all] :${NCOL}")" opt
            pushd "$REPP_ROOT/${oneline[5]}";
            case "$opt" in
                g|go|goo|'') :
                ;; debug) [[ $- == *x* ]] && set +x || set -x #toggle debug
                ;; *) opt= ; echo skipped && continue
            esac

            REPO_ROOT="$REPP_ROOT" REPO_LREV="${lrev}" REPO_GROUP="${oneline[1]}" REPO_REMOTE="${oneline[2]}" REPO_RREV="${oneline[3]}" \
            REPO_PROJECT="${oneline[4]}" REPO_PATH="${oneline[5]}" REPPSCRIPT_V1="${REPPSCRIPT_V1}" REPPSCRIPT_V2="${REPPSCRIPT_V2}" source $REPPSCRIPT_OUT

            # ## REPP_RESULTê°’ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ì„ë•Œì— ëŒ€í•œ defaultê°’ ì„¤ì •
            # if [ "$__ret" = "NONE" ]; then [ $? -eq 0 ] && __ret='OKAY' || __ret='FAIL'; fi
            # #windowsíŒŒì¼ì¸ì§€ linuxíŒŒì¼ì¸ì§€ íŒë‹¨
            # if [ "$fileencoding" = "windows" ];
            # then awk -v count="$((count+3))" -v ret="$__ret" 'BEGIN{RS=ORS="\r\n"} NR==count {print $0,ret}' "$REPPFILE_FORALL" >> ${REPPFILE_FORALL%\.*}_result.csv
            # else awk -v count="$((count+3))" -v ret="$__ret" 'BEGIN{RS=ORS="\n"} NR==count {print $0,ret}' "$REPPFILE_FORALL"   >> ${REPPFILE_FORALL%\.*}_result.csv
            # fi
            popd
        fi
    done
}

##ì•„ë˜ëŠ” repp forall êµ¬í˜„ë‚´ìš©ì„ ê¸°ë¡í•©ë‹ˆë‹¤.
:<< COMMENT
10. repp forall genì´ë‚˜ repp forall -c <cmd>ëª…ë ¹ìœ¼ë¡œ reppforall.csvë¥¼ ìƒì„±í•˜ê²Œ ëœë‹¤.
 11. 2ê²½ìš° ëª¨ë‘ reppforgen_csv ì—ì„œ ì²˜ë¦¬í•˜ë©°, genì´ë©´ ì „ì²´repo/ë¹ˆcmd, -c <cmd>ì´ë©´ í•´ë‹¹repo/cmd í˜•íƒœë¥¼ ê°€ì§„ csvë¥¼ ìƒì„±í•œë‹¤.
 12. ì—¬ê¸°ì„œ repp forall testcase ëª…ë ¹ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ê¸°ì¡´ì— ì˜ ë™ì‘í•˜ëŠ” csvë¥¼ copyí•´ì˜¨í›„ ë°”ë¡œ repp forallë¡œ êµ¬ë™í•´ë³¼ìˆ˜ ìˆë‹¤.
 14. ìƒì„±ëœ reppforall.csvë¥¼ xlsë¡œ ì—´ì–´ ì›í•˜ëŠ” ëª…ë ¹ì´ ë˜ë„ë¡ í¸ì§‘ì„ ì™„ë£Œí•œë‹¤.
20. repp forall ëª…ë ¹ìœ¼ë¡œ reppforall.csvì— ê¸°ë¡ëœ repoë¥¼ ëŒì•„ë‹¤ë‹ˆë©°, ê° cmdë¥¼ ì‹¤í–‰í• ìˆ˜ ìˆë‹¤.
 21. ë¨¼ì € csv_fromlnx_towin í•¨ìˆ˜ë¥¼ í†µí•´ reppforall.csvê°€ linux formatì´ë©´ windowsë¡œ ë°”ê¾¼ë‹¤. (PC í¸ì§‘ì €ì¥ì‹œ window formatìœ¼ë¡œ ì €ì¥ë˜ë¯€ë¡œ)
30. csv headingë¥¼ ì½ì–´ì™€ REPPSCRIPT_V1, REPPSCRIPT_V2ë“± ë¨¼ì € ë³€ìˆ˜ë“¤ì„ ì„ ì–¸í•œë‹¤.
 31. ë³€ìˆ˜ reppscript_pre, reppscript_postì— csvì— ì •ì˜ëœ pre/post scriptë¥¼ ì½ì–´ ì €ì¥í•´ë†“ëŠ”ë‹¤.
 32. ì´ë•Œ scriptë“¤ì— í¬í•¨ëœ íŠ¹ìˆ˜ë¬¸ìë¥¼ ì œê±°í•˜ê¸° ìœ„í•´ reppforgen_sh í•¨ìˆ˜(ëŒ€ì²´í•¨)ë¥¼ í˜¸ì¶œí•˜ì—¬ ì •ì œí•œë‹¤.
40. ì´ì œ reppforall.csvë“¤ì˜ ë³¸ë¬¸(REPO_LREV ë‹¤ìŒì¤„ ê¸°ì¤€)ì„ ëª¨ë‘ ì½ì–´ arrayline ë°°ì—´ì— ë„£ëŠ”ë‹¤. (ì´ë¥¼ ìœ„í•´ êµ¬ë¶„ìë¥¼ backqouteë¡œ í•˜ê³ , REPPSCRIPTê°€ ì¡´ì¬í•˜ëŠ” columnë§Œ ì €ì¥)
 41. ì‘ì—…ê°œìš”ë¥¼ ë³´ì—¬ì£¼ê¸° ìœ„í•´ arraylineì— ë“¤ì–´ê°„ ì‘ì—…í•  repo ì •ë³´ì™€ cmd(REPPSCRIPT)ë¥¼ ëª¨ë‘ ì¶œë ¥í•´ì¤€ë‹¤.
 42. REPPSCRIPT_V1/2ë³€ìˆ˜ì™€ REPPSCRIPT_PRE/POST scriptì˜ ë‚´ìš©ë„ ë³´ì—¬ì¤€ë‹¤.
50. repp forallëª…ë ¹ì„ ê° repoë§ˆë‹¤ ë¬¼ì–´ë³´ë©´ì„œ ì‹¤í–‰í• ì§€ í•œêº¼ë²ˆì— ì‹¤í–‰í• ì§€, ì •ë³´ëŠ” ì–¼ë§ˆë‚˜ ì¶œë ¥í• ì§€ ë¬¼ì–´ë³¸ë‹¤.
 51. arraylineì—ì„œ í•œì¤„ì‹ ì½ì–´ì™€ì„œ REPO_ROOT/LREV/GROUP/REMOTE/RREV/PROJECT/PATH/REPPSCRIPT_V1/REPPSCRIPT_V2/cmd ê°’ì„ ì €ì¥í•œë‹¤.
 52. ì½ì–´ì˜¨ REPPSCRIPT(cmd)ê°€ fileì´ë©´ ë†”ë‘ê³ , cmdì´ë©´ fileì— ë„£ëŠ”ë‹¤. ì´í›„ sourceë¡œ í•´ë‹¹ fileì„ ì½ì–´ì˜¤ê¸° ìœ„í•¨ì´ë‹¤.
 53. ì–´ì§¸íŠ¼ REPPSCRIPT_PRE + REPPSCRIPT(cmd) + REPPSCRIPT_POSTê°€ ë˜ë„ë¡ ìµœì¢… ì‹¤í–‰ script íŒŒì¼ì„ ë§Œë“ ë‹¤.
60. ì´ì œ ì‚¬ìš©ìì—ê²Œ ì‹¤í–‰ë°©ë²•ì„ ì••ë ¥ë°›ì•„, ìœ„ì˜ REPP_XXXë³€ìˆ˜ë“¤ê³¼ í•¨ê»˜ source êµ¬ë¬¸ìœ¼ë¡œ scriptë¥¼ í˜„ì¬ shellì— ë„£ì–´ ì‹¤í–‰í•œë‹¤.
 61. ì‹¤í–‰ì´ ì™„ë£Œë˜ë©´ arraylineì—ì„œ ë‹¤ìŒì¤„ì„ ì½ì–´ì™€ ìœ„ 51ë²ˆë¶€í„° ë°°ì—´ëê¹Œì§€ ë°˜ë³µí•œë‹¤. >>> ì‹¤í–‰ê²°ê³¼ ì²˜ë¦¬ê°€ í•„ìš”í• ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.
COMMENT


##ì•„ë˜ëŠ” repp forallì„ testí•˜ëŠ” ë°©ë²•ì„ ê¸°ìˆ í•œë‹¤.
:<< COMMENT
1. ì•„ë˜ì™€ ê°™ì´ repp forall -c 'ëª…ë ¹'ì„ ë„£ì–´ì„œ ì‹¤í–‰í•´ë³´ê±°ë‚˜, reppforall.csvì˜ REPP_SCRIPT ì˜ì—­ì— repp forall -cë¥¼ ì œì™¸í•˜ê³  ëª…ë ¹ì„ ë„£ì–´ì„œ ì‹¤í–‰í•´ë³¸ë‹¤.
2. ë¨¼ì € ì•„ë˜ ëª…ë ¹ì„ í•˜ë‚˜ì”© ì…ë ¥í•œí›„ repp forallë¡œ ì •ìƒì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ”ì§€ í™•ì¸í•œë‹¤.
    >repp forall -c bash -c 'echo "${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}"'
    >repp forall honda/con/autosar tiger/metas/meta-tiger -cj1 \
        bash -c '[ "${REPO_REMOTE}" != "vgit_na" ] && echo "project:${REPO_PROJECT}" || echo "path:${REPO_PATH}" ' \
        $USER $PWD
    >repp forall -c bash -c 'case ${REPO_PROJECT} in
        */*/*|*/*/*/*)
            if [[ "${REPO_PATH}" =~ (.*build?)    ]]; then echo "path:[${BASH_REMATCH[1]}]"
            elif [[ "${REPO_PROJECT}" =~ (.*build?) ]]; then echo "project:[${BASH_REMATCH[1]}]"
            else echo "remote:[${REPO_REMOTE}]"
            fi
        ;;          *)  printf "~~~~~~~~~~~~~~~${REPO_PROJECT}[%s]\n" "$1 $2"
    esac' - $USER $PWD
    >repp forall . -c bash ~/.proFILEs/repo_var.sh - $USER $PWD
    >repp forall . -c 'revv accessall ${REPO_REMOTE} ${REPO_PROJECT}'
##<ì£¼ì˜> repp forall -c <cmd>ì•ˆì—ì„œ
    #repp ì§€ì›ëª…ë ¹ì€ bashì—†ì´ ì‹¤í–‰ì‹œì¼œì•¼ í•œë‹¤. revv accessëŠ” bash -c ì—†ì´ ì‹¤í–‰ì‹œì¼œì•¼ í˜„ì¬ contextì—ì„œ ì‹¤í–‰ë¨
    #repp forall -c 'repp forall testcase' #ì¦‰, scriptì—ì„œ repp forall ëª…ë ¹ì€ ì¬ê·€í˜¸ì¶œë¨ìœ¼ë¡œ ì‹¤í–‰ì´ ë¶ˆê°€
    #repp forall -c 'bash reppscript.in.sh' #reppscriptë¡œ ì‹œì‘í•˜ëŠ” scriptì—­ì‹œ ì‚¬ìš©í• ìˆ˜ ì—†ë‹¤. ì¬ê·€í˜¸ì¶œë¨ìœ¼ë¡œ ì•ˆë¨

3. repp forall testcase ëª…ë ¹ìœ¼ë¡œ ê¸°ì¡´ì— ì¤€ë¹„ëœ csvë¥¼ reppforall.csvë¥¼ copyí•œí›„, repp forallë¡œ ê²€ì¦í•œë‹¤.
COMMENT



function reppdiff(){
## ---------------------------------------------------------------------------
# get repo command from exising repo project
# $1 show repo command (default: save info to each variable such as REPP_URL, REPP_BRANCH, ...)

    local cmd=$1
    local src=$2
    local target=$3

    [[ ! "${PWD}" = "${REPP_PATH}" ]] && pushd ${REPP_PATH}

    reppget_repcmd
    case ${cmd} in
        diff)
                ## listup xml by date and get input
                [ -z "${src}" ] && ( git log --since=3-weeks --first-parent --date=format:'%Y-%m-%d (%a) %H:%M:%S' --pretty=format:'%Cgreen%cd [%t]%Creset' --name-status| awk 'NF==1{date=$1}NF>1 && !seen[$2]++{print date,$0}' FS=$'\t' )
                if [ -z "${src}" ]; then
                    under "input format: <old manifest> <new manifest>\n"
                    echo "    ex) Daily/project_240621.xml mig_240701.xml  #compare both"
                    echo "    ex) Daily/project_240621.xml                 #compare to current"
                    read -p $'\n\ninput: ' opt

                    src=${opt% *}
                    [ -z ${opt#* } ] && clog "\ninput old [${opt}]" "will be compared to current manifest [${REPPFILE_MANI}]"|| clog "will be executed:" "repp mani diff ${opt}"
                fi
                echo
                warn "if branches are changed between <old manifest> and <new manifest>, you must 'repo sync' without -c option to get all commits !!"
                read -p '[enter:continue without sync| y:yes branches are changed, sync continue| ctrl+c:break]'
                [ "$opt" = "y" ] && repo sync -qj5

                ## assign target value
                if [ -z "$target" ]; then [[ "$opt" =~ " " ]] && [ -z "${opt#* }" ] && target="${opt#* }" || target=${REPPFILE_MANI}; fi

                ##check if both manifest files exists?
                if [ ! -f "${src}"    ]; then err "${src} file is not existed"; return 1; fi
                if [ ! -f "${target}" ]; then err "${target} file is not existed"; return 1; fi

                repo --no-pager diffmanifests --no-color --raw ${src:=${opt% *}} ${target} --pretty-format='> %s| %h| %an| %ci'|sed -e 's/\[m//g' >${REPP_DIR}/repp.diff.tmp
                #repo --no-pager diffmanifests --no-color --raw  Daily/POIP_240627.xml default.xml --pretty-format='>%s|%h|%an|%ci'|sed -e 's/\[m//g' >${REPP_DIR}/repp.diff.tmp
                cat ${REPP_DIR}/repp.diff.tmp| sed -e '/Merge commit/d;/Merge "/d'| while read -r line; do [ "${line:2:1}" = '>' ] && echo "${line/ /|}" || echo -e "|||\n|||\n${line// /|}" ; done > ${REPP_DIR}/repp.diff2
                cat ${REPP_DIR}/repp.diff2 | column -s'|' -t --table-columns status,subject,commit-id,author,date --table-wrap subject --output-width 200 > ${REPP_DIR}/repp.changes
                rm -f ${REPP_DIR}/repp.diff.tmp ${REPP_DIR}/repp.diff2
                showRUN repo diffmanifests ${src:=${opt% *}} ${target} --pretty-format='%Cred%h %Cgreen(%ci) %C(blue)<%an>%Creset %s'

                cat <<-EOL
		guide)   added projects(NOT compare) : path-added,   project-added   (in ${target} manifest)
		       removed projects(NOT compare) : path-removed, project-removed (in {src} manifest)
		       missing projects(NOT compare) : path-same,    project-changed
		  unreachable revisions(NOT compare) : need to 'repo sync' (without -c, fetch all project revision)
		          skip projects(NOT compare) : path-same, project-same, branch-same (No diff, SKIP)
		       changed projects( OK compare) : path-same, project-same, branch-changed
EOL
                info "diff list is saved to ${REPP_DIR}/repp.diff"
                info "changenote is saved to ${REPP_DIR}/repp.changes"

    ;;  diffcheck)
                local cpath cbrold cbrnew cremote cproject ccommitid deployed
                IFS=' '; cat ${REPP_DIR}/repp.diff | sed -e 's/\x1b\[[0-9;]*m//g'| while read -r -a line; do
                #echo "${line[@]}"
                    case ${line[0]} in
                         C) #compare case changed project
                            #3rd is remote, 7th is project,
                            cpath="${line[1]}"; cbrold="${line[2]}"; cbrnew="${line[3]}"
                            #cremote=$(cat ${REPPFILE_CSV} |grep ${cpath} | cut -d'|' -f3)
                            cremote=$(cat ${REPPFILE_CSV} |grep ${cpath} |awk -v FS="|" '{print $3}')
                            cproject=$(cat ${REPPFILE_CSV} |grep ${cpath} | awk -v FS="|" '{print $8}'|xargs)

                        ;;R)
                            ccommitid="${line[1]/|/}"
                            ##get change_id and find commmit in new branch, it is deployed.
                            deployed=$( revv commit find $(revvserver_item ${cremote} path) ${ccommitid} | sed '1d'|  jq -cC '.[].branch' | grep "${cbrnew}" )
                            [ -z "${deployed}" ] && info "[missing commits] ${cremote}> ${cproject}> ${cbrnew}> ${ccommitid}"
                    esac
                done
    esac
    popd
}



function reppget_repcmd(){
## ---------------------------------------------------------------------------
# REPPFILE_MANI ë³€ìˆ˜ì™€ repo init ëª…ë ¹ì–´ë¥¼ ì¶”ì¶œí•œë‹¤.
# $1 ëª…ë ¹ì–´ë¥¼ ì¶œë ¥í• ì§€ ì—¬ë¶€ (default: save info to each variable such as REPP_URL, REPP_BRANCH, ...)
    local count file_tempa file_tempb

    if [ -z "${REPP_BRANCH}" ]; then
        printf "${RED}[warning] please check if you have switched to a topic branch from after repo init${NCOL}\n"
        printf "${RED}[warning] temporarily set to local branch name${NCOL}\n"
        printf "\tyou can set-up upstream branch with: git branch -u %s <branch-name>\n" "$(echo $(git remote -v |cut -f1))"
        REPP_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    fi

    ## find using manifest.xml
    file_tempa=$(command ls -Art ../*.xml | tail -n 1)
    count=$(grep -c include ${file_tempa})
    if [ -L "${file_tempa}" ];then
        file_tempb=$(readlink "${file_tempa}")
        REPPFILE_MANI=${file_tempb#*/}
    elif [ $count -eq 1 ]; then
        file_tempb=$(grep include $file_tempa |sed -E 's/<.*name="(.*)".\/>/\1/')
        REPPFILE_MANI=${file_tempb// /}
    else
        REPPFILE_MANI=default.xml
    fi

    if [ -n "$REPP_GROUPS" ] && [[ ! "${EXTRA_OPTION}" =~ "--groups"    ]] ;then EXTRA_OPTION="--groups=$REPP_GROUPS " ; fi
    if [ -n "$REPP_REF" ]    && [[ ! "${EXTRA_OPTION}" =~ "--reference" ]] ;then EXTRA_OPTION+="--reference=$REPP_REF "; fi
    if [ -n "$REPP_MIRR" ]   && [[ ! "${EXTRA_OPTION}" =~ "--mirror"    ]] ;then EXTRA_OPTION+="--mirror "             ; fi


    if [ "$1" = "info" ];then
        bar inline "repo-init cmd"
        ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        REPP_CMD="repo init -u $REPP_URL -b $REPP_BRANCH -m ${REPPFILE_MANI} ${EXTRA_OPTION} --repo-url=${REPP_REPOURL}"
        log "${REPP_CMD}"
    fi
    return 0
}



function reppinfo(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local manifest=$1

    pushd ${REPP_PATH}
    #oldIFS=${IFS}; IFS='';

    ##show repo dir path
    bar inline "repo path"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    log "${REPP_PATH}"

    ##get global variable and repo init command.
    reppget_repcmd info

    ##show manifest file with included sub manifests.
    bar inline "manifests"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    clog  "    <name of manifest>                                      <including branches>"
    reppshow_manifesttree ${manifest:-${REPPFILE_MANI}} 0
    info "to see specific xml, run 'repp info <xml>'"

    [ -n "$manifest" ] && return 0

    ##show count of repository
    ### block infomation
    bar inline "more information for this repositories"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ##show last synced time
    if [ -f .git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y .git/FETCH_HEAD );
    else clog "last manifest-synced time(check date of files below): " $(ls -ld .git) ;fi
    popd

    clog "md5sum for all repositories:"
    repo forall -j16 -c git log -1 --pretty=format:%H%n  2> /dev/null | md5sum

    clog "number of repositories: " $REPP_COUNT
    read -t 2 -p "Press Ctrl+C not to see extra information(generated by 'repp mani init') ... "

    ##manifestì— ê¸°ë¡ëœ remoteì •ë³´ë¥¼ ë³´ì—¬ì¤€ë‹¤.
    bar inline "remotes & review sites"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #for (( i=0; i < ${#REPP_REMOTELIST[@]}; i++ )); do printf "remote: %s,\t\t review: %s\n" "${REPP_REMOTELIST[$i]}" "${REPP_REVIEWLIST[$i]}"; done
    #cat ${REPPFILE_JSON}|jq -cC '.remote[]'
    cat ${REPPFILE_JSON_REMOTE}|jq -cC '.|sort_by(.fetch)[]|{fetch, name, alias, view, pushurl, revision}'

    ##check if git submodule is activate
    ## repp_initdbì—ì„œ repp.csv.submoduleì„ ë§Œë“¤ì–´ ë†“ì•˜ë‹¤.
    #cat ${REPPFILE_CSV}.submodule| xargs -I% bash -c 'set -- %; [ -e "$1/$2/.git" ] && cat $1/.gitmodules'
    #cat ${REPPFILE_CSV}.submodule| xargs -I% bash -c 'set -- %; echo [$1/$2]; [ -e "$1/$2/.git" ] && cat $1/.gitmodules'
    pushd "${REPP_ROOT}"

    bar inline "git submodule & lfs information"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if [ -s ${REPPFILE_CSV}.submodule ]; then
    clog "git submodule repositories path(git):" "$(wc -l < ${REPPFILE_CSV}.submodule)";
    cat ${REPPFILE_CSV}.submodule| xargs -I{} bash -c \
    '   set -- {};
        if [ -e "$1/$2/.git" ]; then printf "\e[1;33m   active:\e[0m $1/$2\n"; cat $1/.gitmodules;
                                else printf "\e[0;31m inactive:\e[0m $1/$2\n"; fi
    ';fi

    if [ -s ${REPPFILE_CSV}.lfs ]; then
        clog "\ngit lfs repositories path(git):" "$(wc -l < ${REPPFILE_CSV}.lfs)";
        cat ${REPPFILE_CSV}.lfs;
    fi
    popd


    ##show duplicated repositories
    local f_dup=${REPPFILE_CSV}.dup
    awk -v 'FS=|' '{print $7}' ${REPPFILE_CSV} |sort|uniq -dc > $f_dup
    local f_count=$(wc -l < "$f_dup")
    clog "\nduplicated repositories:" "$f_count"
    # íŒŒì¼ì˜ ë¼ì¸ ìˆ˜ê°€ 20 ì¼ë•Œë§Œ í™”ë©´ì¶œë ¥
    if [ "$f_count" -le 20 ]; then cat "$f_dup";
    else info "duplicated repositories are over 20, so duplicated git list are saved to \n [ ${f_dup} ]";
    fi
    #IFS=${oldIFS}
}



function reppshow(){
## ---------------------------------------------------------------------------
# print information(changes, recent commits) of current repository#
    ##topic/working branch
    bar inline "repo branch: check if working branch existed (WAIT: It takes time) "
    repo branch 2> /dev/null

    ##run command "repo info"
    echo "repo status" > ${REPPFILE_STATUS}

    ##remove colored output with 1) sed command, 2) --color option
    #repo status -j8 |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPPFILE_STATUS}
    repo --no-pager --color=never status  >> ${REPPFILE_STATUS} 2> /dev/null &

    ##list up repo commit, remote, branch, project, path
    reppfind |more -60

    ## repo info command is duplicated with reppfind functionality, so remove it.
    #bar inline "repo info: git repo/source path /branch rev saved to [ ${REPPFILE_STATUS} ]"
    #echo "repo info" >> ${REPPFILE_STATUS}
    #repo info |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPPFILE_STATUS}

    bar inline "repo status: uncommitted changes list saved to [ ${REPPFILE_STATUS} ], it takes about 2mins to get info"
    info "${REPPFILE_STATUS} you can use this file to check dirty commits left"
}



# local menu_items=('go ROOTã€€dir' 'go Manifestsã€€dir' 'go GITã€€root dir' 'exit')
# run_menu "${menu_items[@]}"
# case "$?" in
    # 1|11)  cd "${REPP_ROOT}"        ;;
    # 2|12)  cd "${REPP_PATH}"        ;;
# esac

function reppgo() {
## ---------------------------------------------------------------------------
# return git root path or return near git path
    local cmd="$1"

    case $cmd in
        help) cat <<- EOF
				usage) repp go              # go repo root dir
				usage) repp go root         # same to above
				usage) repp go mani         # go manifest dir
				usage) repp go git          # go current git root dir
				usage) repp go repo         # show menu to select similar-depth repo project
				usage) repp go <dir>        # show git path and move there
EOF
                return 1
      ;;repo)
                local INPUT=( $(find ${REPP_ROOT}/.. -maxdepth 4 -name ".repo" 2> /dev/null |head -60))
                if [ -n "${INPUT}" ];
                then run_menu "${INPUT[@]}";  cd "${menu_selected}/.."
                else INPUT=( $(find ${HOME} -maxdepth 4 -name ".repo" 2> /dev/null |head -60))
                     run_menu "${INPUT[@]}";  cd "${menu_selected}/.."
                fi
      ;;repp)   cd ${REPP_DIR}
      ;;mani)   cd ${REPP_PATH}
      ;;  '')   gitt go root
      ;;   *)   gitt go $cmd
    esac
}



function gittgo() {
## ---------------------------------------------------------------------------
# return git root path or return near git path
    local cmd="$1"
    local current_dir=${PWD}

    case $cmd in
        help) cat <<- EOF
				usage) gitt go root         # go repo root dir
				usage) gitt go mani         # go manifest dir
				usage) gitt go git          # go current git root dir
				usage) gitt go              # same to above
				usage) gitt go <dir>        # listup git path including 'dir' and move to select
				   ex) gitt go build        # lustup git path including 'build' and move to select
EOF
                return 0
      ;;root)   cd "${REPP_ROOT:-${GITT_PATH}}"; if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
      ;;mani)   cd "${REPP_PATH}"; if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
    ;;git|'')   cd "${GITT_PATH:?'can not find .git path'}"; if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
    esac

    if ! repp_initvar; then warn "your are not in repo"; return 1; fi
    if [ ! -f ${REPPFILE_CSV} ]; then reppfind $cmd; fi

    local INPUT=( $(cat ${REPPFILE_CSV} |grep ${cmd}| awk -v FS='\\|' '{print $8}'| sort) )
    if [ -n "${INPUT}" ];
    then
        run_menu "${INPUT[@]}"; cd "${REPP_ROOT}/${menu_selected##* }";
        if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
    else warn "you must find path manaully"; return 1
    fi
}



function reppcommit(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local cmd=$1
    local base=$2
    local target=$3
    local server
    case $cmd in
        last)
            bar outline "repo get newest N of last(-1) commit from each gits"
            bar inline "date:YMD HMS]       [sha]    [author]         [commit title]                                         [branch]                            [git project"
            repo forall -j16 -c 'printf "%-100.100s %-32.32s %-s \n" "$(git log -1 --abbrev=7 --date=format:"%Y-%m-%d %H:%M:%S" --pretty=format:"%ad  %h  [%an] %s")" "${REPO_RREV}" "${REPO_PROJECT}"' | sort -r |head -${base:-50}
            #repo forall -c "git log -1 --abbrev=6 --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%ad  %h  [%an] %d %s%n'" |sort -r |head -${base:-50}
      ;;diff)
            reppdiff diff "$base" "$target"

      ;;find)
            for server in na as eu devops_test review null; do
                if [ "$server" != "null" ]; then
                    if revvcommit find ${server} ${base}; then break; fi
                    clog "gerrit url:" $server/plugins/gitilies/$pro/+/$source
                    ## https://git.repp.com/as/plugins/gitiles/npro/build/+/f94ba87

                else  break; fi
            done
      ;;help|*) cat <<- EOF
				usage) repp commit last N            # show top N commits from each git HEAD
				   ex) repp commit last 40           # show top 40 commits form each git lastest HEAD
				usage) repp commit diff <from> <to>  # show diff commits <from.xml> and <to.xml>
				   ex) repp commit diff              # show selectable xml list and show diff between them
				usage) repp commit find <commit-id>  # find commit all remote review system & local repository
				   ex) repp commit find ecd867916b   # find commit ecd867916b in all server and print info

				 info) 'repp commit find' same to 'revv commit find <all-servers> <>'
EOF
    esac
return 0
}



function repp_initdb(){
## ---------------------------------------------------------------------------
# create DB from comparing repo manifest and repo forall
# $1 command
# usage: repp_initdb is used only by function call.

    local cmd=$1
    case $cmd in
       init) if [ "$REPP_INIT" -ge 1 ]; then rm -rf ${REPP_DIR} ; fi
      ;;  *) [ -f "${REPPFILE_CSV}" ] && { $DEBUG "\${REPPFILE_CSV}:${REPPFILE_CSV} reused above file or you can remove and refresh repository info"; return 0; }
    esac
    (( "$(reppversion ver 2>/dev/null)" < 230 )) && { reppversion toggle; warn "automatically update to latest repo version, you can restore 'repp version toggle'"; }
    if [[ ! $(column -V 2>/dev/null|grep util-linux) =~ "util-linux" ]] ;then
        clog "column need to reinstalled, please 'repp install'";
    fi

    #laptime reset;
    warn "REPP DB will be regenerated"; wave
    ## generate json from manifest, #suppress all log for generation json
    [ -d ${REPP_DIR} ] || mkdir ${REPP_DIR}
    repo manifest -r --json -o ${REPPFILE_JSON} &>/dev/null
    if (( "$(reppversion ver 2>/dev/null)" > 220 )) && ! [ -s ${REPPFILE_JSON} ]; then
        warn "check if you are in mirror repo, use source repo NOT mirror
        or failed by manifest error, check with 'repo manifest -r --json'"
    fi
    cat ${REPPFILE_JSON} | jq .remote > ${REPPFILE_JSON_REMOTE}


    #for debug:use 'declare -p items_alias'
    ## get <default> from json
    #readarray -d'|' -t item_default < <(cat  ${REPPFILE_JSON} |jq -j '.default|.revision,"|",.groups,"|",.remote,"|",.upstream,"|",."dest-branch","|",.name,"|",.path,"|"')
    readarray -d'|' -t line_default < <(cat ${REPPFILE_JSON} | jq -r '.default|{revision,groups,remote,upstream,"dest-branch",name,path,fetch} + .| to_entries | map("\(.key)=\(.value)") | join("|")' )
    ## get <remote> from json
    #readarray -t items_remote  < <(cat ${REPPFILE_JSON_REMOTE} |jq -r '.[]|{name,alias,fetch,pushurl,review,revision} + .| to_entries | map("\(.key)=\(.value)") | join("|")'| sort)

    ## get all <project> from json
    #cat ${REPPFILE_JSON} | jq -cC '.project[] | del(.groups, .remote, .upstream, ."dest-branch", .path) | select(length > 1) | {revision} + .'
    readarray -t items_project < <(cat ${REPPFILE_JSON} | jq -r '.project[]|{revision,groups,remote,upstream,"dest-branch",name,path} + .| to_entries | map("\(.key)=\(.value)") | join("|")'| sort -t'|' -k6,7)


    ## save to array
    local mani_out=()
    printf "takes time at first, creating .repp dir & DB files by analysing manifest\n\n"
    ## read one line from items_project array
    local linein lineout count=0
    local lrev group remote upstream dest_branch project path remote_alias

    ## save to array
    for lines in "${items_project[@]}"; do
        IFS='|' read -ra linein <<< "$lines"
        ##get project info, if null assign default value
               lrev=${linein[0]##*=};        [[ $lrev = null ]] &&        lrev=${line_default[0]##*=}
              group=${linein[1]##*=};       [[ $group = null ]] &&       group=${line_default[1]##*=}
             remote=${linein[2]##*=};      [[ $remote = null ]] &&      remote=${line_default[2]##*=};
                                           [[ $remote = null ]] &&      remote=$(revvserver_item "${REPP_REMOTE##*:}" key)
           upstream=${linein[3]##*=};    [[ $upstream = null ]] &&    upstream=${line_default[3]##*=}
        dest_branch=${linein[4]##*=}; [[ $dest_branch = null ]] && dest_branch=${line_default[4]##*=}
            project=${linein[5]##*=};     [[ $project = null ]] &&     project=${line_default[5]##*=}
               path=${linein[6]##*=};        [[ $path = null ]] &&        path=${line_default[6]##*=}
               path=${path//$'\r'/}; path=${path//$'\n'/}
               #printf "[%s] %s" $((count++)) "${path}"

        ## ì¹¼ëŸ¼ìˆœì„œëŒ€ë¡œ 1:revision, 2:group, 3:remote, 4:upstream, 5:dest_branch, 6:rrev, 7:project, 8:path
        ##process item according to index
        [[ $lrev == "null" ]]    && { err "${lineout}"; return 1; }
        [[ $project == "null" ]] && { err "${lineout} name is null"; return 1; }
        [[ $path == "null" ]]    && { err "${lineout} name is null"; return 1; }

        #KJK_DEBUG [ "$remote" == "v9" ] && { set -x; read -p "KJK_DEBUG"; } || set +x
        #3.remote: aliasë¥¼ ì›ë˜ remoteì´ë¦„ìœ¼ë¡œ ë³€ê²½í•œë‹¤.
        #remote_alias=$(cat ${REPPFILE_JSON_REMOTE} | jq --arg jq_remote "$remote" -r '.[] | select(.alias != null and .name == $jq_remote) | .alias')
        #[ -n "$remote_alias" ] && remote="$remote_alias"

        lineout="${lrev}|${group:-all,default}|${remote}|${upstream}|"
        if [[ $dest_branch == "$upstream" ]]; then
            lineout+="${dest_branch}|${upstream}|"
        else
            [[ $upstream == "null" ]] && lineout+="${dest_branch}|${lrev}|" || lineout+="${dest_branch}|${upstream}|"
            [[ $upstream != "null" ]] && clog "pull/push url is diff" "$(printf "[%-60.60s] %-40.40s %-40.40s" "$project" "$dest_branch" "$upstream")"
        fi
        lineout+="${project}|${path}|"
        mani_out+=("$lineout")
    done

    #laptime
    ## make result output
    #declare -p mani_out
    printf "%s\n" "${mani_out[@]}" >  ${REPPFILE_CSV}.json
    local prnmsg='%s|%12.12s|%8.8s|%-32.32s|%-32.32s|%-32.32s|%-74.74s|%.80s|%s'
    printf "${prnmsg}\n" ${mani_out[*]//|/ } > ${REPPFILE_TXT}


    #### repo forallë¡œ dbë¥¼ ì¼ë‹¨ ìƒì„±í•´ë†“ê³ , ì´ë•Œ jsoníŒŒì¼ì´ ìƒì„±ë˜ì§€ ì•Šì•˜ë‹¤ë©´ repp.csvë¡œ ëŒ€ì²´í•œë‹¤.
    repo forall -j1 -c 'echo "${REPO_LREV}|all,default|${REPO_REMOTE}|${REPO_UPSTREAM}|${REPO_DEST_BRANCH}|${REPO_RREV}|${REPO_PROJECT}|${REPO_PATH}|"' |sort -t'|' -k7,8 > ${REPPFILE_CSV}.repo
    [ -s "${REPPFILE_CSV}.repo" ] || { err "repo is not working, must check"; return 1; }
    if (( "$(reppversion ver 2>/dev/null)" > 220 )) && ! [ -f ${REPPFILE_JSON} ]; then
        warn "you are in mirror repo, temporary ${REPPFILE_CSV} is generated by force, it may show incorrect information"
        cp ${REPPFILE_CSV}.repo ${REPPFILE_CSV};
    fi

    # ëª¨ë“  íŒŒì¼ì„ í•œ ë²ˆì— ë©”ëª¨ë¦¬ë¡œ ë¡œë“œ
    ## í•µì‹¬columeë§Œ ë¹„êµí•˜ê¸° ìœ„í•´ ì¶”ì¶œ
    local matchlinenum_json matchlinenum_repo
    awk -v FS="|" '{print $1"|"$6"|"$7"|"$8}' ${REPPFILE_CSV}.json > ${REPPFILE_CSV}.json.cmp
    awk -v FS="|" '{print $1"|"$6"|"$7"|"$8}' ${REPPFILE_CSV}.repo > ${REPPFILE_CSV}.repo.cmp

    mapfile -t json_cmp_lines < "${REPPFILE_CSV}.json.cmp"
    mapfile -t repo_cmp_lines < "${REPPFILE_CSV}.repo.cmp"
    mapfile -t json_lines < "${REPPFILE_CSV}.json"
    mapfile -t repo_lines < "${REPPFILE_CSV}.repo"

    # json.cmp ë¼ì¸ì„ ì¸ë±ìŠ¤ì— ë§¤í•‘í•˜ëŠ” í•´ì‹œë§µ ìƒì„± (O(1) ê²€ìƒ‰ìš©)
    declare -A json_line_to_idx
    for i in "${!json_cmp_lines[@]}"; do
        json_line_to_idx["${json_cmp_lines[$i]}"]=$i
    done

    # íŒŒì¼ì´ ë‹¤ë¥¸ì§€ í™•ì¸
    if ! diff -q -B "${REPPFILE_CSV}.json.cmp" "${REPPFILE_CSV}.repo.cmp" &>/dev/null; then
        # íŒŒì¼ì´ ë‹¤ë¥¸ ê²½ìš° - ê²°ê³¼ ë°°ì—´ êµ¬ì„±
        result_lines=()
        for i in "${!repo_cmp_lines[@]}"; do
            # iëŠ” ë¼ì¸ë„˜ë²„, !repo_cmp_lines[i]ëŠ” ëª¨ë“  ì›ì†Œì˜ indexê°’ì˜ ë‚˜ì—´
            line="${repo_cmp_lines[$i]}"
            if [[ -v json_line_to_idx["$line"] ]]; then
                # ë¼ì¸ì´ json.cmpì— ì¡´ì¬í•˜ë©´ jsonì—ì„œ í•´ë‹¹ ë¼ì¸ ì‚¬ìš©
                result_lines+=("${json_lines[${json_line_to_idx[$line]}]}")
            else
                # ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ repoì—ì„œ í•´ë‹¹ ë¼ì¸ ì‚¬ìš©
                result_lines+=("${repo_lines[$i]}")
            fi
        done

        # ê²°ê³¼ë¥¼ íŒŒì¼ì— í•œ ë²ˆì— ê¸°ë¡
        printf "%s\n" "${result_lines[@]}" > "${REPPFILE_CSV}"

        bar inline "${REPPFILE_CSV}"
        clog "bad case:content different" "join 'repo' and 'json' info"
        warn "${REPP_PATH}/${REPPFILE_MANI}\n        has mismatch  between 'repo manifest' and 'repo forall' \nand the reason why..."
        echo "1.existing project: new commits are added to existing repository, therefore the revision is changed from manifest"
        echo "2.     new project: new repositories created that not described in manifest, by build time download or manual work"
        wave
        diff -B <(awk -v FS="|" '{print $1"|"$7"|"$8}' ${REPPFILE_CSV}.json) <(awk -v FS="|" '{print $1"|"$7"|"$8}' ${REPPFILE_CSV})
    else
        # íŒŒì¼ì´ ê°™ì€ ê²½ìš°
        cp "${REPPFILE_CSV}.json" "${REPPFILE_CSV}"
        bar inline "${REPPFILE_CSV}"
        clog "good case:exactly same" "generated from manifest and verfied by repo"
    fi

    ##git submoduleì´ ì„¤ì •ë˜ì–´ ìˆëŠ” ê²½ìš°ë¥¼ ìˆ˜ì§‘í•œë‹¤.
    #repo forall -cj4 '[ -s .gitmodules ] && printf "%80s" "${REPO_PATH} $(cat .gitmodules|grep -oP "(?<=path \= ).*")"' > ${REPPFILE_CSV}.submodule
    repo forall -cj16 'printf "%s""$( cat .gitmodules|grep -oP "(?<=path \= ).*" |xargs -I{} echo $REPO_PATH {})"' > ${REPPFILE_CSV}.submodule
    repo forall -cj16 '[ -e .gitattributes ] && [ -n  "$(git check-attr -a *|grep lfs)" ] && echo $REPO_PATH' > ${REPPFILE_CSV}.lfs

    laptime; wave; REPP_INIT=3 #repp DBê¹Œì§€ ì´ˆê¸°í™” ì™„ë£Œ
    return 0
    #cat ${REPPFILE_JSON}|jq -cC '.project[]|{groups,remote,upstream,"dest-branch",revision,name,path}'
    #cat ${REPPFILE_JSON}|jq -jr '.project[]|.groups,"|",.remote,"|",.upstream,"|",."dest-branch","|",.revision,"|",.name,"|",.path,"\n"'
    #cat ${REPPFILE_JSON}|jq -jr '.project[]|.groups," ",.remote," ",.upstream," ",."dest-branch"," ",.revision," ",.name," ",.path,"\n"'
    #cat ${REPPFILE_JSON}|jq -cM '.project[]|{groups,remote,upstream,"dest-branch",revision,name,path}'|tr -d 'repp"'
    #cat ${REPPFILE_JSON} | jq -cC '.project[] | del(.groups, .remote, .upstream, ."dest-branch", .path) | select(length > 1) | {revision} + .'
    #valueë§Œ stringìœ¼ë¡œ
    #cat ${REPPFILE_JSON} | jq -r '.project[] | del(.groups, .remote, .upstream, ."dest-branch", .name, .path) | select(length > 1) | "\(.revision)|\(.[])"'
    #key/valueë¥¼ stringìœ¼ë¡œ
    #cat ${REPPFILE_JSON} | jq -cC '.project[] | {revision,groups,remote,upstream,"dest-branch",name,path} + .| to_entries | map("\(.key)=\(.value)") | join("|")'
}



function reppfind(){
## ---------------------------------------------------------------------------
# find git repository with path and project name with regexp
# $1 path or project
# usage: reppfind [path|project]
    local aparam="$1"               #original input value
    local filter="${2:-.}"
    local cparam="$3"               #original input value
    local cshow="$3"                #select colum from input value
    local allname="REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH"
    local hide="$allname,"
    local aname cindex cname

    #repp find @remote na     @path@project
    #          aparam     filter  cshow
    case $aparam in
           '@rev') cindex=1 aname=REPO_LREV
    ;;   '@group') cindex=2 aname=REPO_GROUP
    ;;  '@remote') cindex=3 aname=REPO_REMOTE
    ;;      '@up') cindex=4 aname=REPO_UPSTREAM
    ;;    '@dest') cindex=5 aname=REPO_DEST_BRANCH
    ;;  '@branch') cindex=6 aname=REPO_RREV
    ;; '@project') cindex=7 aname=REPO_PROJECT
    ;;    '@path') cindex=8 aname=REPO_PATH
    ;;     '@all') cindex=0 aname="$allname"
    ;;         '') cindex=99 #no cindex
    ;;          *) cindex=9;
    esac

    [[ "$cparam" =~ "@rev"     ]] && { cname=REPO_LREV       ;cshow="${cshow//@rev/$cname,}"    ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@group"   ]] && { cname=REPO_GROUP      ;cshow="${cshow//@group/$cname,}"  ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@remote"  ]] && { cname=REPO_REMOTE     ;cshow="${cshow//@remote/$cname,}" ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@up"      ]] && { cname=REPO_UPSTREAM   ;cshow="${cshow//@up/$cname,}"     ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@dest"    ]] && { cname=REPO_DEST_BRANCH;cshow="${cshow//@dest/$cname,}"   ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@branch"  ]] && { cname=REPO_RREV       ;cshow="${cshow//@branch/$cname,}" ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@project" ]] && { cname=REPO_PROJECT    ;cshow="${cshow//@project/$cname,}";hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@path"    ]] && { cname=REPO_PATH       ;cshow="${cshow//@path/$cname,}"   ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@all"     ]] && {                        cshow="$allname"                  ;hide=""                ; }
    [[ "$cparam" =  ""         ]] && {                        cshow="$aname"                    ;hide="${hide/$aname,/}"; }


    [ -f "${REPPFILE_CSV}" ] && info "use generated db, or you can refresh it by 'repp mani init'" || repp_initdb

    case ${aparam} in
        help) cat <<- EOF
		 info) \${REPPFILE_CSV} is saved. can be opened by excel menu [data> text> select file> file open wizard]
		       or can be reformatted by excel menu [data> text to columns> select delimter'|'> finish]
		usage) repp find                                   # show rev,remote,branch,project,path info for all repo
		usage) repp find <string>                          # list info of gits which has string <string> in all git info
		   ex) repp find build                             # list info of gits which has string 'build' in all git info
           ex) repp find .                                 # show info of current git
		   ex) cat \${REPPFILE_CSV}                         # cat output file
		usage) repp find <@key> <string> <@printkey>       # print key colume for all repo
		                 #key: @rev, @group, @remote, @branch, @project, @path, @up, @dest, @all
		usage) repp find @all                              # print all raw columns for all repo
		   ex) repp find @project                          # print project colume for all repo
		   ex) repp find @remote                           # print all remote
		   ex) repp find @remote na                        # print remote which including 'na' string
		   ex) repp find @remote na @path@project@rev      # print path & project & revision with specific remote
		   ex) repp find @group na @group@project          # print group & project with corresponding group
EOF

    ;; @*)        awk -v FS="|" -v vf="$filter" -v vo="$cindex" '$vo ~ vf{print $0}' ${REPPFILE_CSV}|\
                  column '-s|' -t --table-columns "$allname" --table-order "$cshow" --table-hide "$hide"| (sed -u 1q; sort|uniq|pCount)

    #;; @rev)      clog "<REPO_LREV>";    awk -v FS="|" -v vf="$filter" -v vo="$cindex" '$1 ~ vf{printf "[%-40.40s]  %s\n", $1,$vo}' ${REPPFILE_CSV} |pCount
    #;; @branch)                          awk -v FS="|" -v vf="$filter" -v vo="$cindex" '$4$5$6 ~ vf{printf "[%s] %s\n", $4"|"$5"|"$6"|", $vo}' ${REPPFILE_CSV} |sort |uniq |column -s'|' -t --table-columns '<REPO_UPSTREAM>,<REPO_DEST_BRANCH>,<REPO_RREV>'  |pCount -1
    #;; @all)     awk -v FS="|" -v vf="$filter" -v vo="$cindex" '$0 ~ vf{printf "[%s] %s\n"    , $0,"|"$vo}' ${REPPFILE_CSV} |sort |uniq |\
                  #column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH |pCount -1
                  #cat ${REPPFILE_CSV}|column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH |pCount -1
    ;; '')        #summary view by hiding REPO_GROUP,REPO_UPSTREAM,REPO_DEST_BRANCH from all items
                  cat ${REPPFILE_CSV}|colrm 7 40|\
                      column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH \
                      --table-hide REPO_GROUP,REPO_UPSTREAM,REPO_DEST_BRANCH |pCount -1
                  printf "\n\n"
                  info "Above \${REPPFILE_CSV} is generated, all repository info is save: ${REPPFILE_CSV}"
                  clog "\${REPPFILE_CSV}" "this file can opened by excel menu [data> text> select file> file open wizard], or reformatted by [data>text to columns> select delimter'|'> finish]"
                  clog "to see help: " "repp find help"
    ;; \.)        if ! gittcheck_isgitproject; then warn "you need to move the git dir"; return 1; fi
                  clog "current git info from manifest"
                  gitt_initvar; aparam=${GITT_PROJECT}
                  cat ${REPPFILE_CSV}| grep -i ${aparam}|\
                      column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH |\
                      grep --color=always -iE "(^|${aparam})" |pCount -1
                  #repo forall . -c 'echo $REPO_LREV\|$REPO_RREV\|$REPO_UPSTREAM\|$REPO_DEST_BRANCH' 2>/dev/null | column -s'|' -t --table-columns REPO_LREV,REPO_RREV,REPO_UPSTREAM,REPO_DEST_BRANCH
    ;; *)         #local prnmsg='%6.6s|%12.12s|%8.8s|%-32.32s|%-74.74s|%.80s'
                  clog "to find keyword in all item, use 'repp find @all |grep <keyword>' ";
                  #printf "\e[1;33m${prnmsg} \e[0m\n" "REPO_LREV" "REPO_GROUP" "REPO_REMOTE" "REPO_RREV" "REPO_PROJECT" "REPO_PATH"
                  #filter in grep, width in colume, highlight in grep
                  cat ${REPPFILE_CSV}| colrm 7 40| grep -i ${aparam}|\
                      column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH \
                      --table-hide REPO_GROUP,REPO_UPSTREAM,REPO_DEST_BRANCH| grep --color=always -iE "(^|${aparam})" |pCount -1
                  #printf "${prnmsg}\n" $( cat ${REPPFILE_CSV} | grep -i --color=always ${aparam}| sed 's/|/ /g' ) | pCount
    esac

}



function reppbranch(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest output file name
# $2 command
# $3 branch name or branch postfix
    local cmd=$1
    local name=$2

    case ${cmd} in
       ''|help) cat <<- EOF
		 info) gitt branch info                    # show only current git branch info (local, remote branch and commits)

		usage) repp branch list                    # list all remote branches for all gits (it takes times)
		   ex) repp branch list '*release*'        # find *release* matching branches (asterix need to be closed by colon)
		usage) repp branch create                  # show commands can create branch for all, some gits by pre/in/postfix
		usage) repp branch remove                  # show commands can revove branch for all, some gits
		   ex) repp branch create release          # show commands to create 'release' branch
		usage) repp branch checksum                # print local repo checksum and remote tracking branch checksum
		usage) repp branch compare                 # compare which git is diff between local and remote tracking branch
		usage) repp branch compare <remote>        # compare which git is diff among local, remote tracking, a remote branch.
		   ex) repp branch compare mig_230426      # compare between 3 branches (local, remote, mig_230426 branch)
EOF
    ;;  list|find)
                under "please run one of these 'git ls-remote' commands to check if branch is existed in remote\n"
                info "this command show all git project and show if the branch is existed"
                clog "prefix:" "repo forall -pc 'git ls-remote -h \${REPO_REMOTE} refs/heads/\$1_\${REPO_RREV}' ${name:-<branch-prefix>}"
                clog "postfix:" "repo forall -pc 'git ls-remote -h \${REPO_REMOTE} refs/heads/\${REPO_RREV}_\$1' ${name:-<branch-postfix>}"

                bar inline "check exact ${name} remote branche is existed for all gits"
                #showRUNQ y repo forall -c 'printf "%30s| %-70s\n" ${REPO_REMOTE} ${REPO_PROJECT} $(git ls-remote -h ${REPO_REMOTE} refs/heads/$1)' ${name}
                #test case all) repp branch list, repp branch list '*', repp branch list '*mas*',  exact) repp branch list m/master, repp branch list 'm/master'
                set -o noglob
                showRUN repo forall -c 'printf "\t\t >>>> [%10s] ${YELLOW}%-60s${NCOL}\n" ${REPO_REMOTE} ${REPO_PROJECT}; git ls-remote -h ${REPO_REMOTE} refs/heads/${1}' ${name:-*}
                set +o noglob
    ;;  create|new)
                under "please run one of these 'git push' commands to create branch in remote\n"
                info "<branch name> will be passing to 'git push' cmd in position of parameter \${1}"
                info "variable preview: \${REPO_REMOTE}|\${REPO_RREV} $(repo forall . -c 'echo ${REPO_REMOTE}\|${REPO_RREV}' 2> /dev/null)\n"
                clog "infix:" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
                clog "prefix :" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}_\${REPO_RREV}' ${name:-<branch-prefix>}"
                clog "postfix:" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${REPO_RREV}_\${1}' ${name:-<branch-postfix>}"
                echo
                clog "ex) infix only current git" "repo forall . -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
                clog "ex) infix for several gits" "repo forall xxx/yyy ppp/qqq/rrr -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
    ;;  remove|delete)
                under "please run one of these 'git push' commands to delete branch in remote\n"
                info "<branch name> will be passing to 'git push' cmd in position of parameter \${1}\n"
                clog "infix:" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
                clog "prefix :" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${1}_\${REPO_RREV}' ${name:-<branch-prefix>}"
                clog "postfix:" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${REPO_RREV}_\${1}' ${name:-<branch-postfix>}"
                echo
                clog "ex) infix only current git" "repo forall . -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
                clog "ex) infix for several git " "repo forall xxx/yyy ppp/qqq/rrr -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
    ;;  checksum) ##don' use showRUN, md5sum includes showRUN command.
                bar inline "1. md5sum of local HEAD in all repository"
                repo forall -c 'git log -1 --pretty=format:%H%n' | md5sum

                bar inline "2. md5sum of remote all tracking branch in all repository"
                repo forall -c 'git ls-remote -h ${REPO_REMOTE} refs/heads/${REPO_RREV} | cut -f1' |md5sum
                #repo forall -c 'git ls-remote -h ${REPO_REMOTE} refs/heads/$1 | cut -f1' ${name:-${REPP_BRANCH}} |md5sum

                info "you can use 'repp branch compare' to get which git is different"
    ;;  compare)
                bar inline "generate branch info local, remote tracking branch, and specific remote branch"
                #repo forall -pc 'git diff --shortstat tagA tagB'
                fileA=$(mktemp); fileB=$(mktemp)
                repo forall -c 'printf "%s %s %s\n" $(git log -1 --pretty=format:%H%n) ${REPO_RREV} ${REPO_PROJECT}' > ${fileA}
                repo forall -c 'printf "%s %s %s\n" $(git ls-remote -h ${REPO_REMOTE} refs/heads/${REPO_RREV}) ${REPO_PROJECT}' > ${fileB}
                if [ -n "${name}" ]; then
                    fileC=$(mktemp)
                    repo forall -c 'printf "%s %s %s\n" $(git ls-remote -h ${REPO_REMOTE} refs/heads/$1) ${REPO_PROJECT}' ${name} > ${fileC}
                fi

                info "please compare command: vimdiff ${fileA} ${fileB} ${fileC}"
                info "please compare command: icdiff ${fileA} ${fileB} |more -60"
    ;;       *) reppbranch help
    esac
}



function reppinit(){
## ---------------------------------------------------------------------------
# repo init helper
# $1 short repo init command
    ##option handle
    local cmd="$1"

    case $cmd in
       help|'')    cat <<-EOF
			 usage) repp init -u <manifest-url> -b <manifest-branch> -m <manifest-name> -p <platform> -c
			                  --reference=<mirror-path> --depth=<depth> --repo-url=<repo-url>
			                  --no-clone-bundle --partial-clone --no-tags --mirror
				ex) repp init -u ssh://${USER}@vgit.lge.com:29440/honda/linux/manifest -b tsu_25.5my_release
				ex) repp init -u https://android.googlesource.com/platform/manifest -b android-12.1.0_r1
				ex) repp init -b lampauto_r_release -m all.xml
				ex) repp init -u ssh://lamp.lge.com:29418/platform/manifest.git -b lampauto_r_release --git-lfs
				     -m lampauto/lampauto-gm-recent.xml --reference=/data001/vc.integrator/mirror/lampauto_r_release/
				     --repo-url=ssh://lamp.lge.com:29418/repo/git-repo.git
                ex) repp init -u ssh://lamp.lge.com:29418/platform/manifest.git -b lampauto_r_release --dissociate
                ex) repp init -u ssh://${USER}@vgit.lge.com:29440/honda/linux/manifest -b tsu_25.5my_release --partial-clone --clone-filter=blob:none

EOF
            info 'please refer http://collab.lge.com/main/x/xYv4j'
            return 1
       ;; *) :
    esac


    #### parameter parsing
    local url revision manifest platform reference depth repo_url extra ret=0
    if ! options=$(getopt -l reference:,depth:,repo-url:,no-clone-bundle,partial-clone,no-tags,mirror -o b:m:p:u: -- "$@")
    then err 'please check "repo init --help"'; return 1; fi

    ##reset legacy positional parameter except $options
    eval set -- "$options"
    ##parse parameter from options using shift, which shifts the $1, $2, ... value sequencely
    while true; do
        $DEBUG [$1][$2]
        case $1 in
            ##when option has sub option, should shift 2 or just shift
            -u|--manifest-url)                                          url=$2;         shift 2;;
            -b|--manifest-branch)                                       revision=$2;    shift 2;;
            -m|--manifest-name)                                         manifest=$2;    shift 2;;
            -p|--platform)                                              platform=$2;    shift 2;;
            --reference)                                                reference=$2;   shift 2;;
            --depth)                                                    depth=$2;       shift 2;;
            --repo-url)                                                 repo_url=$2;    shift 2;;
            ##single option that need no additional sub value
            ##skip single option and remove getopt cmd
            -c|--current-branch)                                  extra="${extra} $1";  shift 1;;
            --no-clone-bundle|--partial-clone|--no-tags|--mirror) extra="${extra} $1";  shift 1;;
            --|*)                                                                  shift; break;;
        esac
    done

    #### parameter check
    ##if url has lamp and url is null, default url is lamp or return
    local sep='~'
    case ${url}$sep${revision} in
         $sep*lamp*) url="ssh://lamp.lge.com:29418/platform/manifest.git" ;;
         $sep*) err "-u manifest-url is necessary" ;;
         *$sep*) : ;;
    esac
    ##if reference dir is existed, set reference as default.
    if [ -z "${reference}" ];then reference="${reference:-${PATH_MIRROR}/${revision}}"; [ ! -d "${reference}" ] && reference=''; fi
    ##issue https://github.com/OP-TEE/manifest/issues/157
    if [ -z "${repo_url}" ] && [ "${url}" != "${url/lamp/}" ];then repo_url='ssh://lamp.lge.com:29418/repo/git-repo.git'; fi

    #### run repo command
    ##url handle with replication server
    local file_info=$(mktemp)
    cmd_repoinit="repo init ${url:+-u ${url}} ${revision:+-b ${revision}} ${manifest:+-m ${manifest}} ${platform:+-p ${platform}} ${reference:+--reference=${reference}} ${depth:+--depth=${depth}} ${repo_url:+--repo-url=${repo_url}} ${extra} $@"

    ##make final repo init cmd
    bar outline "executed command:" >> ${file_info}
    printf "${cmd_repoinit}\n" >> ${file_info}

    ##execute cmd
    reppcheck_initcmd ${cmd_repoinit}
    if [ "$?" -eq 1 ]; then ret=1; fi

    ##show repo info
    bar outline >> ${file_info}
    cat ${file_info}; rm -f ${file_info}

    ##go next step or not
    if [ "$ret" -eq 0 ]; then info "to repo sync?:[enter:continue| ctrl+c:break] "; reppsync;
    else err "'repp connect help' or 'repp init help'"; fi
}



function reppsync(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
# ex) reppsync
    local cmd=$1
    local opts="${@:2}"
    local preopt njobs

    case $cmd in
        help) cat <<- EOF
			usage) repp sync                # sync with default option
			usage) repp sync debug          # for debugging with --trace
			usage) repp sync <option>       # default option) --no-tags --no-clone-bundle --fail-fast
			   ex) repp sync --force-sync   # go current git root dir
			   ex) gitt go build            # show git path including 'build' and move to select
EOF
        ;; debug)   info "you can use permission check with 'repp connect' command"
                    preopt="--trace" ; njobs=1
        # -[[:digit:]] ) ##same to '*[0-9])'
        #           njobs=${cmd}
        #    -*)    opts="${cmd} ${opts}"
        ;;    *)
                    clog "-m" "event/branch_migration.xml  # use input manifest.xml (to check if manifest work before commit) "
                    clog "-d" "                            # back to manifest revision"
                    clog "-f" "                            # force sync with overwriting"
                    clog "--jobs-network=" "8              # count of network thread [default 1], 8 recommand"
                    clog "--jobs-checkout=" "8             # count of checkout thread [default 8], 24 recommand"
                    clog "--auto-gc" "                     # with garbage collection [default no]"
                    info "default cmd: repo sync --no-tags --no-clone-bundle --fail-fast -cj8"

                    read -p  $'\n\nPlease add option to repo sync [enter:auto| opts:-qcj4| ctrl+c:exit]: ' opts;
                    if [ -z $opts ]; then njobs=${NJOBS}; fi
    esac

    showRUN repo ${preopt} sync --no-tags --no-clone-bundle --fail-fast -cj${njobs:-8} ${opts}

    #"$@" 2> >(tee -a ${file_error})
    "$@" > >(tee -a ${file_error})
    case $? in
     0) ;;
     1) echo Generic error, usually because invalid command line options or malformed configuration;;
     2) echo Connection failed;;
     *) echo Unknown Error;;
    esac
}



function reppreset(){
## ---------------------------------------------------------------------------
# reset git repositories
# $1 target

    local cmd=$1
    case ${cmd} in
            help)   cat <<-EOF
				usage) repp reset          # reset all repository to original revision
				usage) repp reset check    # show reset result (details: repp show)
				usage) repp reset project  # remove legacy 'repo sync' info to 'repo sync' again.

				 info) gitt reset          # provide detail control for one repository
EOF
        ;;   '')    info "repp reset help : for more usage\n"
                    ## git reset --hard;   #reset to local lastest commit status.
                    ## git clean -xdf      #remove uncommitted change
                    showRUNQ y repo forall -cj${NJOBS} 'git reset --hard FETCH_HEAD; git clean -xdf'

                    #showRUN repo sync -dlvj${NJOBS} --force-remove-dirty
                    info "\nfinish reset all repositories, and reset FETCH_HEAD"
        ;;project)  info "you can repo sync without conflicting legacy objects"
                    showRUNQ y echo "
                    ${REPP_ROOT}/.repo/project.list
                    ${REPP_ROOT}/.repo/project-objects/
                    ${REPP_ROOT}/.repo/projects/"
                    rm  -rf ${REPP_ROOT}/.repo/project.list \
                    ${REPP_ROOT}/.repo/project-objects/ \
                    ${REPP_ROOT}/.repo/projects/
        ;;check|*)  showRUN repo status -vj${NJOBS}
                    info "\n\n reset to manifest revision and check if uncommited change existed"
    esac
}



function reppvertoggle(){
## ---------------------------------------------------------------------------
local repo_executor=${proFILEdir}/bin/_repo
local repo_launcher_backup=${REPP_PATH%/*}/__repo
local repo_launcher=${REPP_PATH%/*}/repo

## update repo newest
if [ -d "${repo_executor}" ];
then
    git -C ${proFILEdir}/bin/_repo pull
else
    git clone https://gerrit.googlesource.com/git-repo -b stable ${repo_executor}
fi

## back or restore
if [ -d "${repo_launcher_backup}" ];
then ## restore
    [ -L "${repo_launcher}" ] && rm -f ${repo_launcher} || ( err "cannot restore, plz check"; return 1 )
    mv ${repo_launcher_backup} ${repo_launcher}

    ## restore PATH
    [[ -v PATH_OLD ]] && PATH=${PATH_OLD}

else ## backup & change
    mv ${repo_launcher} ${repo_launcher_backup}
    ln -s ${repo_executor} ${repo_launcher}

    ## add path for priority
    ## if variable is not defined, backup PATH, ban re-enterd
    [[ -v PATH_OLD ]] || PATH_OLD=$PATH
    PATH=${repo_launcher}:$PATH
fi
}



function reppversion(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local file_log=$(mktemp)
    python3 $(which repo) --version > ${file_log}

    local VER cmd="$1"
    case $cmd in
             help) cat <<-EOF
			usage) repp version toggle         # change repo version newest & restore
			usage) repp version ver            # show only repp version number exactly
			usage) repp version                # show repo, git, python version
EOF
        ;; toggle) reppvertoggle; return 0
    esac

    ## only 3digit length version code is valid to compare old version
    VER=$(cat ${file_log} | grep "repo version"  |tr -dc '[:digit:]')
    [ -z $VER ] && { VER=$(repo --version | grep 'launcher version' |tr -dc '[:digit:]'); }
    if [ "$cmd" == "ver" ]; then echo ${VER:0:3} && return 0; fi

    #if VER is not integer, in case of error
    [[ ${VER} != ?(-)+([0-9]) ]] && VER=000

    [ -d "${REPP_PATH%/*}/__repo" ] && warn "you are using toggled version"
    echo "this version is expected to used, please check this version is matched to your local version"

    bar inline "expected"
    info "warning: this is the repo packaged with this project."
    $REPP_PATH/../repo/repo version

    printf "\n\n"
    bar inline "found"
    info "the local version currently you are using"
    bar inline "what"
    cat ${file_log}

    echo
    py_path=$(which python) >/dev/null
    py_ver="$(python --version 2>&1)"
    printf "[check] %s is working in [%s]\n" "${py_ver}" "${py_path}"

    bar inline "where"
    which repo
    which git

    if (( ${VER:0:3} < 230 )); then
        under "you need to upgrade 'repo' to use full functionality\n"
        clog "1. remove old .repo:" rm -rf ${REPP_ROOT}/.repo
        clog "2. download to dir:" git clone https://gerrit.googlesource.com/git-repo ${PATH_MIRROR}/repo2 --mirror
        clog "3. repo init with below command:" --repo-url=[${REPP_REPOURL}] --\> [${PATH_MIRROR}/repo2]
        pushd ${REPP_PATH} ; reppget_repcmd info ; popd
        clog "-->"
        echo "${REPP_CMD/${REPP_REPOURL}/${PATH_MIRROR}/repo2}"
        #| sed -e 's#--repo-url=${REPP_REPOURL}#--repo-url=${PATH_MIRROR}/repo2'
    fi
}



function reppcheck_initcmd(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
    local file_error=$(mktemp)
    local ret=1 #return 1 is success, 0 is fail
    echo "\$ $@"
    time "$@" 2> >(tee -a ${file_error})
    #"$@" | tee -a ${file_error}


    case $(cat ${file_error}) in
        help)                           echo "init error handler"
    ;; *fatal*|*fail*|*error*)          err "check error log [${file_error}]"
    ;; *Permission?denied*publickey*)   err "check error permission"
    ;; *)                               ret=0
    esac

    [ "$ret" -eq 1 ] && echo "check http://collab.lge.com/main/pages/viewpage.action?pageId=1620608725"
    return $ret
}


#ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject}
function reppssh_server(){
## ---------------------------------------------------------------------------
# check if server can access code-review server by SSH protocol
# SSH protocol is used in local server to get source from code-review sever
    local server=$1
    local port=$2
    local user=$3
    local passwd=$4
    local cmd=${@:5}


    under "ssh access [${server}] port [${port}]  ${user})"
    clog cmd "${cmd}"
    ret=$(sshpass -p "${passwd}" ssh -q ${user}@${server} -p ${port} bash <<SSH_COMMAND
    ${cmd}
SSH_COMMAND
)
}



function reppcheck_server(){
## ---------------------------------------------------------------------------
# check if server can access code-review server by SSH protocol
# SSH protocol is used in local server to get source from code-review sever
    local server=$1
    local user=$2
    local port=$3
    local gitproject=$4
    local branch=$5
    local ret
    local file_error="$(mktemp)"

    #local port=$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')
    bar inline "step2.1-ssh: check local if ssh is installed (checked by $ACCOUNT)"
    clog try "install proper version of ssh"
    if [ -x "$(command -v ssh)" ]; then  log "ssh is installed in [$(which ssh)]"; else err "ssh is not installed, plz install it"; fi

    if [ -z $oriserver ]; then reppconnect help && return 1;fi
    bar inline "step2.2-tcp: check remote if tcp port is well listened (checked by $ACCOUNT)"
    clog try "check port num is correct? firewall is active? internet is on?"
    showRUN timeout 5 bash -c "</dev/tcp/${server}/$port"
    if [ $? == 0 ];then echo "server $server over port $port is listened";
    else echo "server $server over port $port is not listened, please contact server manager"; fi

    bar inline "step2.3-sshd: check remote if ${user} can access ${server} on ${port}port (checked by ${user})"
    clog try "check port num is correct? check account and ssh-key is matched and registered?"
    #echo "ssh -T $user@$server -p $port -vvv 2> $file_error"
    : '
    echo \n| ssh -T $user@$server -p $port -vvv 2> $file_error

    case $(cat ${file_error}) in
        help)       echo "ssh connection error msg handler"
    ;; *success*)   echo "good, SSHD is active on port [$port] in server [$server], you can connect"
    ;; *Connection?refused*)
                    err "check log in ${file_error}"
                    grep -En "*Connection refused*" $file_error
                    err "check IP/PORT setting in (.ssh/config) with below"
                    ping $server -c2
                    return 1
    ;; *publickey*) err check publickey
                    read -p "go or stop? [enter:continue | ctrl+c:stop]"
    ;; *)           err "unknown error is occured, please check log [${file_error}]"
                    return 1
    esac
    '
    bar inline "step2.4-project: check remote if ${user} can access git project (checked by ${user})"
    clog try "check git name path is correct and can access"
    ret=$(ssh -q ${user}@10.158.7.50 -p 22 bash <<SSH_COMMAND
    ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject}
SSH_COMMAND
)
    [ -n "$ret" ] &&  echo "gitproject existed and accessed [${gitproject}]" || err "check git project is existed or permission allowed [${gitproject}]"

    bar inline "step2.5-branch: check remote if ${user} can access the branch on the project (checked by ${user})"
    clog try "check branch name path is correct and can access"
    #ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject} -b ${branch}
    ret=$(ssh -q ${user}@10.158.7.50 -p 22 bash <<SSH_COMMAND
    set -x
    ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject} -b ${branch}
SSH_COMMAND
)
    [ -n "$ret" ] &&  echo "branch existed and accessed [${branch}]" || err "check git branch is existed or permission allowed [${branch}]"

    under "you can check 'READ' accessibility for all branch & repository (wait 30s) (checked by ${user})\n"
    read -p "check accessibility for all repository  [enter:continue| ctrl+c:exit]: "

    ssh -q ${user}@10.158.7.50 -p 22 bash <<'SSH_COMMAND'
    mkdir -p ~/repo.test && cd ~/repo.test
    repo init -u ssh://vgit.lge.com:29440/honda/linux/manifest -b tsu_25.5my_release 2> /dev/null
    repo sync -qcj8 --no-tags --no-clone-bundle --fail-fast 2> /dev/null
    repo forall -qc bash -c '
    GERRIT=( "vgit_na:29420" "vgit_eu:29430" "vgit_as:29440" "vgit_adas:29550" "vgit_devops_test:29999" "lamp_review:29418" )
    for _item in ${GERRIT[@]};do
        if [ ${_item%:*} = "${REPO_REMOTE}" ]; then
            [ -z "$(ssh $REPO__${USER}@$0 -p ${_item#*:} gerrit ls-projects --prefix ${REPO_PROJECT} -b ${REPO_RREV} --limit 1)" ] && printf "[ERROR] project:%-50s path:%s" "${REPO_PROJECT}" "${REPO_PATH}"
        fi
    done
    ' vgit.lge.com  2> /dev/null
SSH_COMMAND
#$(revvserver_item ${oriserver} subdomain) #vgit.lge.com
#repo forall -c 'echo \${REPO_REMOTE}:\${REPO_PROJECT}:\${REPO_PATH}:\${REPO_LREV}:\${REPO_RREV}' > ~/repo.test/repo.result
        #[ ${_item%:*} = "${REPO_REMOTE}" ] && printf "[%-60.50s] " "${REPO_I}/${REPO_COUNT}/${REPO_PROJECT}" && ssh $REPO__${USER}@$0 -p ${_item#*:} gerrit ls-projects --prefix ${REPO_PROJECT} -b ${REPO_RREV} --limit 1
}



function reppconnect(){
## ---------------------------------------------------------------------------
# check connection and report error
# $1 server
# $2 port
# $3 password
    reppcheck_initvar reppgittrevv

    local cmd="$1"
    case ${cmd} in
       help)    cat <<-EOF
			  usage) repp connect [server]  [user]          [gitproject]   [branch]
			 -----------------------------------------------------------------
			default) repp connect ${REPP_REMOTE} $ACCOUNT   ${REPP_PROJECT}    ${REPP_BRANCH}
			     ex) repp connect na        testaccount     tiger/tools  tiger_release
			     ex) repp connect na        joongkeun.kim   tiger/tools  tiger_release
			     ex) repp connect na        testaccount     tiger/tools
			     ex) repp connect na        testaccount
			     ex) repp connect na        testaccount
			     ex) repp connect
EOF
                return 1;
    ;;     *) :
    esac

    local user oriserver server gitproject branch port
    local temp_p=$(expr "${REPP_URL}" : ".*[0-9]/\(.*\)\..*")
    [ -z "$4" ] && info "use default branch: ${GITT_BRANCH:-${REPP_BRANCH}}"        ;branch=${4:-${GITT_BRANCH:-${REPP_BRANCH}}} ;
    [ -z "$3" ] && info "use default git project: ${GITT_PROJECT:-${REPP_PROJECT}}" ;gitproject=${3:-${GITT_PROJECT:-${REPP_PROJECT}}} ;
    [ -z "$2" ] && info "use default account: $USER"                                ;user=${2:-$USER} ;
    [ -z "$1" ] && info "use default server: ${GITT_REMOTE:-${REPP_REMOTE}}"        ;oriserver=${1:-${GITT_REMOTE:-${REPP_REMOTE}}} ;
    server=$( revvserver_item ${oriserver} subdomain ); port=$(revvserver_item ${oriserver} port)

    clog "should be this format:ex)" "[testaccount][$oriserver][$server][$gitproject][$branch]"
    dnlog [$user] [$server] [$oriserver] [$gitproject] [$branch]

    under "step1: check gerrit permission for ${user} from WEB(HTTP) by account admin[${ACCOUNT}]\n"
    showRUN revvcheck_server ${oriserver} log                                              ;wave
    showRUN revvcheck_account ${oriserver} ${user} log                                     ;wave
    showRUN revvcheck_permission ${oriserver} ${user} ${gitproject} ${branch} read         ;wave

    under "step2: check git permission for ${user} from SERVER(SSH) user[${user}]\n"
    showRUN reppcheck_server ${server} ${user} ${port} ${gitproject} ${branch}
    #showRUN reppcheck_server ${buildserver} ${port} ${user} ${repo init cmd}
}



function reppfind_repodir(){
## ---------------------------------------------------------------------------
# find input-path up and down,
# $1:path name, $2:max depth to sub dir, $3:print or not
# ex) reppfind_repodir .repo 5
# ex) reppfind_repodir .git 2
    local T=$PWD
    local target=${1:-.repo}
    local down_depth=${2:-2} #default value:2

    ## find in sub directory with depth
    readarray -t REPP_PATH_ALL < <(find . -maxdepth ${down_depth} -path "*${target}" |sort)
    case ${#REPP_PATH_ALL[@]} in
    1)  ## found one in sub dir
        REPP_PATH=$(readlink -f ${REPP_PATH_ALL[0]})
        ;;
    0)  ## not found, so find in parent directory upto $HOME
        while [[ "${PWD}" =~ "${HOME}" ]]; do
            if [ -d ${target} ]; then break; fi
            pushd ..
        done
        if [ -d ${target} ]; then REPP_PATH=$(readlink -f ${target});else REPP_PATH='';fi
        pushd -0 && dirs -c
        cd $T
        ;;
    *)  ## found multiple dir in sub dir
        under "found repo in subdir [count: ${#REPP_PATH_ALL[@]}]\n"
        printf "%s\n" "${REPP_PATH_ALL[@]// /\n}"
        REPP_PATH=''
        ;;
    esac
}



function repp_initvar(){
## ---------------------------------------------------------------------------
# find input-path up and down,

    ## move to repo root
    reppfind_repodir .repo/manifests 5
    ## set variable REPP if manifest dir exists
    if [ ! -d "${REPP_PATH}" ];then $DEBUG ${REPP_PATH_ALL[@]}; $DEBUG "you are not in repo project, please check !"; return 1;fi
    REPP_ROOT=${REPP_PATH%/.repo*}
    ## ì´ë¯¸ ì´ˆê¸°í™”ëœ dirì¸ì§€ íŒë‹¨.
    if [ ! -f "${REPP_ROOT}/.repo/project.list" ] || [ ! -d "${REPP_ROOT}/.repo/projects" ] || [ ! -d "${REPP_ROOT}/.repo/project-objects" ];
    then  err "repo sync is need, please check" ; return 1
    else  REPP_INIT=1 #repo syncê¹Œì§€ ì™„ë£Œ
    fi

    (( "${REPP_INIT}" > 1 ))  && [ -d "${REPP_PATH}" ] && [[ "${REPP_PATH}" =~ "${REPP_ROOT}" ]] && return 0


    pushd ${REPP_PATH}
    REPP_DIR=${REPP_ROOT}/.repp
    [ -f ${REPP_ROOT} ] || mkdir -p ${REPP_DIR}

    ##ì „ì²´ filelist
    REPPFILE_STATUS=${REPP_DIR}/repp.status             #í˜„ì¬ repoì˜ ë³€ê²½ íŒŒì¼ì´ë¦„ê³¼ ìƒíƒœ(status)ë¥¼ ì €ì¥
    REPPFILE_COMMIT=${REPP_DIR}/repp.commit             #í˜„ì¬ repoì˜ ë³€ê²½ íŒŒì¼ì´ë¦„ê³¼ ë‚´ìš©(commit)ì„ ì €ì¥
    REPPFILE_XML=repp.xml                               #repp maniì—ì„œ ì „ì²´ manifestë¥¼ í•˜ë‚˜ì˜ manifest íŒŒì¼ë¡œ ìƒì„±ì‹œ ê²°ê³¼íŒŒì¼
    REPPFILE_JSON=${REPP_DIR}/repp.json                 #repo manifestë¡œë¶€í„° ìƒì„±ëœ repo json íŒŒì¼
    REPPFILE_JSON_REMOTE=${REPP_DIR}/repp_remote.json   #repp.jsonì—ì„œ remoteì •ë³´ë§Œ ì¶”ì¶œí•œ íŒŒì¼, /tmp/ì— ì„ì‹œì €ì¥ë¨
    REPPFILE_TXT=${REPP_DIR}/repp.txt                   #ìœ„ jsonì„ parsingí•œ ê²°ê³¼ë¥¼ formatted txtë¡œ ì €ì¥í•œ íŒŒì¼, êµ¬ë¶„ì(|)
    REPPFILE_CSV=${REPP_DIR}/repp.csv                   #ìœ„ json íŒŒì¼ê³¼ repo forallì„ ë¹„êµí•˜ì—¬ ìµœì¢… ìƒì„±ëœ íŒŒì¼ DB, êµ¬ë¶„ì(|)ë¡œ excelë¡œ ì½ì„ë•ŒëŠ” ë³€í™˜í•„ìš”.
                                                        #repp.csví•­ëª©ì€ repo forall listì™€ ë™ì¼í•˜ë©°, ì„¸ë¶€ gitì •ë³´ë§Œ ë” í¬í•¨ë˜ì–´ ìˆë‹¤.
    #repp.csv.json                                      #manifest jsonì„ parsiní•˜ì—¬ ìƒì„±ëœ DB
    #repp.csv.repo                                      #repo forallë¡œë¶€í„° ìƒì„±ëœ DB, jsoníŒŒì¼ë¡œ ìƒì„±ì´ ì–´ë ¤ìš¸ë•Œ ìµœì¢…ì‚¬ìš©í•˜ê²Œ ëœë‹¤.
    #repp.csv.lfs                                       #repp.csví•­ëª©ì¤‘ì— git lfsë¡œ êµ¬ì„±ëœ git list
    #repp.csv.dup                                       #repp.csví•­ëª©ì¤‘ì— gitì´ 2ê°œì´ìƒì¸ git list
    #repp.csv.submodule                                 #repp.csví•­ëª©ì´ ì†Œìœ í•œ git submodule list
    REPPFILE_FORALL=${REPP_DIR}/reppforall.csv          #repp forall ì‘ì—…ì„ ì§„í–‰í•˜ê¸° ìœ„í•œ script. repp forall genë¡œ ìƒì„±ë¨. êµ¬ë¶„ì(,)
    REPPFILE_SCRIPT=${REPP_DIR}/reppscript              #repp forallì—ì„œ ì‚¬ìš©í•˜ëŠ” scriptë¥¼ ì €ì¥í•˜ëŠ” íŒŒì¼ë“¤ì´ë‹¤. in.tm.pre.postë“±ì´ ì¡´ì¬í•œë‹¤.
    REPPSCRIPT_IN=${REPPFILE_SCRIPT}.in.sh              #repp forall -c <cmd> ë¶€ë¶„ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ ì„ì‹œ script
    REPPSCRIPT_OUT=${REPPFILE_SCRIPT}.out.sh            #pre + in + post = outìœ¼ë¡œ ìµœì¢… ì‹¤í–‰ë˜ëŠ” script

    #reppforall.csv.tmp                                 #reppforall.csvë¥¼ ì‹¤ì œ ì‹¤í–‰í• ë•Œ êµ¬ë¶„ì(`)ë¡œ ë³€ê²½í•˜ì—¬ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ì¤‘ê°„íŒŒì¼


    #REPP_PROJECT=$(git remote -v |grep fetch | sed -E 's#.*[0-9]+(.*).git.*$#\1#')
    #REPP_PROJECT=$(git config --get-regexp remote.*.url  |head -1|cut -d' ' -f2)
    REPP_PROJECT=$(git config --get-regexp remote.* |grep -Ee "(projectname|url)" |head -1|grep -Po '\w/\K.\w+[^?]+')
    REPP_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null| sed 's:.*/::')  #GITT_BRANCH
    REPP_REVIEW=$(git config --get-regexp remote.*.review|cut -d' ' -f2|head -1)        #GITT_REVIEW
    REPP_URL=$(git config --get-regexp remote.$(git remote|head -1).url|cut -d' ' -f2|head -1) #GITT_URL

    #REPP_REMOTE=$(revvserver_item $(git remote -v |grep fetch | grep -oP '(?<=:)[0-9]+(?=/)') remote)
    if [[ -z $REPP_REMOTE ]]; then
        REPP_REMOTE=$(cat ${REPPFILE_JSON} 2>/dev/null |jq -r '.default.remote')
        if [[ -z "${REPP_REMOTE}" ]] || [[ "${REPP_REMOTE}" == "null" ]] ; then
            reppget_repcmd
            local tmp=$(git config --get-regexp ^remote.*.url | sed 's/.*:\([0-9]*\).*/\1/')
            REPP_REMOTE=$(grep '<remote ' ${REPPFILE_MANI} | sed -n 's/.*name="\([^"]*\)".*/\1/p')
        fi
    fi
    if [[ -z "${REPP_REMOTE}" ]] || [[ "${REPP_REMOTE}" == "null" ]] ; then warn "REPP_REMOTE is null, must check"; fi

    #REPP_URL=$(git remote -v |grep fetch |awk '{print $2}')
    #REPP_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}| sed 's:.*/::')
    REPP_REPOURL=$(cat ../repo/.git/config |grep url|sed 's/.*= \(.*\)/\1/')
    #REPP_REF=$(cat ../manifests.git/config |grep reference|sed 's/.*= \(.*\)/\1/')
    REPP_REF=$(git config --get-regexp repo.reference |head -1|cut -d' ' -f2)
    REPP_MIRR=$(git config --get-regexp mirror |head -1|cut -d' ' -f2)
    REPP_GROUPS=$(git config --get-regexp manifest.groups |head -1|cut -d' ' -f2)
    REPP_COUNT=$($REPP_PATH/../repo/repo list |wc -l)

    REPP_REMOTELIST=( $(repo manifest 2>/dev/null |grep review | sed -E 's#.*name="([^"]*[^"]*)".*#\1#') )
    REPP_REVIEWLIST=( $(repo manifest 2>/dev/null |grep review | sed -E 's#.*review="([^"]*[^"]*)".*#\1#') )
    REPP_INIT=2 #repp script ì ìš©ì™„ë£Œ
    popd

    return 0
}



function gitt_initvar(){
## ---------------------------------------------------------------------------
# find input-path up and down,

    local temp
    if ! gittcheck_isgitproject; then
        GITT_REMOTE=; GITT_PROJECT=; GITT_BRANCH=; GITT_PATH=; GITT_URL=; GITT_REVIEW=;
        return 1
    fi

    ##readarray -t GITT_REMOTE < <(git remote -v |cut -f1|uniq)
    GITT_REMOTE=$(git remote|head -1)

    #git config --get-regexp remote.$GITT_REMOTE |sort|grep -Ee "(projectname|url)"
    #git config --get-regexp remote.*.projectname|cut -d' ' -f2
    temp=$(git config --get-regexp remote.* |grep -e "projectname" |head -1|cut -f2 -d' ')
    if [ -n "${GITT_PROJECT}" ] && [ "${temp}" = "${GITT_PROJECT}" ]; then return 0; else GITT_PROJECT=${temp}; fi
    if [ -z "${GITT_PROJECT}" ]; then GITT_PROJECT=$(git config --get-regexp remote.* |grep -Ee "(url)" |head -1| sed -E 's#.*://[^/]+/(.*)#\1#'); fi

    #NEEDTO WORK: find more secure way to get current branch revision
    GITT_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null| sed 's:.*/::')
    [ -z "${GITT_BRANCH}" ] && GITT_BRANCH=$(git branch -ar |grep -e '->' |sed -E 's#.*[/|>](.*)$#\1#')
    [ -z "${GITT_BRANCH}" ] && GITT_BRANCH=$(git branch -ar |grep -e 'm/' |sed -E 's#.*[/|>](.*)$#\1#')
    [ -z "${GITT_BRANCH}" ] && warn "'repo start <workingbranch> --all' is recommended"
    [ -z "${GITT_BRANCH}" ] && ( err "check your branch with 'git branch'
    repo start <working branch> --all       # make working branch
    source repp                             # reload repp script"
    )

    GITT_URL=$(git config --get-regexp remote.${GITT_REMOTE}.url|cut -d' ' -f2|head -1)
    GITT_REVIEW=$(git config --get-regexp remote.*.review|cut -d' ' -f2|head -1)
    GITT_REVIEW=${GITT_REVIEW:="${GITT_URL/${GITT_PROJECT}/}"}
    GITT_PATH=$(git rev-parse --show-toplevel)
    return 0
}



function revv_initvar(){
## ---------------------------------------------------------------------------
# find repo, gitt, review variable
    local ret=0
    local key_id key
    #default initial gerrit API key is na (vgit_na).


    #key_id=$(revvserver_item ${GITT_REMOTE:-${REPP_REMOTE:?"run 'repp_initvar' first"}} key)
    key=$(revvserver_item ${GITT_REMOTE:?'ERROR: check server info!!'} pass)

    if (( 40 > ${#key} )); then
        warn "if problem continue, check gerrit http key value in [~/.key_server] \n
        you can generate file [.key_server] : cmd[revvserver gen] and add access key"
        ret=1
    fi

    # if ! revvcheck_server ; then
    #     err "please check correct account&key is saved using revv server "
    #     ret=1
    # fi

    return $ret
}


function reppcheck_initvar(){
## ---------------------------------------------------------------------------
# find repo, gitt, review variable

    local cmd=$1
    local besttry=false
    if  [ "${cmd:0:1}" = "O" ]; then besttry=true ; fi
    ## --------------------------------------------------------
    if [[ "${cmd}" =~ "repp" ]]; then
        if ! repp_initvar ;then #repo projectê°€ ì•„ë‹ë•Œ
            if ! "$besttry" ; then warn "repo is not initialized well, please check" && return 1;fi
        else
            [[ "${cmd}" =~ "mani" ]] || repp_initdb
        fi
    fi
    ## --------------------------------------------------------
    if [[ "${cmd}" =~ "gitt" ]]; then
        if ! gitt_initvar ; then
            [[ ! "${cmd}" =~ "go" ]] && { warn "you are not in git project" && return 1; }
        fi
    fi
    ## --------------------------------------------------------
    if [[ "${cmd}" =~ "revv" ]]; then
        if ! revv_initvar ; then warn "you don't have a permission, please check" && return 1;  fi
    fi
    return 0
}



function gittsshcmd(){
## ---------------------------------------------------------------------------
# find replication server
# $1 server-url
# $2 port-number
    local server_port=${REPP_URL#*@}
    local server=${1:-${server_port%:*}}
    local user=${2:-${USER}}
    local port=${3:-$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')}

    case $cmd in
       help) cat <<- EOF
				usage) gitt sshcmd checkserver                         # show current branch info
				usage) gitt branch delete|remove <name>         # delete branch with exact-name, with confirm 'y'
				   ex) gitt branch create my_temp_branch        # create my_temp_branch, with confirm 'y'
				 info) gitt diff                                # see gitt diff to compare branch
EOF

    ;; checkserver)
        if [ -z "${server}" ] || [ -z "${port}" ] ; then info "usage) revv server status vgit.lge.com 29999"; return 1;fi
        ping $server -s 1016 -c 4 -A
        printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
        if [ $? -ne 0 ]; then continue; fi
        ssh ${user}@$server -p $port -o ConnectTimeout=2 -o ConnectionAttempts=1 gerrit show-caches
        if [ $? -ne 0 ]; then continue;fi
        printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
        echo "please check 1) ipg/ewma from ping, 2) AvgGet from gerrit connection"

    ;; *) gittbranch help
    ;; esac

}




shortname_of_branch() {
    local input="$1"
    # branch nameì—ì„œ ë’¤ì—ì„œë¶€í„° _ê°€ 2ë²ˆ ë‚˜ì˜¬ë•Œê¹Œì§€ ì‚­ì œí•˜ê³  prefixë§Œ ì·¨í•´ì„œ ê²€ìƒ‰
    local out="${input%_*_*}";
    if [ ${#out} -gt 12 ] || [ ${#out} -le 6 ]; then echo "${input:0:10}" ; else echo "$out"; fi
}


function gittinfo(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# TODO: clone command
    local TEMP THEAD
    local review_gerrit=admin/repos

    ## git path
    bar inline "git path"
    clog 'current git path:' "${GITT_PATH}"

    ## git remote info
    ## "error: must check" must be checked!!!
    bar inline "show all remote info"
    clog ' remote:' ${GITT_REMOTE:="error: must check"}                        #remote name
    clog 'project:' ${GITT_PROJECT:="not defined"}                             #project name
    clog ' branch:' ${GITT_BRANCH:="error: must check"}                        #branch name
    clog ' review:' ${GITT_REVIEW:="not defined"}                              #git review site
    clog '    url:' ${GITT_URL:="error: must check"}                           #git review url

    ##review system check
    case $(git config --get-regexp remote|cut -d' ' -f2) in
      help)             echo "site customization"
    ;;*github.com*)     GIT_SITE=$(printf "https://%s" ${GITT_URL}|sed -E 's#^.*github.com:(.*.git)$#http://github.com/\1#')
    ;;*vgit.lge.com:*)
        case ${GITT_URL} in #remove starting string 'vgit.lge.com:29420/'
           *vgit.lge.com:29420*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'na' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29430*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'eu' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29440*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'as' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29550*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'adas' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29999*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'devops_test' ${review_gerrit}/${GITT_URL##*9/} )
        ;;                    *) GIT_SITE="please add site custom setting" ;;
        esac
    ;;''|*)             GIT_SITE=$(printf "%s/${review_gerrit}/%s" "$(echo ${GITT_REVIEW}|sed -E 's#(.*)[/]$#\1#')" ${GITT_PROJECT} )
    ;;esac
    clog "source repository url :" ${GIT_SITE}                                     #http review url
    clog "review commit url     :" $(echo "$GIT_SITE" |sed -E "s#http:(.*)admin/repos/(.*)#https:\1q/project:\2+branch:"${GITT_BRANCH}"#")
    clog "source browser gitiles:" ${GIT_SITE/"${review_gerrit}"/"plugins/gitiles"}/+/refs/heads/${GITT_BRANCH}                #source from gitiles
    clog "source browser gerrit :" ${GIT_SITE/"${review_gerrit}/"/"gitweb?p="}.git\;a=shortlog\;h=refs/heads/${GITT_BRANCH}    #source from gerrit

    ## git clone & push command
    bar inline "git clone & push commands"
    clog " git clone:" "git clone ${GITT_URL} -b ${GITT_BRANCH}"               #make git clone command
    TEMP=$(printf "git push $GITT_REMOTE HEAD:refs/heads/%s" ${GITT_BRANCH})
    clog " git push review:" ${TEMP/\/heads/\/for}                             #make git push command for
    clog " git push direct:" $TEMP                                             #make git push command head

    ## git recent local command
    bar inline "recent local commit info"                                      #extract last commit info with only 1000 character
    git --no-pager show --stat --color=always --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset %C(blue)<%an>%Creset  %<(1000,trunc)' HEAD

    # if ! diff -qB <(git rev-parse FETCH_HEAD) <(git rev-parse HEAD); then       #current head is changed
    THEAD=$(git log -1 --pretty=format:%H%n)
    if ! git ls-remote -h ${GITT_REMOTE}| grep "$THEAD";then
        warn "git changed: local and remote is differ"
        git --no-pager log --color=always --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset %C(blue)<%an>%Creset' --abbrev-commit --date=relative HEAD.."$THEAD"
    fi

    ## git submodule & lfs
    pushd "${GITT_PATH:?"You are not in git project"}"
    bar inline "git submodule & git lfs"
    ## sub module ì •ë³´ê°€ ìˆìœ¼ë©´ ì¶œë ¥
    if [ -f .gitmodules ]; then info "$( cat .gitmodules|grep -oP "(?<=path \= ).*" |xargs -I{} bash -c '[ -e {}/.git ] && echo "this git HAS active git-submodule: [{}]" || echo "this git has not active git-submodule: [{}]"' )"; fi
    if [ ! -f .gitmodules ] && [ -n "$(awk -v VAR=${GITT_PATH} 'VAR~$2{print $2}' ${REPPFILE_CSV}.submodule 2>/dev/null)" ]; then info "this git IS git-submodule: [${GITT_PATH/$REPP_ROOT/}]"; fi
    ## lfs ì •ë³´ê°€ ìˆìœ¼ë©´ ì¶œë ¥
    if [ -f "${REPPFILE_CSV}.lfs" ] && [ -n "$(grep ${GITT_PATH/$REPP_ROOT\//} ${REPPFILE_CSV}.lfs)" ]; then info "this git HAS git-lfs file"; git lfs ls-files; fi
    popd

    ## git last sync time
    bar inline "last synced time"                                              #extract sync time
    oldIFS=${IFS}; IFS='';
    if [ -f ${GITT_PATH}/.git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y ${GITT_PATH}/.git/FETCH_HEAD );
    else clog "last manifest-synced date(check date of files below):" "\n$(ls -lct ${GITT_PATH}/.git| tail -1)";fi
    IFS=${oldIFS}

    bar inline "show branchout list from current branch within 4 months (botton is newest)"
    remote_commits=$(git ls-remote -h ${GITT_REMOTE} refs/heads/$(shortname_of_branch ${GITT_BRANCH})*)

    # ìµœê·¼ 4ê°œì›”ê°„ commitì¤‘ì—ì„œ branch-outëœ ë¸Œëœì¹˜ë¥¼ ëª¨ë‘ listupí•˜ê¸°ìœ„í•´, í•´ë‹¹ commitì— ë§ëŠ” branchë¥¼ ì¶œë ¥í•œë‹¤.
    local tmp
    git log --since="4 months ago" --pretty=format:'%H %ci <%an> %s' --reverse | while read -r sha; do
        tmp=${sha:67} #author ì‹œì‘ë˜ëŠ” column
        printf "$remote_commits" | grep --color=never "${sha%% *}" && printf "%2s ${green}%s ${magenta}%s> ${blue}%s${NCOL}\n" "" "${sha:41:25}" "${tmp%%>*}" "${tmp#*>}"
    done
}



function gittshow(){
## ---------------------------------------------------------------------------
# show commit history by git log, or show commit by git show
# $1: "number of commit" or "commit sha1"
    #topic/working branch
    local depth="${1:-15}"

    if [[ ${#depth} -gt 3 ]] && [[ ${depth} =~ ^[0-9a-f]+$ ]]; then
        bar outline "call native git"
        git show  --pretty=fuller --stat ${depth}
        return 0
    fi

    bar outline "gitt show is based on command: git log "
    bar inline "git commit history with option (to see all branche, gitt show 15 --all)"
    showRUN git log --decorate --graph -n${depth} --pretty=format:'%Cred%h -%C(yellow)%s %Cgreen(%ci) %C(blue)<%an>%Creset'

    bar inline "git commit history with diff file list"
    echo "filter: --since(=after), --before(=until)"
    echo "date  : 6 hour, 2-day, 2-week, 1-month, 1-year"
    clog "ex:" "--since=2-weeks, --since=04:24, --before=6-hours, --after=2022-11-10 --before=2022-11-20-23\n"
    read -p "input add option [default:--pretty="short" --name-only with your input option] "

    bar inline "file name only (press 'q' to stop)"
    #git log --color=always --pretty="short" --name-only ${reply} --pretty=format:'%Cred%h -%C(yellow)%s %Cgreen(%ci) %C(blue)<%an>%Creset' |more -60
    git log --color=always --pretty="short" --name-only ${reply} --pretty=format:'%Cred%H %Cgreen(%ci) %n%C(yellow)%s %C(blue)<%an>%Creset'

    clog "to see only modified file & contents, not add/delete files:" "git log -p --color=always --pretty=oneline --diff-filter=M ${reply}"
}



function formatprint(){
## ---------------------------------------------------------------------------

    local cmd=$*
    local index=0 line;

    #cmd preprocessor
    case ${cmd} in
                 help) echo "pre-process cmd"
    ;;   *git?status*) under "file changes list\n"
    ;;              *) echo "not found"
    esac

    readarray -t resultline < <( ${cmd[*]} )
    #resultline=("${cmd[*]}" "${resultline[@]}")
    #declare -p resultline

    ##read one line from array "${resultline[@]}"
    ##for line in "${resultline[@]}"; do while read item; do
    printf "%14s | %-14s -- \t%s\n" "indexed area" "working tree" "filelist"
    echo ${linemi}
    for line in "${resultline[@]}"; do
        #echo "KJK:[${line:0:1}][${line:1:1}]"
            ##custom handler for each item.
            case ${line:0:1} in
                 help)   :
            ;;    '#')   bar inline "file changes in branch: ${line}"
            ;;    '?')   printf "%14s | " "new"
            ;;    '!')   printf "%14s | " "new"
            ;;    ' ')   printf "%14s | " ""
            ;;    'A')   printf "%14s | " "added"
            ;;    'M')   printf "%14s | " "modified"
            ;;    'D')   printf "%14s | " "deleted"
            ;;    'T')   printf "%14s | " "type changed"
            ;;    'R')   printf "%14s | " "renamed"
            ;;    'C')   printf "%14s | " "copied"
            ;;    'U')   printf "%14s | " "unmerged"
            ;;      *)   clog "must classfied"  "${line}"
            esac
            case ${line:1:1} in
                 help)   :
            ;;    '?')   printf "%-14s -- \t%s\n" "untracked" "${line:3}"
            ;;    '!')   printf "%-14s -- \t%s\n" "ignored" "${line:3}"
            ;;    ' ')   printf "%-14s -- \t%s\n" "tracked" "${line:3}"
            ;;    'A')   printf "%-14s -- \t%s\n" "added" "${line:3}"
            ;;    'M')   printf "%-14s -- \t%s\n" "modified" "${line:3}"
            ;;    'D')   printf "%-14s -- \t%s\n" "deleted" "${line:3}"
            ;;    'T')   printf "%-14s -- \t%s\n" "type changed" "${line:3}"
            ;;    'R')   printf "%-14s -- \t%s\n" "renamed" "${line:3}"
            ;;    'C')   printf "%-14s -- \t%s\n" "copied" "${line:3}"
            ;;    'U')   printf "%-14s -- \t%s\n" "unmerged" "${line:3}"
            esac
            #printf "%${width}s\n" "${item}"
            #index=$(( ++index % ${#cmd[@]} ))
    ##done <<< "${line}"; done
    done
}



function gittcommit(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: number of commit
# $2: other option such as --all (all branch)
    local cmd="$1"
    local opt="${@:2}"
    case $cmd in
       auto)    msg=$(date +"%y%m%d:%H%M")
                git commit -m "${msg}: ${opt:-test}"
                git show --stat --oneline HEAD
                clog "[run]" "git push $GITT_REMOTE HEAD:refs/heads/${GITT_BRANCH}"
    ;; reset)   gittreset help
    ;; info)    formatprint git status -s --porcelain
                printf "\n\n"
                read -p "to see diff with cached in detail [ enter:compare| line:compare with line | q(ctrl+c):break ]: "
                case "$REPLY" in
                    help) clog "you can use with options:" "git diffi --line-numbers"
                ;;  line) git difftool --extcmd 'icdiff --line-numbers'
                ;;  *) git difftool --extcmd 'icdiff'
                esac
                if [ $? -ne 0 ];then echo "need to install 'sudo apt-get install icdiff'"; fi
    ;; help|*)    cat <<-EOF
				usage) gitt commit info         # show commit info and diff with cached
				usage) gitt commit auto         # add auto commit
				   ex) gitt commit auto misc    # add auto commit with msg 'misc'
				usage) gitt commit reset        # show useful reset command

				 info) gitt diff                # diff advanced with HEAD, HEAD^, staged, unstaged, revision
				 info) gitt info                # overall info for current git
				 info) gitt branch info         # branch info
EOF
    esac
}



function gittbranch_info(){
## ---------------------------------------------------------------------------
# show branch local & remote
# $1 all or filter

    ## local branch
    #list option must be wrapped with quoat ex) --list '*relese*'
    bar inline "info: branch local"
    clog "[local]" "* marked is current branch"
    showRUN git branch -vv

    ## remote branch
    bar inline "info: branch remote"
    clog "[remote]" "tracking branch"
    echo ${GITT_BRANCH}

    ## remote branch which are same to local HEAD
    bar inline "find remote branch which are at same local HEAD"
    clog "[always latest]" "read from remote live"
    git ls-remote -h ${GITT_REMOTE}| grep $(git log -1 --pretty=format:%H%n)
    if [ $? -eq 0 ]; then warn "local branch is same to remote branch";
    else warn "there is no remote branches same to current HEAD pointing, please below log"; fi

    local tmp=$(shortname_of_branch ${GITT_BRANCH})
    bar inline "git log the related branches(${tmp}), tag info omitted (last 4 months)"
    git log --color=always --graph --decorate --pretty=format:'%Cred%h%Creset %s %Cgreen(%cr)%Creset %C(red)%d%Creset' --since="4 months ago" \
        $(git for-each-ref --format='%(refname:short)' refs/heads/ | grep ${tmp}) |sed -E 's/tag:[^,]*,? ?/|/g'
    echo
    info "if you want to see omitted TAG infomation (${red}|${NCOL}) use 'git loga'"
}



function gittbranch_list(){
## -------------------- -------------------------------------------------------
# show branch local & remote
# $1 all or filter
    local opt=$1
    local filter

    read -p "'git fetch' is needed to get recent branch details [enter:continue| ctrl+c:break] :"
    git fetch --all
    bar inline "remote tag] recent 20 by date (bottom is newest create tag)"
    echo "get all branches and sort by date recent its tag"
    showRUNQ "git for-each-ref --color=always --sort=creatordate refs/tags \
    --format='%(color:yellow)%(committerdate:short) %(color:red)%(objectname:short) %(color:green)%(refname:short) %(color:blue)%(authorname)%(color:reset) %(contents:subject)' | tail -20"


    bar inline "remote branch] recent 20 by date (bottom is newest commit added)"
    showRUNQ "git for-each-ref --color=always --sort=committerdate refs/remotes \
    --format='%(color:yellow)%(committerdate:short) %(color:red)%(objectname:short) %(color:green)%(refname:short) %(color:blue)%(authorname)%(color:reset) %(contents:subject)' | tail -20"


    # echo "branch: remote all with filter (${filter:-all}) in remote repository"
    # set -o noglob
    # [ -z "${opt}" ] && filter="" || filter="--list *${opt}*"
    # set +o noglob

    # bar inline "lookup remote branch ${filer}"

    # clog "[always latest]" "read from remote live"
    # showRUN git ls-remote -h ${GITT_REMOTE} refs/heads/${opt} | more -60

    under "find: sort by recently updated branches by new commit findkey: ${opt:-'*'} (bottom is newest commit added)\n"
    # echo "shows the branches downloaded when git fetch equivalent command was executed"
    # clog "run 'git pull'" "to fetch all latest remote branches"
    #set -o noglob
    #[ -z "${opt}" ] && filter="" || filter="--list *${opt}*"
    #showRUN git branch -rvv --sort=committerdate ${filter} | more -60
    #set +o noglob
    showRUNQ git branch -rvv --sort=committerdate --list ${opt} | tail -60
}


function gittbranch(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 command
# $2 branch name or branch postfix
    local cmd=$1
    local name=$2
    local target=$3

    case $cmd in
       help) cat <<- EOF
				usage) gitt branch info                         # show current branch info
				usage) gitt branch list <''|name-filter>        # show remote recent 20 tag/branches
				   ex) gitt branch list *my*                    # find branches including 'my'
				usage) gitt branch create|new empty             # show guide to create empty branch
				usage) gitt branch create|new <name>            # create new branch with exact-name, with confirm
				usage) gitt branch delete|remove <name>         # delete branch with exact-name, with confirm 'y'
				   ex) gitt branch create my_temp_branch        # create my_temp_branch, with confirm 'y'
				usage) gitt branch diff <branchA> <branchB>     # compare commit history between 2 branches
				 info) gitt diff                                # see gitt diff to compare branch by snapshot not history
EOF
    ;; create|new)  if [ -z "${name}" ]; then err "branch name must be input" && return 1;fi
                if [[ "${target}" =~ 'empty' ]]; then
                    info "to create branch with empty commit"
                    echo "git switch --orphan <new-branch-name> #switch to new empty branch"
                    echo "git commit --allow-empty -m 'Initial commit to create branch' #add empty commit"
                    echo "git push ssh://vgit.lge.com:29440/honda/con/autosar HEAD:refs/heads/<branch-name>"
                fi

                bar inline "create branch: new branch will be created from current HEAD"
                showRUNQ y git push ${GITT_REMOTE} HEAD:refs/heads/${name}

    ;; delete|remove)  if [ -z "${name}" ]; then err "branch name must be input" && return 1;fi
                bar inline "delete branch: branch [${name}] will be removed from REMOTE"
                showRUNQ y git push ${GITT_REMOTE} --delete ${name}
    ;; info)    gittbranch_info
    ;; list)    #test case all) gitt branch list, gitt branch list '*', gitt branch list '*mas*',  exact) gitt branch list m/master, gitt branch list 'm/master'
                #gittbranch_list \'"${name:-*}"\'
                set -o noglob
                gittbranch_list "${name:-*}"
                set +o noglob
    ;; diff)    if [ -z "${name}" ]; then err "branch name must be input, if you don't know use 'gitt branch list'" && return 1;fi
                local tempvar=$(git branch -rvv --sort=committerdate --list ${name} |sed 's/^[[:space:]]*//'| cut -d' ' -f1)
                [ "$name" = "$tempvar" ] || { warn "branch name is wrong";  bar inline "must be input as the following"; git branch -rvv --sort=committerdate --list *${name}* *${target}*; return 0; }
                bar inline "show tree between [${name}] [${target}]"
                git fetch --all
                local base=$(git merge-base "${name}" "${target}") || { git fetch --all; }
                git log --color=always --graph --decorate=short --oneline --boundary ${base}.. "${name}" "${target}" \
                    --pretty=format:'%C(yellow)%h -%C(reset)%s %Cgreen(%ci) %C(red)%d%Creset' |sed -E 's/tag:[^,]*,? ?//g'

                under  "\n\n> [${target} only commits]\n"
                showRUN git log --shortstat --decorate=no --pretty=format:'%C(yellow)%h -%C(reset)%s %C(blue)<%an>%Creset' ${name}..${target}

                under  "< [${name} only commits]\n"
                showRUN git log --shortstat --decorate=no --pretty=format:'%C(yellow)%h -%C(reset)%s %C(blue)<%an>%Creset' ${target}..${name}


    ;; *) gittbranch help
    ;; esac
}



function gittfind(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: regexp or string
# $2: file, dir and area
    local keyword="$1"
    local area="${@:2}"

    case $keyword in
    ''|help) cat <<- EOF
				usage) gitt find '<string>'                     #find <string> in committer, message, code-diff
				                                                #please brace string with single quoat('~~~')
				   ex) gitt find 'docker' dock                  #find string 'docker' in file 'dock'
EOF
             return 0;
    ;; *)   bar outline "search in commit with regexp(${keyword}) in files(${area:-file list or path})"
    esac

    source <(cat <<'EOL'
    under "find string(${keyword}) in committer in history(${area:-all})\n"
    echo "ex) git log --author=".*${keyword}.*" ${area}"
    echo "ex) git log --owner=".*${keyword}.*" ${area}"
    checkifSHA ${keyword} &&  git log -1 ${keyword}
    showRUN git log --committer=".*${keyword}.*" ${area}


    under "find string(${keyword}) in commit message of history (${area:-all}) with file-changes\n"
    showRUN git log -i --name-status -F --grep="${keyword}" ${area}

    under "find string(${keyword}) in commit diff in file history(${area:-all}) \n"
    echo "ex) git grep -e regexp1 --or -e regexp2"
    echo "ex) git grep -e regexp1 --and -e regexp2"
    showRUN git grep -n "${keyword}" ${area}

    under "find function(${keyword}) in file history(${area:-all}) \n"
    read -p "[enter:continue| ctrl+c:break]"
    showRUN git log -L :${keyword}:${area}
EOL
)

    ## show commit diff including keyword
    #git log -p -S"${keyword}" ${area}

    ## find string in function
    #under "find string in :fuction:file\n"
    #showRUN git log -L :"${keyword}":"${area}"
    ##run echo

}



function gittdiff(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 command
# $2 branch name or branch postfix
    local cmd="$1"
    local path="$2"
    local rev1="$3"
    local rev2="$4"

    local cmd_diff="git difftool"

    if command -v icdiff > /dev/null ; then cmd_diff="git difftool --extcmd icdiff";fi
    if [ -z "${path}" ]; then path=.;fi

    case $cmd in
    help) cat <<- EOF
				 info) if default <path> is omitted, . (current dir) will be used
				usage) gitt diff work <path>                        #  staged >>> diff <<< unstaged(workspace)
				usage) gitt diff staged <path>                      #    HEAD >>> diff <<< staged
				usage) gitt diff HEAD <path>                        #    HEAD >>> diff <<< unstaged & staged(add empty path)
				usage) gitt diff HEAD^ <path>                       #    HEAD >>> diff <<< HEAD^

				usage) gitt diff branch <path> <branchA> <branchB>  #branch A >>> diff <<< branch B, <path> is mandatory
				   ex) gitt diff branch . vgit_na/tsu_26my_release vgit_na/tcua_release
				       if this not working, please put 'current local branch name' as parameter

				usage) gitt diff commit <path> <commitA> <commitB>  #commit A >>> diff <<< commit B, <path> is ignored
				   ex) gitt diff commit . HEAD^ 03c2df

				flow) gitt branch list                              # find remote branch name : origin/master
				      gitt fetch                                    # get all branch for comparing
				      gitt diff branch . HEAD origin/master         # compare current branch to origin/master
				      gitt diff branch . default origin/master      # compare default branch to origin/master
EOF
    ;;  work)   under "      staged >>> diff <<< unstaged\n"
                showRUNQ ${cmd_diff} -- ${path} |more -60
    ;;staged)   under "        HEAD >>> diff <<< staged\n"
                showRUNQ ${cmd_diff} --cached -- ${path} |more -60
    ;;HEAD|head)     under "        HEAD >>> diff <<< unstaged/staged\n"
                warn "automatically 'git add empty path' to show diff untracked new file"
                git add -N . #to compare new untracked file
                showRUNQ  ${cmd_diff} HEAD -- ${path} |more -60
    ;;HEAD^|head^)   under "        HEAD >>> diff <<< HEAD^ \n"
                #= showRUN ${cmd_diff} @ @^ ${path}
                showRUNQ ${cmd_diff} HEAD HEAD^ ${path} |more -60
    ;;branch)   under "    branch A >>> diff <<< branch B \n"
                warn "to see remote branch, run 'gitt branch list'"
                showRUNQ ${cmd_diff} ${rev1} ${rev2} ${path} |more -60
    ;;commit)   under "    commit A >>> diff <<< commit B \n"
                showRUNQ ${cmd_diff} ${rev1}..${rev2} |more -60
    ;;  file)   under "    current >>> diff <<< current-1 \n"
                showRUNQ ${cmd_diff} @:${path} @^:${path} |more -60
    ;;  *|'')   gittdiff help
    ;; esac
}



function gittreset(){
## ---------------------------------------------------------------------------
# reset git repositories
# $1 target

    local cmd=$1
    case ${cmd} in
        clear)   showRUNQ y "git reset --hard @{upstream} && git clean -xdf"

    ;; help|*)   cat <<-EOF
				usage) gitt reset clear #remove all changes and reset with comfirm 'y'
				usage) gitt reset       #show detail reset commands below, run manully.

				info) git reset flow
				1) git log: check reset point in repository
				2) git reset <rev> <option>
				   current : workspace index repository | description
				   -----------------------------------------------------------------------------------------------------
				    --soft : workspace index <<<<       | keep commit & file, could retry from 'git push'
				    --mixed: workspace <<<<             | keep only  file, could retry from 'git add' (default)
				    --hard : <<<<                       | remove all, need to retry from scratch
				3) retry from each step
				flow) git log> git reset c3cef36787        > add modification> git add -A> git commit        > git push
				flow) git log> git reset c3cef36787 --soft > add modification> git add -A> git commit --amend> git push
				info) 'git reset --hard' restored by this 'git reflog > git reset --hard <relog rev>'
EOF
    esac
}



## revv ======================================================================================================================


JSON_IDFY=")]}'"
function revvcheck_server(){
## ---------------------------------------------------------------------------
# check gerrit is permitted for input user on git project > branch
# usage) revvcheck_server na log
# $1: target review system
# $2: log flag

    local server=$1
    local flag=$2

    [ "$REVV_TAG" = "$server" ] && return 0
    local key=$(revvserver_item ${server}  pass)
    local user=$(revvserver_item ${server} user)

    if [ -z "${server}" ];
    then port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)'); server=$(revvserver_item ${port} http)
    else port=$(revvserver_item ${server} port); server=$(revvserver_item ${server} http);
    fi
    #$DEBUG ["$server"]["$port"]

    ## gerrit apiì— accessê°€ ê°€ëŠ¥í•œì§€ë¥¼ gerrit versionì„ ì œëŒ€ë¡œ returní•˜ëŠ”ì§€ ì—¬ë¶€ë¡œ íŒë‹¨í•œë‹¤.
    [ "${flag}" = "log" ] && info "curl -su ${user}:${key} ${server}/a/config/server/version |sed '1d'| jq -cC '.'"
    REVV_VER=$(curl -su ${user}:${key} ${server}/a/config/server/version |sed '1d'| jq -cC '.')
    if ! [[ "${REVV_VER}" =~ [2-9].[0-9].[0-9]* ]]; then REVV_VER='NA'; err "gerrit is not working, please check"; return 1; fi

    if [ "${flag}" = "log" ]; then
        bar inline "step1.1-gerritserver: [remote] check if gerrit server is active (checked by $user)"
        clog try "check gerrit service is online from web"
        echo "ok. gerrit is working ${REVV_VER}"
    fi
    return 0
}



function revvcheck_account(){
## ---------------------------------------------------------------------------
# check gerrit is permitted for input user on git project > branch
# usage) revvcheck_account na joongkeun.kim log
# $1: target review system
# $2: target user
# $3: log flag


    local server=$1
    local user=$2
    local flag=$3
    local key_id=$(revvserver_item ${server} sub)
    local key=$(revvserver_item ${key_id} pass)
    local ret=()

    #local port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)')
    if [ -z "${server}" ];
    then port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)'); server=$(revvserver_item ${port} http)
    else port=$(revvserver_item ${server} port); server=$(revvserver_item ${server} http);
    fi

    readarray -d',' -t ret < <(curl -su ${ACCOUNT}:${key} ${server}/a/accounts/?suggest\&q=${user}|sed '1d'| jq -c '.[]|{_account_id,username,name,email}'|sed  's/[{}"]//g')
    ! [[ "${ret[*]}" =~ "${user}" ]] && err "there is no account [${user}] in gerrit" && return 1

    ##get username & accountID from gerrit
    REVV_USERID="${ret[0]#*:}"
    REVV_USER="${ret[1]#*:}"

    if [ "${flag}" = "log" ]; then
        bar inline "step1.2-gerritserver: [remote] check if ${user} can access gerrit (checked by $ACCOUNT)"
        clog try "check current account is in gerrit system"
        echo "ok. gerrit account existed: ${ret[@]}"
        #declare -p ret
    fi
    return 0
}



function revvcheck_permission(){
## ---------------------------------------------------------------------------
# check gerrit is permitted for input user on git project > branch
# usage)  revvcheck_permission as joongkeun.kim honda/con/autosar tsu_26my_release create
# $1: target user
# $2: target review system
# $3: gitproject
# $4: branch
# $5: permission(https://gerrit-review.googlesource.com/Documentation/access-control.html#access_categories)
#     Abandon,Create(Create Reference),Delete(Delete Reference),Forge Author, Forge Committer,Forge Server,Owner,Push,Direct Push
#     Push Merge Commits,Create Annotated Tag,Read,Rebase,Revert,Submit,Submit (On Behalf Of),Edit Hashtags,Edit Topic Name
#

    local server=$1
    local user=$2
    local oriproject=$3 ;
    local gitproject=${oriproject//'/'/'%2F'}
    local branch=$4
    local perm=$5
    local flag=$6
    local key_id=$(revvserver_item ${server} sub)
    local key=$(revvserver_item ${key_id} pass)
    local log ret

    revvcheck_account ${server} ${user}

    #local port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)')
    if [ -z "${server}" ];
    then port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)'); server=$(revvserver_item ${port} http)
    else port=$(revvserver_item ${server} port); server=$(revvserver_item ${server} http);
    fi
    if [ -z "${oriproject}" ];then info "guide) repp connect help" && return 1;fi

    ##[ "${oriproject}" = "${REPP_PROJECT}" ] && server=origin #change remote name for manifest git to origin
    #curl -su vc.integrator:'F3ZYZofW1J~~~' http://vgit.lge.com/as/a/projects/honda%2Flinux%2Fbuild_tsu/check.access?account=7986\&ref=refs%2fheads%2fmaster\&perm=read
    bar inline "step1.3-gerritserver: [remote] check if ${user} can access git project (checked by $ACCOUNT)"
    clog try "check git name path is correct and can access"
    log=$(curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject}/check.access?account=${REVV_USERID})
    ret=$(echo "${log}" |sed '1d'| jq -c '.')
    ! [[ "${ret#*:}" =~ 200 ]] && err "check gerrit project error: ${log}" && return 1
    echo "ok. gerrit account[${REVV_USER}] can access by[read]: ${oriproject}"
    echo ${linemi}

    bar inline "step1.4-gerritserver: [remote] check if ${user} can access branch on the project (checked by $ACCOUNT)"
    clog try "check git/branch is correct and can access it [case sensitive]"
    dnlog "commit" "read,submit,push,pushMerge,revert,forgeCommitter,forgeAuthor,editTopicName,label-Code-Review"
    dnlog "branchtag" "create,delete,createTag,createSignedTag"
    dnlog "server" "priority,streamEvents,administrateServer"
    [ -z "${branch}" ] && branch="master"
    [ -z "${perm}" ] && perm="read"
    log=$(set -x; curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject}/check.access?account=${REVV_USERID}\&ref=refs%2fheads%2f${branch}\&perm=${perm})
    readarray -d $'\n' -t ret < <(echo "${log}" |sed '1d'| jq -rM '.message,.status')
    ! [[ "${ret[1]}" =~ 200 ]] && { err "check gerrit project error: ${log}"; return 1;}
    ##get username & accountID from gerrit
    echo "ok. gerrit branch[${branch}] existed and can accessed with[${perm}] permission by[${REVV_USER}]"

    return 0
}


function test_revvserver_item() {
## ---------------------------------------------------------------------------
## check all format is well printed
## print remote (gerrit server) info for all supported format
## awk print 2nd line to last-1 line
#revvserver show |awk -F '|' 'NR>1{print $1}'
    local cmd=$1
    for _item in $(revvserver show |awk -F '|' 'NR>2 {print last} {last=$1}');do
        if [ "$cmd" = info ]||[ "$cmd" = check ]; then revvcheck_server $_item log; fi

        if [ "$cmd" = info ]; then
        for _test in http port sub domain subdomain path url remote debug;do
            bbar cyan "${_item##*/}:$_test"  "$(revvserver_item "${_item##*/}" "$_test")\n"
        done
        fi
    done
}



function revvconnect(){
## ---------------------------------------------------------------------------
# check connection and report error
# $1 server
# $2 port
# $3 password
    local cmd="$1"
    case ${cmd} in
       help)    cat <<-EOF
			  usage) revv connect [server]  [user]          [gitproject]   [branch]
			 -----------------------------------------------------------------
			default) revv connect ${REPP_REMOTE} $ACCOUNT   ${REPP_PROJECT}    ${REPP_BRANCH}
			     ex) revv connect na        testaccount     tiger/tools  tiger_release
			     ex) revv connect na        joongkeun.kim   tiger/tools  tiger_release
			     ex) revv connect na        testaccount     tiger/tools
			     ex) revv connect na        testaccount
			     ex) revv connect na        testaccount
			     ex) revv connect
EOF
                return 1;
    ;;     *) :
    esac

    local user oriserver gitproject branch port
    local temp_p=$(expr "${REPP_URL}" : ".*[0-9]/\(.*\)\..*")
    [ -z "$4" ] && info "use default branch: ${GITT_BRANCH}"        ;branch=${4:-${GITT_BRANCH}} ;
    [ -z "$3" ] && info "use default git project: ${GITT_PROJECT}"  ;gitproject=${3:-${GITT_PROJECT}} ;
    [ -z "$2" ] && info "use default account: $USER"                ;user=${2:-$USER} ;
    [ -z "$1" ] && info "use default server: ${GITT_REMOTE}"        ;oriserver=${1:-${GITT_REMOTE}} ;
    port=$(revvserver_item ${oriserver} port)

    #clog "should be this format:ex)" "[testaccount][$oriserver][$gitproject][$branch]"
    bbar PURPLE "[$user] in" "\nchecked under [$oriserver] [$gitproject] [$branch]\n\n"

    under "step1: check gerrit permission for ${user} from WEB(HTTP) by account admin[${ACCOUNT}]\n"
    showRUN revvcheck_server ${oriserver} log                                              ;wave
    showRUN revvcheck_account ${oriserver} ${user} log                                     ;wave
    showRUN revvcheck_permission ${oriserver} ${user} ${gitproject} ${branch} read         ;wave
}



function revvinfo(){
## ---------------------------------------------------------------------------
# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch

    local cmd=${1:-info}
    #local branch=$4

    case ${cmd} in
       help)    cat <<-EOF
				usage) revv info                                   #show gerrit POST command
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) clog "test" "test api"
    ;; esac
}



function revvaccount(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account (from 'revv account')
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    if [ "$subcmd" != help ] ; then
        local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
        local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
        local key=$(revvserver_item $sub pass)
        local user=$(revvserver_item $sub user)
    fi
    local source=${3:-$USER}
    local target=$4
    local extra=$5
    local file=$(mktemp)
    local out


    #local branch=$4
    [ -z "$user" ] && user=$ACCOUNT
    local SEP='~'
    case ${cmd}${SEP}${subcmd} in
           *~help)
            echo "check your cmd [${cmd}]"; cat <<-EOF
			usage) revv user      na joongkeun.kim                             # check account is existed and its groups
			   ex) revv user      na joon                                      # check all accounts named joon
			   ex) revv user      na 7602             none none                # for api, get user info only
			usage) revv sshkey    na joongkeun.kim                             # get registered SSH-KEY
			usage) revv group     na sa515m_developer                          # check group existance and list sub-groups & all members
			   ex) revv group     na sa515m_                                   # find groups has *'sa515m_'*
			   ex) revv group     na 16d578384091ad1~ none none                # for api, get group info only
			usage) revv groupadd  na sa515m_developer joongkeun.kim            # add member to group
			usage) revv groupdel  na sa515m_reviewer  joongkeun.kim            # delete member from group
			usage) revv groupmem  na sa515m_reviewer  joongkeun.kim            # check member is in group and its sub-groups
EOF
    ;;      user~*)
            [ "$extra" != "none" ] && bar inline "check if account is existed & get account info "
            curl -su ${user}:${key} ${server}/a/accounts/?suggest\&q=${source} |sed '1d'|jq -cC .[]|pCount

            [ "$(cat /tmp/pCount)" -ne 1 ] && return 0

            if [ "$extra" != "none" ]; then
                bar inline "list group name which account belongs to"
                curl -su ${user}:${key} ${server}/a/accounts/${source}/groups |sed '1d'| jq -cC '.[]|{name, created_on}' | more -60
            fi

    ;;    sshkey~*)
            info "config: " "${server}/na/settings/#SSHKeys"
            bar outline "get registered SSH-key for account [${source}] in server [$server]"
            #curl -su ${user}:${key} ${server}/a/accounts/${source}/sshkeys |sed '1d'| jq -cC '.[]|{ssh_public_key, comment}'
            out=$(curl -su ${user}:${key} ${server}/a/accounts/${source}/sshkeys)
            if [ "$(echo "${out}" | head -1)" = "${JSON_IDFY}" ];
            then echo "$out"| sed '1d'| jq -cC '.[]|{ssh_public_key, comment}'
            else err "$out"
            fi

    ;;  groupadd~*)
            bar outline "add member to group"
            curl -su ${user}:${key} ${server}/a/groups/${source}/members/${target} -X PUT

    ;;  groupdel~*)
            bar outline "delete member from group"
            curl -su ${user}:${key} ${server}/a/groups/${source}/members/${target} -X DELETE

    ;; groupmem~*)
            bar outline "find member from group"
            curl -su ${user}:${key} ${server}/a/groups/${source}/members|grep ${target}

    ;;    group~*)
            if [ "$extra" != "none" ]; then
                info "config: " "${server}/admin/groups/q/filter:${source}"
                info "please visit url for creating & removing user/group"
                bar inline "find group by name"
            fi

            out=$(curl -su ${user}:${key} ${server}/a/groups/${source})
            if [ "$(echo "${out}" | head -1)" = "${JSON_IDFY}" ];
            then echo "$out"| sed '1d'| jq -cC '.|{id, name}'
            else
                #curl -su ${user}:${key} ${server}/a/groups/?m=${source} |sed '1d'| jq '.'
                out=$(curl -su ${user}:${key} ${server}/a/groups/?m=${source})
                if [ "$(echo "${out}" | head -1)" = "${JSON_IDFY}" ];
                then echo "$out"| sed '1d'| jq '.'
                else err "$out"
                fi
                return 0
            fi

            if [ "$extra" != "none" ]; then
                #gerritì— ëŒ€í•œ permissionì€ ìœ„ ì²˜ë¦¬ë¡œ ì¶©ë¶„í•˜ì—¬ ì•„ë˜ëŠ” ì˜ˆì™¸ì²˜ë¦¬ë¥¼ í•˜ì§€ ì•Šì•˜ë‹¤.
                bar inline "list sub-group by ${source} group"
                curl -su ${user}:${key} ${server}/a/groups/${source}/groups/ |sed '1d'| jq -c '.[]|{name, created_on}'
                bar inline "show group member by ${source} group to its decendents"
                curl -su ${user}:${key} ${server}/a/groups/${source}/members?recursive |sed '1d'| jq -cC '.[]|{name, email}'  | more -60
            fi

    ;;*)    err "please check command ex)revv user help, revv group help"
    esac
}



function revvproject(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)
    local project=$3
    local url_gerrit="${server}/a/projects/${project//'/'/'%2F'}"
    local parent=$4
    local extra=$5
    local file=$(mktemp)


    #local branch=$4
    [ -z "$user" ] && user=$ACCOUNT
    local SEP='~'
    case ${cmd}${SEP}${subcmd} in
           *~help)
            echo "check your cmd [${cmd}]"; cat <<-EOF
			usage) revv project       na mustang/tm/src                            # find project with project-name
			usage) revv project       na vendor/qct/sa515m/_lge_only               # find project and its child projects
			usage) revv projectadd    na sample/target sample/parent               # add git project from parent with empty master
			usage) revv projectadd    na sample/target                             # add git project from All-project with empty master
			usage) revv projectdel    na sample/target                             # get remove page url in gerrit
			usage) revv projectparent na sample/target sample/parent               # change parent of the project
			 info) project delete is not supported in CLI, WEB support it, please access it revv projectdel cmd

EOF
    ;;projectadd~*)
            bar inline "check if project already existed"
            local temp=$(curl -su ${user}:${key} $url_gerrit |sed '1d' | jq -cC '.name')
            if [ -n "${temp}" ]
            then err "[${temp}] already legacy project existed" && return 1;
            else clog "passed, no legacy project" "ok, continue to create"
            fi

            if [ -n "${parent}" ]; then
                temp=$(curl -su ${user}:${key} ${server}/a/projects/${parent//'/'/'%2F'} |sed '1d' | jq -cC '.name')
                if [ -z "${temp}" ]; then err "but no parent project, stop to create"; return 1; fi
            fi

            bar inline "add new project inherited All-projects(default), and create emtpy master"
            curl -su ${user}:${key} $url_gerrit -H "Content-Type:application/json" \
                 --data "{\"description\":\"revvcreate\",\"parent\":\"${parent:-'All-Projects'}\", \"create_empty_commit\":true }" \
                 -X PUT |sed '1d' > $file
            clog "result for creaing project: "
            cat $file| jq -C .

    ;;projectdel~*)
            bar inline "check if project already existed"
            local temp=$(curl -su ${user}:${key} $url_gerrit |sed '1d' | jq -cC '.name')
            if [ -n "${temp}" ]
            then clog "[${temp}] already legacy project existed" "ok, please remove manually"
            else err "no existing project, stopped" && return 1
            fi

            bar inline "'removing project' by CLI is not supported in gerrit"
            dnlog "so only provide url link, you cand remove git project there"
            dnlog "[guide] To delete project (visit):" "${server}/admin/repos/${project},commands"
            printf "\n\n"

    ;;projectparent~*)
            bar inline "check if project already existed"
            local temp=$(curl -su ${user}:${key} $url_gerrit |sed '1d' | jq -cC '.name')
            [ -z "${temp}" ] && { clog "[${temp}] already legacy project not existed"; return 1; }

            if [ -n "${parent}" ]; then
                temp=$(curl -su ${user}:${key} ${server}/a/projects/${parent//'/'/'%2F'} |sed '1d' | jq -cC '.name')
                if [ -z "${temp}" ]; then err "but no parent project, stop to create"; return 1; fi
            fi

            bar inline "changing parent of project"
            [ -z "${parent}" ] && (warn "git created whose parent is All-project(default)" && return 0)
            curl -su ${user}:${key} $url_gerrit/parent -H "Content-Type: application/json" --data "{\"parent\":\"${parent}\"}" -X PUT > $file
            clog "result for changing parent: "
            cat $file| sed '1d'| jq . | more -60
            printf "\n\n"

    ;;  project~*)
            dnlog "[gerrit url] gerrit cli:" "curl -su ${user}:${key} $url_gerrit | sed '1d'| jq  -cC '.[]'"

            info "config: " "${server}/admin/repos/${project}"
            bar inline "find project and show project url"
            curl -su ${user}:${key} ${server}/a/projects/?m=${project} |sed '1d' > $file
            clog "matching project: "  $(cat $file| jq -C 'keys[]'| pCount)

            [ "$(cat /tmp/pCount)" -ne 1 ] && return 0
            #cat $file| jq --arg jq_var "${server}/admin/repos/" -c '$jq_var + .[].id' | nl
            local temps=http://$(revvserver_item $server subdomain)
            echo $temps$(curl -su ${user}:${key} ${server}/a/projects/?m=${project} |sed '1d' | jq -rM '..|select(contains("gitweb?")?)')
            echo $temps$(curl -su ${user}:${key} ${server}/a/projects/?m=${project} |sed '1d' | jq -rM '..|select(contains("plugins")?)')

            bar inline "parent-project info"
            curl -su ${user}:${key} $url_gerrit |sed '1d' | jq -cC '.|{name,parent}'
            curl -su ${user}:${key} $url_gerrit/access |sed '1d' > $file
            cat $file| jq --arg jq_var "${server}/admin/repos/" -c '"config: " + $jq_var + .inherits_from.name'

            bar inline "grand parent-project info"
            cat $file| jq -cC '.inherits_from|{name,parent}'
            cat $file| jq --arg jq_var "${server}/admin/repos/" -c '"config: " + $jq_var + .inherits_from.parent'

            bar inline "child-project info inherited from ${project}, plz wait..."
            curl -su ${user}:${key} $url_gerrit/children/?recursive| sed '1d'| jq  -cC '.[].name' | more -60
            printf "\n\n"
    ;;*)    err "please check command ex)revv project help"
    esac
}


function revvpermission(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local file=$2

    case ${cmd} in
    ##accessapiparent, accessapigroup, accessapipermission í•¨ìˆ˜ëŠ” ì§ì ‘í˜¸ì¶œìš©ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ê²ƒìœ¼ë¡œ ì•„ë‹ˆë©°, revv accessë¡œ ë¶€í„° í˜¸ì¶œë˜ë„ë¡ êµ¬í˜„ë˜ì—ˆë‹¤.
    accessgroup*) bar inline "show permission group"
                ## group.urlì´ nullì¼ë•ŒëŠ” ì‹¤ì œ nullì´ë¼ëŠ” ë¬¸ìì—´ë¡œ replaceë¥¼ í•˜ê³ , nullì´ ì•„ë‹ë•ŒëŠ” #ë¥¼ serverì£¼ì†Œë¡œ ë³€ê²½í•´ì¤€ë‹¤.
                #cat $file|jq --arg jq_var "${server}" -c '.groups[]| {url:(.url| if .==null then "null" else gsub("#"; $jq_var) end), name}'
                cat $file|jq -c '.groups[]| {name}' >&2
    ;; accesspermission*) bar inline "show permission setting"
                ## jsonì¤‘ groupì—ì„œ urlê²½ìš°ì—ëŠ” nullì´ë¼ëŠ” ë¬¸ìì—´ë¡œ ë³€ê²½í•˜ê³ , ìˆì„ë•ŒëŠ”#ëŒ€ì‹  serverì£¼ì†Œë¥¼ ë„£ê³ , nameê²½ìš°ì—ëŠ” /ë¥¼ _ë¡œ ë³€ê²½í•˜ê³  tostring(ë¬¸ìì—´ë¡œë³€í™˜)í•˜ê³ , gsubìœ¼ë¡œ ë¬¸ìì—´ì„ replaceí•œë‹¤.
                ## 3fe63d48b76~,jlr_vcm_developer
                ## 3fcc47cb801~,mustang_tm_reviewer
                ## stdinìœ¼ë¡œ ë¶€í„° awkë¥¼ í†µí•´ ì•„ë˜ì™€ ê°™ì€ ë³€í™˜ì‹íŒŒì¼ì„ ë§Œë“¤ì–´ë†“ê³ , ë³€í™˜ì‹ì´ ë“¤ì–´ìˆëŠ” íŒŒì¼ì„ stdinìœ¼ë¡œ sedë¡œ ì…ë ¥ë°›ì•„ ì‹¤ì œ íŒŒì¼ì¸ $fileì„ ë³€ê²½í•œë‹¤.
                ## ê·¸ëŸ°ë° ì‹¤ì œíŒŒì¼ì¤‘ì— ì¼ë¶€ì¸ .localë¶€ë¶„ë§Œ í•„ìš”í•¨ìœ¼ë¡œ ê·¸ ë¶€ë¶„ì„ process substitionì˜¤ë¡œ ì…ë ¥ë°›ì•„ì„œ ì²˜ë¦¬í•œë‹¤.
                ## ì´ë•Œ jq -C '.local'ë¡œ ì²˜ë¦¬í–ˆì§€ë§Œ, compactí•˜ê²Œ ì¶œë ¥í•˜ê¸° ìœ„í•´ jq -cC '.local|to_entries | map({(.key): .})[][][]' ë¥¼ ì‚¬ìš©í• ìˆ˜ë„ ìˆë‹¤.
                local cmdfile=$(mktemp);
                cat $file|jq --arg jq_var "${server}" -crM \
                '.groups[]| {url:(.url| if .==null then "null" else gsub("#"; $jq_var) end), name:(.name| gsub("/"; "_"))} |tostring |gsub("{|\"|}";"") |gsub("url.*uuid-|name:";"")'|\
                awk -F, '{print "s/"$1"/"$2"/g;"}'> $cmdfile

                ## compactí•˜ê²Œ ë‚˜ì˜¤ì§€ ì•Šê³  full displayë¥¼ í•˜ëŠ” ê²½ìš°
                ## [ "$(cat /tmp/pCount)" -gt 10 ] && { read -t 2 -p "Press Ctrl+C not to see more ..."; cat $cmdfile|sed -f - <(cat $file|jq -C '.local'); }
                ## compact display
                ## jq -cC '.local |to_entries[] | .value.permissions | to_entries[] | {key: .key, value: .value}') ì—¬ê¸°ì„œ actionê³¼ forceê°’ì„ ì œì™¸
                cat $cmdfile| sed -f - <(cat $file | jq -cC '.local | to_entries[] | .value.permissions | to_entries[] |
                    {key: .key, value: (.value | walk(if type == "object" then del(.action, .force) else . end))}') >&2
    ;; accessparents*) bar inline "show permission parents git"
                ## ì…ë ¥ëœ projectì˜ ë¶€ëª¨ project ì •ë³´ë¥¼ stdout, stderrë¡œ ë™ì‹œ ì¶œë ¥í•œë‹¤.
                cat $file|jq 'if .inherits_from then .inherits_from | {name, id, parent, state} | del(.web_links) else "No more parents" end' >&2
    ;; *) :
    esac
}


## ---------------------------------------------------------------------------
function revvaccess(){
# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    local project=${3:-${GITT_PROJECT:-${REPP_PROJECT}}}
    local group=${4:-$USER} #gerrit group name
    local branch=$5 #^refs/heads/26my_migg_.*

    if [ "$subcmd" != "help" ]; then
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)
    local group_id=$(revvaccount group "$server" "$group" none none)
    fi

    [ -z "$user" ] && user=$ACCOUNT
    local sep='~'
    case ${cmd}$sep${subcmd} in
          *~help)  cat <<-EOF
				usage) revv access[all|add|group|groupall|permission|permissionall|parents|parentsall]   na <project>
				   ex) revv access              na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission info for current git
				   ex) revv accessall           na vendor/qct/sa515m/sa515m_modem/modem_proc  #get all permission info including parents
				   ex) revv accessgroup         na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission group for current git
				   ex) revv accessgroupall      na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission group including parents
				   ex) revv accesspermission    na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission setting for current git
				   ex) revv accesspermissionall na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission setting including parents
				   ex) revv accessparents       na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission parents for current git
				   ex) revv accessperentsall    na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission parents including parents
				usage) revv accessadd na <project>  <group> <'branch-regexp'>                 #add migration permission to a group
				   ex) revv accessadd na qct/modem  26my_migrator '^refs/heads/26my_migg_.'   #add migration permission to 26my_migrator

				 info) repp connect help : you can check your basic access permission for a git.
EOF
    ;;accessadd~)
                clog "add migration permission $group_id $branch"
                [ -z "$group_id" ] && { err "group is not existed, check $group"; return 1; }
                cat|json_pp >temp.json << TEMP_JSON
                {"add" : { ""$branch"" : {"permissions" :   {
                    "forgeCommitter"            : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "abandon"                   : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "label-Code-Review"         : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}, "label":"Code-Review"},
                    "create"                    : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "label-CodeReview-Verified" : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}, "label":"CodeReview-Verified"},
                    "pushMerge"                 : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "label-Verified"            : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}, "label":"Verified"},
                    "submit"                    : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "push"                      : {"rules" : {""$group_id"" : {"action":"ALLOW","force":true}}},
                    "forgeAuthor"               : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}}
                }}}} }
TEMP_JSON
        showRUNQ y curl -su ${user}:${key} ${server}/a/projects/${project//'/'/'%2F'}/access -H "Content-Type:application/json" -d @temp.json -X POST

    ;;access*~)
                #cat $file|jq --arg jq_var "${server}" -crM '.groups[]| {url:(.url| if .==null then "null" else gsub("#"; $jq_var) end), name}| tostring | gsub("{|\"|}";"")| gsub("url.*uuid-|name:";"")'|\
                #    sed 's:/: :g' |awk -F, '{print "s/"$1"/"$2"/g;"}' |sed -f - <(cat $file|jq '.local') > b.txt
                # cat $file|jq -cC '.local|to_entries | map({(.key): .})[][][]'
                case ${cmd} in accessgroup*|accesspermission*|accessparents*|accessall|access) :
                                                                                          ;;*) revvaccess help; return 1
                esac

                while [ "$project" != "null" ] ; do
                    local file=$(mktemp);
                    ##í˜„ì¬ projectì˜ accessì •ë³´ë¥¼ ê°€ì ¸ì˜¨ë‹¤.
                    curl -su ${user}:${key} ${server}/a/projects/${project//'/'/'%2F'}/access |sed '1d' > $file

                    if [ ! -s "$file" ] || $(cat $file | grep -q 'Not found'); then { err "${project} is not existed"; break; }; fi
                    info "config: " "${server}/admin/repos/${project},access"
                    clog "rawfile:" "cat $file|jq -cC '.'"

                    ##cat rule.txt | sed -f - <(cat /tmp/tmp.frgiex2IBv | jq '.local|walk(if type == "object" then del(.force) else . end)')
                    ##cat $file|jq --arg jq_var "${server}" -crM '.groups[]| {url:(.url| if .==null then "null" else gsub("#"; \$jq_var) end), name:(.name| gsub("/"; "_"))} |tostring |gsub("{|\"|}";"") |gsub("url.*uuid-|name:";"")'|awk -F, '{print "s/"\$1"/"\$2"/g;"}'
                    wave
                    case ${cmd} in
                        accessgroup*|\
                        accesspermission*|\
                        accessparents*)     [ "$(revvpermission ${cmd} $file)" = "No more parents" ] && break
                        ;;accessall|access)      revvpermission accessgroup $file
                                                 revvpermission accesspermission $file
                                            [ "$(revvpermission accessparent $file)" = "No more parents" ] && break
                    esac
                    [[ ! "$cmd" =~ "all" ]] && break; ##accessallì¼ë•ŒëŠ” ë°˜ë³µ
                    ##ë¶€ëª¨ projectì˜ ì´ë¦„ì„ ê°€ì ¸ì˜¨ë‹¤.
                    #cat $file |jq -rM '.inherits_from.web_links[] | select(.url | contains("plugins")) | .url' |sed -E 's#\/(.*)/plugins.*#\1#'
                    project="$(cat $file |jq -rM '.inherits_from.id')"
                done
    esac
}



function revvbranch(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)
    local source=${3:-$USER}
    local target=$4
    local extra=$5


    #local branch=$4
    [ -z "$user" ] && user=$ACCOUNT
    local SEP='~'
    case ${cmd}${SEP}${subcmd} in
           *~help|*~)
            echo "check your cmd [${cmd}]"; cat <<-EOF
			   ex) revv branch    na mustang/tm/src tsu_25.5my_release         # find branch with branch-name
			   ex) revv branchadd na mustang/tm/src tsu_25.5my_release_new     # create branch (will ask base branch)
			   ex) revv branchdel na mustang/tm/src tsu_25.5my_release_old     # remove branch
			 info) 'empty branch' can be created by 'revv projectadd' not 'revv branchadd'
			       therefore if you want 'empty branch', refer 'gitt branch create empty'
EOF
            clog "\ncopy & modify this:" "revv branch ${GITT_REMOTE:-${REPP_REMOTE}} "${GITT_PROJECT:-${REPP_PROJECT}}" "${GITT_BRANCH:-${REPP_BRANCH}}""

    ;;branchadd~*)
            bar inline "create branch with base revision"
            if [ -z "${extra}" ]; then read -p "input base branch which new branch is created from: ";fi
            showRUNQ y curl -su ${user}:${key} ${server}/a/projects/${source//'/'/'%2F'}/branches/${target} -H "Content-Type:application/json" --data "{"revision":"${extra:-${REPLY}}"}"  -X PUT

    ;;branchdel~*)
            bar inline "delete branch by name"
            showRUNQ y curl -su ${user}:${key} ${server}/a/projects/${source//'/'/'%2F'}/branches/${target} -X DELETE
            clog "if cannot delete branch, use cli with force option" "git push vgit_na HEAD:refs/heads/tsu_26my_release -f"

    ;;   branch~*)
            bar inline "find branches by name"
            curl -su ${user}:${key} ${server}/a/projects/${source//'/'/'%2F'}/branches/?m=${target} | sed '1d'| jq  -cC '.[]|{ref,revision}' | more -60

    ;;*)    err "please check command ex)revv branch help"
    esac
}



function revvcommit(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)

    local source=${3:-$USER}
    local target=$4
    local extra=$5
    local file=$(mktemp)

    #local branch=$4
    [ -z "$user" ] && user=$ACCOUNT
    case ${cmd} in
       find)
            local change_id=$(curl -su ${user}:${key} ${server}/a/changes/${source} |sed '1d'| jq -r '.change_id')
            if [ -z "${change_id}" ]; then
                err "NOT Found in $server change_id for commit_id [${source}]"
                echo "this commit is not in this gerrit system."
                clog "info:" "it could bue direct pushed commit or maybe in other servers"
                return 1;
            fi
            curl -su ${user}:${key} ${server}/a/changes/?q=${change_id}| sed '1d' > ${file}

            local pro branch changenumber path
            under "commit & user info from gerrit server\n"
            jq -c '.[]' "${file}" | while read -r change; do
                changenumber=$(echo "$change" | jq -r '._number')
                pro=$(echo "$change" | jq -r '.project')
                branch=$(echo "$change" | jq -r '.branch')
                submitter=$(echo "$change" | jq -r '.submitter._account_id')

                clog "gerrit url:" "$server/c/$pro/+/$changenumber"
                revvaccount user na "$submitter" none none

                echo "$change" | jq '{project,branch,change_id,_number,subject,status,submitted}'
                echo

                under "commit info from current source\n"
                path="$REPP_ROOT/$(repo list -p "$pro" 2> /dev/null)"
                clog "local git path:" "$path"
                git -C "$path" show --quiet "$source"

                wave
            done

    ;;*|help)
            cat <<-EOF
			usage) revv commit find [na|as|eu|devops_test|review] <commit-id>    # find commit info from server
			   ex) revv commit find na 57a4eeeca914                              # get change-id from commit-id

			info) 'review' is lamp-sever, others are vgit server, these servers must be predefined.
			info) to find in all server, use 'repp commit find 57a4eeec'.
EOF

    esac
}



function revvforall(){
## ---------------------------------------------------------------------------
# repoforall for revv
# ex) revv forall branch vgit_na              #check branch ${REPO_RREV}
# ex) revv forall branchadd vgit_na _temp     #check branch ${REPO_RREV}_temp
# ex) revv forall branchdel vgit_na _temp     #check branch ${REPO_RREV}_temp
# $1 account
# $2 server
# $3 gitproject
# $4 branch
###### *ëŠ” ì“°ì§€ë§ì. ëŒ€ì‹  ëª…ì‹œì ìœ¼ë¡œ ì¨ì•¼ í•œë‹¤. @all, @curr ë“±ìœ¼ë¡œ ì‚¬ìš©í•˜ì
    local cmd=$1
    local target=$2 #no need * for all file in gerrit, remove
    local source=$3

    case $cmd in
        help) cat <<-EOF
			usage) revv forall <cmd> <target_branch> <base_branch>
			guide) revv forall is working based on the manifest.xml.
			 info) Ocmd: print 1st command without run
			       Dcmd: run 1st command & debug info & exit
			       Pcmd: print all command without run
			       Ecmd: run command, if error occurs then exit
			        cmd: run command, if error occurs then continue

			 info) @branch: current branch, @remote: current remote, @project: current project
			 info) use 'revv forall setgit' to apply specific gits, this setting is remained until reset.
			   ex) revv forall setgit        .                           # repo forall . (for current project)
			   ex) revv forall setgit sample/poky sample/meta-browser    # repo forall some projects (for only input projects)
			   ex) revv forall setgit                                    # reset, therefore all gits is applied

			   ex) revv forall branch        master                      # check if branch(master) exist
			   ex) revv forall Ebranch       master                      # check if branch(master) exist, if error occurred, will stop.
			   ex) revv forall Pbranch       master                      # print command without running
			   ex) revv forall Dbranch       master                      # print debug info with running 1st cmd
			   ex) revv forall branch        @branch                     # check if current branch is existed in remote
			   ex) revv forall branchlist                                # print all branches
			   ex) revv forall branchlist    '*my*'                      # print all branches including 'my'
			   ex) revv forall branchlist    mas                         # print all branches including 'mas'
			   ex) revv forall branchadd     new master                  # create branch 'new' based from 'master'
			   ex) revv forall branchadd     @branch master              # create branch as written in manifest revision from master
			   ex) revv forall branchaddpre  new_ @branch                # create branch with name of new_<current_branch> from current
			   ex) revv forall branchaddpost _new @branch                # create branch with name of <current_branch>_new from current
			   ex) revv forall branchaddpost _new master                 # create branch 'master_new' from 'master'
			   ex) revv forall branchdel     master                      # delete branch 'master'
			   ex) revv forall branchdel     @branch                     # delete current branch (current remote branch)
			   ex) revv forall branchdelpre  new_ @branch                # delete branch with name of new_<current_branch> from current
			   ex) revv forall branchdelpost _new @branch                # delete branch with name of <current_branch>_new from current

			   ex) revv forall project                                   # check if projects exist listed in manifest
			   ex) revv forall projectadd    parent                      # add projects listed in manifest
			   ex) revv forall projectdel                                # list up all url can delete the git

			   ex) revv forall accessurl     @project                    # list up all url can access setting
EOF
            return 0
    ;; setgit)  info "setgit is delivered to 'repo forall <git list>', this setting is sustain until reset it"
                echo "flow) cat ${REPPFILE_CSV} |awk -F'|' {'print \$7'} > project.list"
                echo "flow) revv forall setgit \$(cat project.list) #select gits"
                echo "flow) revv forall Pbranch master #do job for any selected gits"
                echo "flow) revv forall setgit #reset, remove selected git setting"

                echo "flag_forall=${@:2} #print selected gits" ; #setgit is all next cmd from @:2
                source  <(echo 'flag_forall="${@:2}"'); return 0
    ;;   branch*|?branch*) :
    ;; project*|?project*) :
    ;;   access*|?access*) :
    ;;                  *)  err "please check usage: not registerd cmd, use 'revv forall help' "; return 1
    esac

    set -o noglob
    local tempr=/tmp/revv.ret
    if [ -f "${tempr}" ]; then rm -f "${tempr}"; touch "${tempr}"; fi
    #test case all) revv forall branchlist, gitt branch list '*', revv forall branchlist '*mas*'
    [[ "${target}" =~ "*" ]] && clog "[warn]" "asterisk * is not permitted in gerrit, automatically removed"
    case ${cmd::1} in
      O|D) repo forall ${flag_forall}                   -evcj1 bash 'revvscript.sh' $cmd ${target//\*/} ${source} 2>/dev/null
    ;;  E) ## if missing-project exists, repo forall -e option cannot stop bash subprocess, so continue to end
           err $(repo forall -c '') #only print log: skipping project
           repo forall ${flag_forall} --ignore-missing -evcpj1 bash 'revvscript.sh' $cmd ${target//\*/} ${source} 2>/dev/null
    ;;P|*) repo forall ${flag_forall}                   -vcpj4 bash 'revvscript.sh' $cmd ${target//\*/} ${source}
    esac

    set +o noglob
    #supress show result msg, only E|NONE type show log.
    case ${cmd::1} in  P|O|D) return 0; esac

    read -p $'\n\nshow result log: [ctrl+c: exit | enter: continue]? '
    bar inline ""
    cat ${tempr} |grep --color=always FAIL | tee /dev/tty | wc -l
    bar inline ""
    cat ${tempr} |grep --color=always OKAY | tee /dev/tty | wc -l
    #pr -2 -t <(cat ${tempr} |grep FAIL)
}


function revvshowcmd(){
## ---------------------------------------------------------------------------
# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)

    local usercmd=${2-${USER}}
    local oriproject=${3:-${GITT_PROJECT:-${REPP_PROJECT}}}
    local gitproject=${oriproject//'/'/'%2F'}
    #local branch=$4

    [ -z "$user" ] && user=$ACCOUNT
    case ${cmd} in
       help)    cat <<-EOF
				usage) revv cmd help                                    #show account info from gerrit server
				usage) revv cmd <server> <account> <gitproject>         #make gerrit POST command
				   ex) revv cmd eu joongkeun.kim mustang/tm/src         #make gerrit POST command with parameter
				   ex) revv cmd eu joongkeun.kim
				   ex) revv cmd eu
				   ex) revv cmd
EOF
            bar outline "info gerritserver: ex) show gerrit account"
            showRUN curl -su ${user}:${key} ${server}/a/accounts/?suggest\&q=${usercmd} |more

    ;; *)
            bar outline "show gerrit account commands"
            cat <<-EOF
			## check if <user> account is existed           ex) curl -su ${user}:${key} ${server}/a/accounts/?suggest\&q=${usercmd}| more
			## list group <user> belongs to                 ex) curl -su ${user}:${key} ${server}/a/accounts/${usercmd}/groups |sed '1d'| jq  '.[].name'| sort |more
			## find group which has string <group-name>     ex) curl -su ${user}:${key} ${server}/a/groups/?m=<group-name>

			## show group member for <group-name>           ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/members?recursive
			## list sub-group in <group-name>               ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/groups/
			## add account to group                         ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/members/${usercmd} -X PUT
			## check account is existed in <group-name>     ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/members|grep ${usercmd}
			## remote accout from group                     ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/members/${usercmd} -X DELETE
			## get ssh-key for specific account             ex) curl -su ${user}:${key} ${server}/a/accounts/${usercmd}/sshkeys
EOF
            bar outline "show gerrit project which name has <project-name>"
            cat <<-EOF
			##find git project named <gitproject>           ex) curl -su ${user}:${key} ${server}/a/projects/?m=${gitproject:-"<project-name>"}
			##find labels, parents[id], basic info          ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}
			##find child projects of <project name>         ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/children/?recursive| sed '1d'| jq  '.[].name'
EOF
            bar outline "show gerrit branch which name has <branch-name>"
            cat <<-EOF
			##list branches including named <branch>        ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/branches/?m=<branch-name>
			##remove branch                                 ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/branches/<branch-name> -X DELETE
			##create branch with base revision              ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/branches/<branch-name> -H "Content-Type: application/json" --data '{"sha": "049405ab2885e6c6844b212f83b43f835c904"}'  -X PUT
EOF
            bar outline "show gerrit tag which name has ${tag}"
            cat <<-EOF
			##list tag named <tag-name>                     ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/tags?m=<tag-name>
			##show tag date, tag revision, committer        ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/tags/<tag-name>
EOF
            bar outline "show gerrit commit with branch info"
            cat <<-EOF
			##show commit msg with data, author, committer  ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/commits/<full-sha-code>
			##show branches that commit beloings to         ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/commits/<full-sha-code>/in
			##show files that commit has changed            ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/commits/<full-sha-code>/files
			##show all hashtaged commit                     ex) curl -su ${user}:${key} ${server}/a/changes/?q=hashtag
			##show hastag with HITT or TAT2                 ex) curl -su ${user}:${key} ${server}/a/changes/?q=hashtag:HITT+OR+hashtag:TAT2
EOF
    esac
}



function revvserverstatus(){
## ---------------------------------------------------------------------------
# find replication server
# $1 server-url
# $2 port-number
    local server_port=${REPP_URL#*@}
    local server=${1:-${server_port%:*}}
    local user=${2:-${USER}}
    local port=${3:-$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')}

    if [ -z "${server}" ] || [ -z "${port}" ] ; then info "usage) revv server status vgit.lge.com 29999"; return 0;fi
    ping $server -s 1016 -c 4 -A
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    if [ $? -ne 0 ]; then continue; fi
    ssh ${user}@$server -p $port -o ConnectTimeout=2 -o ConnectionAttempts=1 gerrit show-caches
    if [ $? -ne 0 ]; then continue;fi
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    echo "please check 1) ipg/ewma from ping, 2) AvgGet from gerrit connection"
}



function revvdebug(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local server=$(revvserver_item ${1:-na} http)
    local key=$(revvserver_item $2 pass)
    local cmd=${2-${ACCOUNT}}
    local gitproject=${3//'/'/'%2F'}
    #local branch=$4

    case ${usercmd} in
       help)    cat <<-EOF
				usage) revv info                                   #show gerrit POST command
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) echo "default functionality"
    ;; esac
}




##==========================================================================================================================
## below functions allow parameter "*, ?, +, ..." with non-globbing option
#__noglob() { $@; set +o noglob ;}
#must enable globbing within fuction at the begining.
#alias revv='set -o noglob; revv'
#alias gitt='set -o noglob; gitt'
#alias repp='set -o noglob; repp'

##==========================================================================================================================
function revv(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1: command
# $2: server
# $3: account

#set +o noglob
local MENU=(
"     info: shows repository info such as manifest path, repo cmd, tree of manifests, etc"
"      cmd: list useful command from gerrit"
"  connect: check if input account can access branch in gitproject on server"
"   server: check/add/listup predefined git server list or status"
"    debug: show variable REPO, REPP, REPPFILE, GITT variable used in script"
"   forall: repoforal for revv branch commands"
"     user: check if account is existed & get account info "
"   sshkey: get registered SSH-key for an account in server "
"    group: find/findmember/add/delete group by name"
"  project: find/add/delete project or change parents of project"
"   access: show access permission/group in specific git including child & parents"
"   commit: find commit in review system"
"   branch: find/add/remove branches by name"
)

local ret=0
case "$1" in
                     ##$1:cmd      ${@:2}:parameters
                        help)                                            reppmenu help "${MENU[@]}"
    ;;                    '')                                            reppmenu revv "${MENU[@]}"
    ;;                server)  [ "$2" = "status" ] && revvserverstatus "${@:3}" || revvserver "${@:2}"
    ;;                   cmd)      reppcheck_initvar reppgittrevv    &&  revvshowcmd "${@:2}"
    ;;               connect)      reppcheck_initvar gittrevv        &&  revvconnect "${@:2}"
    ;;                  info)      reppcheck_initvar gittrevv        &&  revvinfo  "${@:2}"
    ;;                 debug)      reppcheck_initvar gittrevv        &&  revvdebug "${@:2}"
    ;;                forall)      reppcheck_initvar repprevv        &&  revvforall "${@:2}"
    ;;                commit)      reppcheck_initvar reppgittrevv    &&  revvcommit "${@:2}"
    ;;               access*)      reppcheck_initvar repgittprevv    &&  revvaccess "${@:1}"
    ;;               branch*)      reppcheck_initvar reppgittrevv    &&  revvbranch "${@:1}"
    ;;              project*)      reppcheck_initvar repprevv        &&  revvproject "${@:1}"
    ;;    user|sshkey|group*)      reppcheck_initvar repprevv        &&  revvaccount "${@:1}"
esac
return $ret
}



##==========================================================================================================================
function gitt(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
#set +o noglob
local MENU=(
"   info: shows git path, gerrit info/url/remote, push command, commit info, sync time"
"   show: shows git (default 15) commits history, file change list"
"     go: move dir to repo root, git root, manifest dir or specific git"
" commit: git auto commit or show commit info (change file list and diff view)"
" branch: lookup, create, delete remote branch"
"   find: find string(changes) in commit history by multiple way."
"   diff: compare commit, branch with dir/file"
"  reset: reset git repository by choices"
"  debug: show GITT & REPO variable"
)
local ret=0
case "$1" in
    ##$1:below ${@:2}:parameters
          help)                                     reppmenu help "${MENU[@]}"
    ;;      '')                                     reppmenu gitt "${MENU[@]}"
    ;;    info)     reppcheck_initvar Oreppgitt &&  gittinfo
    ;;    show)     reppcheck_initvar gitt      &&  gittshow "${@:2}"
    ;;      go)     reppcheck_initvar gittgo    &&  gittgo "${@:2}"
    ;;  commit)     reppcheck_initvar gitt      &&  gittcommit "${@:2}"
    ;;  branch)     reppcheck_initvar gitt      &&  gittbranch "${@:2}"
    ;;    find)     reppcheck_initvar gitt      &&  gittfind "${@:2}"
    ;;    diff)     reppcheck_initvar gitt      &&  gittdiff "${@:2}"
    ;;   reset)     reppcheck_initvar gitt      &&  gittreset "${@:2}"
    ;;   debug)                                     gittdebug "${@:2}"
    ;;       *)     bar outline "call native git"
                    git "${@}";;
esac
return $ret
}



##==========================================================================================================================
function repp(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
#set +o noglob
local MENU=(
"    info: shows repository info such as manifest path, repo cmd, tree of manifests, etc"
"    show: shows uncommitted changes, top -1 commits, md5 sum for all repository"
"      go: move to repo root dir, manifest dir, git path nearby with similar depth"
"  commit: shows latest commits(git log -1) from all repository (default 20)"
"    find: search(list) string in all (repo revision, remote, branch, project, path)"
"  branch: show branch info, push remote branch, look-up remote-branch"
"    mani: repo manifest handling"
"    init: repo init with automatic options"
"    sync: repo sync with optimized multi-job and options"
"   reset: reset all repositories to original state"
"  ersion: check repo & python version and provide repo upgrade"
"  onnect: check the connection with git host server and accessibilty for branch of git"
"   debug: show variable REPO, REPP, REPPFILE, GITT variable used in script"
" install: check essential linux packages to run repp utility"
"  forall: run 'repo forall' from .repp/reppforall.csv(plz put your cmds before run)"
)

local ret=0
case "$1" in
     ##$1:cmd       check if validation                          ${@:2}:parameters
       help)                                                reppmenu help "${MENU[@]}"
    ;; '')                                                  reppmenu repp "${MENU[@]}"
    ;; info)        reppcheck_initvar repp              &&  reppinfo  "${@:2}"
    ;; show)        reppcheck_initvar repp              &&  reppshow "${@:2}"
    ;; go)          reppcheck_initvar repp              &&  reppgo "${@:2}"
    ;; commit)      reppcheck_initvar repp              &&  reppcommit "${@:2}"
    ;; find|list)   reppcheck_initvar repp              &&  reppfind "${@:2}"
    ;; branch)      reppcheck_initvar repp              &&  reppbranch "${@:2}"
    ;; mani)        reppcheck_initvar reppmani          &&  reppmani "${@:2}";
    ;; forall)      reppcheck_initvar repp              &&  reppforall "${@:2}";
    ;; init)                                                reppinit "${@:2}"
    ;; sync)                                                reppsync "${@:2}"
    ;; reset)       reppcheck_initvar repp              &&  reppreset "${@:2}"
    ;; version)     reppcheck_initvar repp              &&  reppversion "${@:2}"
    ;; connect)                                             reppconnect "${@:2}"
    ;; debug)                                               reppdebug "${@:2}"
    ;; install)                                             reppinstall
    ;; *)           bar outline "result of native repo";    repo "${@}"
esac
return $ret
}



function reppmenu(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
# $2 help array for each command
local cmd="$1"
local MENU=( "${@:2}" )


printf ${green}
cat << PREFACE
==============================================================
 welcome to gitt & repp & review
 -------------------------------------------------------------
 command usage: ex) gitt, gitt info, gitt show [currnet git]
 command usage: ex) repp, repp info, repp show [default.xml]
 command usage: ex) revv
 ex) repp info, repp find [string], repp sync 16 --force-sync, etc
 ex) gitt info, gitt find [string], gitt show, etc
 ex) revv info
 help: http://collab.lge.com/main/x/xYv4j
==============================================================
PREFACE
printf ${NCOL}

if [ "$1" = "help" ]; then
    for m in "${MENU[@]}"; do clog "${m%%:*}" "${m##*:}"; done
    return 0;
fi

local COLUMNS=60
PS3=$'\e[00;35m=== Please input command! [enter:menu, number:choice, ctrl+c:exit] === : \e[0m'
select CHOICE in "${MENU[@]}"; do
    $cmd ${CHOICE%%:*}
    if [ -n "$?" ]; then return 1;fi
done
}



function reppdebug(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'

    #sourceë¡œ ë¬¶ì–´ì„œ ì‹¤í–‰(ë³€ìˆ˜, ë”°ì˜´í‘œ/íŠ¹ìˆ˜ë¬¸ì ì²˜ë¦¬ë¥¼ shell terminalì—ì„œ ì…ë ¥í•œ ê·¸ëŒ€ë¡œ ë™ì‘ì‹œí‚¤ê¸° ìœ„í•¨, showRUNë¶€ë¶„í™•ì¸)
    source <(cat <<'EOL'
        bar inline "GITT_VARIABLE && REPP_VARIABLE for all repository"
        for var in \
        '${REVV_VER}' '${REVV_TAG}' '${REVV_SERVER}' \
        '${GITT_REMOTE}' '${GITT_PROJECT}' '${GITT_BRANCH}' '${GITT_PATH}' '${GITT_REVIEW}' '${GITT_URL}' \
        '${REPP_PATH}' '${REPP_ROOT}' '${REPP_INIT}' '${REPP_REMOTE}' '${REPP_PROJECT}' '${REPP_BRANCH}' '${REPP_URL}' '${REPP_REPOURL}' '${REPP_REF}' '${REPP_GROUPS}' '${REPP_COUNT}' \
        '${REPPFILE_STATUS}' '${REPPFILE_COMMIT}' '${REPPFILE_CSV}' '${REPPFILE_XML}' '${REPPFILE_MANI}'
        do
           dnlog "$var\t" $(eval echo $var)
        done

        for (( i=0; i < ${#REPP_REMOTELIST[@]}; i++ )); do
            dnlog "\${REPP_REMOTELIST[$i]}\t\t"   "${REPP_REMOTELIST[$i]}"
            dnlog "\${REPP_REVIEWLIST[$i]}\t\t"   "${REPP_REVIEWLIST[$i]}"
        done

        bar inline "[${GITT_PROJECT}] print repo variable"
        showRUN repo forall ${GITT_PROJECT:--r .*build.*} -ec 'echo ${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_UPSTREAM}, ${REPO_DEST_BRANCH}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'

        bar inline "[all repo] print repo variable"
        dnlog                '${REPO_I}/${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'
EOL
)
    ##run echo
}



function reppinstall(){
## ---------------------------------------------------------------------------
#install basic package for repp
if ! command -v curl > /dev/null ; then clog "curl need to be installed:" "sudo apt install curl"; fi
if ! command -v icdiff > /dev/null ; then clog "icdiff need to be installed:" "sudo apt install icdiff"; fi
if ! command -v jq > /dev/null ; then clog "jq need to be installed:" "sudo apt install icdiff"; fi
if ! command -v repo > /dev/null ; then clog "repo need to be installed:" "sudo apt-get install repo"; fi
if [[ ! $(column -V 2>/dev/null|grep util-linux) =~ "util-linux" ]] ;then clog "column need to reinstalled:";
    cat << GUIDE
    1. dpkg -l | grep -i util-linux ##find a nearest version
    2. wget https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.31/util-linux-2.31.tar.gz
    3. tar zxvf util-linux-2.31.tar.gz
    4. cd util-linux-2.31
    5. ./configure
    6. make column
    7. sudo cp .libs/column /usr/bin/column
GUIDE
fi
}



function gittdebug(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'

    if gittcheck_isgitproject; then
        reppcheck_initvar gitt
    fi

    source <(cat <<'EOL'
        bar inline "GITT_VARIABLE && REPP_VARIABLE for this git"
        for var in \
        '${GITT_PROJECT}' '${GITT_REMOTE}' '${GITT_BRANCH}' '${GITT_REVIEW}' '${GITT_URL}' '${GITT_PATH}'
        do
           dnlog "$var\t" $(eval echo $var)
        done

        bar inline "[${GITT_PROJECT}] print REPO variable using repo"
        showRUN repo forall ${GITT_PROJECT:+.} -c 'echo ${REPO_I}/${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, \
          ${REPO_UPSTREAM}, ${REPO_DEST_BRANCH}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'

EOL
)
    ##run echo
}



function gitthelp(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'

    case ${cmd} in
        help)   echo "print git help"
    ;;  area)   cat <<-EOF
				info) git area
				current : workspace      | index     |   local repository     remote repository
				-----------------------------------------------------------------------------------------------------
				          working area   | cached    |   history              remote
				          unstaged       | staged    |   commit
				          untracked      | tracked   |   tree

EOF
    ;;     *)   echo cat <<-EOF
				usage) gitt help area #show git area
				usage) gitt reset     #show detail reset commands
EOF
esac
}



##============================================================================
## Main
##============================================================================
REVV_VER=
GITT_REMOTE= &&GITT_PROJECT= &&GITT_BRANCH= &&GITT_REVIEW= &&GITT_URL= &&GITT_PATH=
##REPP_PATH=.repo/manifests, REPP_ROOT=src root, REPP_COUNT=total repo count, REPP_CMD=repo command
###REPP_REMOTE=manifest remote, REPP_URL=manifest git url, REPP_BRANCH=manifest branch, EPP_REPOURL=repo url, REPP_REF=reference path, REPP_GROUPS=group option when repo init,
REPP_ROOT= &&REPP_PATH= &&REPP_COUNT= &&REPP_CMD=
REPP_REMOTE= &&REPP_PROJECT= &&REPP_URL= &&REPP_BRANCH= REPP_REPOURL= &&REPP_REF= &&REPP_GROUPS=
REPP_REMOTELIST=()
REPP_REVIEWLIST=()
REPP_PATH_ALL=()

#sourceë¡œ ì‹¤í–‰ë˜ì—ˆëŠ”ì§€, callë¡œ ì‹¤í–‰ë˜ì—ˆëŠ”ì§€ íŒë‹¨
(return 0 2>/dev/null) && sourced=true || sourced=false
if $sourced; then REPP_INIT=0; #repp source ì™„ë£Œ
    echo "[WELCOME] repp & gitt utility is applied for current shell";
else err "you must run repp using 'source repp'"; fi

# #repp flow
# 1. source reppë¡œ í˜„ì¬ shellì— repp ì ìš©
# 2. ì´í›„ repp í•¨ìˆ˜ì—ì„œ repp infoì™€ ê°™ì´ ì§ì ‘ëª…ë ¹ì„ ì‹¤í–‰í•˜ê±°ë‚˜, ì•„ë‹ˆë©´ menuë¥¼ í†µí•´ì„œ ì‹¤í–‰
# 3. reppcheck_initvarì—ì„œ ì…ë ¥ëœ ëª…ë ¹ì— ë”°ë¼ repp,gitt,revv ëŒ€í•œ ì„¤ì •
# 4. repp_initvarrë¥¼ í†µí•œ reppí™˜ê²½ ì„¤ì •, REPP_INIT ë³€ìˆ˜ë¥¼ ì„¤ì •í•¨ìœ¼ë¡œ ì´ˆê¸°í™”ê°€ ì˜ë˜ì—ˆìŒì„ í‘œì‹œí•œë‹¤.
# *  REPP_INIT=0 sourceë¨, REPP_INIT=1 repo initìƒíƒœ, REPP_INIT=2ì´ë©´ repp script ì´ˆê¸°í™”ì™„ë£Œ, REPP_INIT=3 repp_initdbë¡œ dbê¹Œì§€ ì´ˆê¸°í™” ì™„ë£Œ
# 5. repp find ëª…ë ¹ì„ ë„£ìœ¼ë©´ reppí•¨ìˆ˜ì—ì„œ find ëª…ë ¹ì¸ í™•ì¸í•˜ì—¬ reppfindë¥¼ í˜¸ì¶œí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬ë™ëœë‹¤.