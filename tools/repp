#!/bin/bash
## ==========================================================================
##  readme    : repo utiliies
##  mail      : joongkeun.kim@lge.com, av9300@gmail.com
## ==========================================================================
###---------------------------------------------------------- DEBUG OPTION
#DEBUG=["echo -e"|:], : means no-operation
DEBUG=:
PATH_FULL=$(realpath "$BASH_SOURCE")
PATH_DIR="${PATH_FULL%/*}"
PATH_FILE="${PATH_FULL##*/}"
DIR_CURR=$(pwd)
LC_ALL=C.UTF-8

$DEBUG "[$_][$BASH_SOURCE][$0]  [${PATH_FULL}][${PATH_DIR}][${PATH_FILE}]"

if [ -e "${PATH_DIR}/prelibrary" ]; then source ${PATH_DIR}/prelibrary;
else source ${proFILEdir}/tools/prelibrary; fi
##user setting
account=vc.integrator
path_mirror="/data001/${account}"/mirror


##------------------------ alias & oneline func ------------------------------
##============================================================================
#### git alias
## load direct from below
source <(cat <<\EOF
    git config --global alias.alias 'config --get-regexp ^alias\.'
    git config --global alias.st 'status'
    git config --global alias.ci 'commit --verbose'
    git config --global alias.loga 'log --oneline --decorate --graph -n 15 --all'
    git config --global alias.logo "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset %C(blue)<%an>%Creset' --abbrev-commit --date=relative"
    git config --global alias.tagcur 'describe --tags --abbrev=0 --match'
    git config --global alias.diffc 'difftool -t bc'
    git config --global alias.diffv 'difftool -t vimdiff'
    git config --global alias.difft 'difftool --dir-diff -t vimdiff'

    ## NEEDTO: sudo apt-get install icdiff
    #git config --global alias.diffi "difftool --extcmd 'icdiff'"
    git config --global alias.diffi '!_gitdiff() { git difftool --extcmd "icdiff $@"; }; _gitdiff' --replace-all
    #git config --global alias.clear !_gitclear() { git reset --hard $1; git clean -xdf; }; _gitclear
EOF
)


## oneline function
##suppress print path
pushd() { command pushd "$@" > /dev/null ;}
popd() { command popd "$@" > /dev/null ;}
NJOBS=$(( $(nproc --all) / 4))
gittcheck_isgitproject(){ git -C "$1" rev-parse --is-inside-work-tree &> /dev/null ;}

##--------------------------- Menu Functions --------------------------------
##============================================================================

function tempfunc(){
## ---------------------------------------------------------------------------
# template for bash fuction 
# $1 parameter explanation
# $2 parameter explanation
    local cmd=$1
    local opt=$2

    case $cmd in
       help) cat <<- EOF
				usage) gitt branch list <''|name-filter>
				usage) gitt branch create|new <name>
				usage) gitt branch delete|remove <name>
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) echo "default functionality"
    ;; esac
}



function reppshow_manifesttree(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest file name
# $2 treedepth to display sub manifest
    local file
    local path='|--|--|--|--|--|--'
    local treedepth=${2:-0}

    ##print name of manifest
    printf "%s$1 \n" "${path::${treedepth}}"

    (( treedepth=treedepth+3 ))
    ##print name of branches
    cat $1| sed -n 's/.*revision="\([^ |\t]*\)".*/\1/p' |sort|uniq| xargs -n1 -I {} printf "%60s {}\n"

    ##sub manifests
    cat $1 | sed -n 's/.*include name="\(.*\)".*/\1/p' | \
    while read -r file; do
        if [ -n "${file}" ];then reppshow_manifesttree ${file} ${treedepth}; fi
    done
    (( treedepth=treedepth-3 ))
}



function reppmani(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest output file name
# $2 command
# $3 branch name or branch postfix
    local cmd=$1
    local item=$2
    local str=$3
    local filter=$4


    case ${cmd} in
           ''|help) cat <<- EOF
				usage) repp mani help
				usage) repp mani info
				usage) repp mani gen <outfile>
				usage) repp mani change <groups|upstream|dest-branch|etc> <str> <filter>
				ex) repp mani change groups deststring pdk
EOF
    ;;        info) bar inline "recently changed manifest file [default 10 commit]"
                    showRUN git log -10 --name-status --abbrev=6 --date=format:"%Y-%m-%d %H:%M" --pretty=format:"%C(yellow)%ad %C(red)%h %C(green)%s%C(reset)"
    ;;         gen) bar inline "current manifest.xml regnerated with option"
                    clog "-r --suppress-dest-branch --suppress-upstream-revision" "generate revision without -- option"
                    clog "-m default.xml" "use default.xml as input"
                    clog "--json " "generate manifest to json format"
                    read -p "input option :" opt
                    showRUN repo manifest ${opt} -o ${item:-${REPPFILE_XML}}
    ;;      change) under "please run one of these 'repo manifest' commands to change string in manifest\n"
                    clog "usage) repp mani change <group|upstream|dest-branch|etc> <change-string> <filter>"
                    clog "ex) infix: change field[item] with [str] " "repp mani change name str"
                    clog "ex) infix: change field[item] includig filter [xxx] with [str] " "repp mani change name str poky\n"
                    cat <<- CHANGE
					     infix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="${str}"#'
					    prefix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="${str}\1"#'
					   postfix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="\1${str}"#'
					  infilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="${str}"#'
					 prefilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="${str}\1"#'
					postfilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="\1${str}"#'
                    
					   verifiy : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="\1${str}"#' | grep --color=auto ${str}
					   preview : icdiff <( cat ${REPPFILE_XML} ) <( cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="\1${str}"#' )
CHANGE
    ;; esac

}
 


function reppget_repcmd(){
## ---------------------------------------------------------------------------
# get repo command from exising repo project
# $1 show repo command (default: save info to each variable such as REPP_REMOTE, REPP_BRANCH, ...)
    local count file_tempa file_tempb

    if [ -z "${REPP_BRANCH}" ]; then
        printf "${RED}[warning] please check if you have switched to a topic branch from after repo init${NCOL}\n"
        printf "${RED}[warning] temporarily set to local branch name${NCOL}\n"
        printf "\tyou can set-up upstream branch with: git branch -u %s <branch-name>\n" "$(echo $(git remote -v |cut -f1))"
        REPP_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    fi

    ## find using manifest.xml
    file_tempa=$(command ls -Art ../*.xml | tail -n 1)
    count=$(grep -c include ${file_tempa})
    if [ -L "${file_tempa}" ];then
        file_tempb=$(readlink "${file_tempa}")
        FILE_MANI=${file_tempb#*/}
    elif [ $count -eq 1 ]; then
        file_tempb=$(grep include $file_tempa |sed -E 's/<.*name="(.*)".\/>/\1/')
        FILE_MANI=${file_tempb// /}
    else
        FILE_MANI=default.xml
    fi

    if [ -n "$REPP_MIRROR" ];then EXTRA_OPTION="--reference=$REPP_MIRROR"; fi
    if [ "$1" = "info" ];then
        bar inline "repo-init cmd"
        REPP_CMD="repo init -u $REPP_REMOTE -b $REPP_BRANCH -m $FILE_MANI --repo-url=$REPP_URL $EXTRA_OPTION"
        log "${REPP_CMD}"
    fi
    return 0
}



function reppinfo(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local manifest=${1:-${FILE_MANI}}

    pushd ${REPP_PATH}
    #oldIFS=${IFS}; IFS='';

    ##show repo dir path
    bar inline "repo path"
    log "${REPP_PATH}"

    ##get global variable and repo init command.
    reppget_repcmd info

    ##show manifest file with included sub manifests.
    bar inline "manifests"
    clog  "    <name of manifest>                                      <including branches>"
    reppshow_manifesttree ${manifest} 0
    
    ##show count of repository
    ### block infomation
    bar inline "misc information for this repositories"
    clog "number of repositories: " $REPP_COUNT

    clog "md5 sum for all repositories:"
    repo forall -j16 -c git log -1 --pretty=format:%H%n | md5sum

    ##show last synced time
    if [ -f .git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y .git/FETCH_HEAD );
    else clog "last manifest-synced time(check date of files below): "; ls -lct | tail -10;fi

    #IFS=${oldIFS}
    popd
}



function reppshow(){
## ---------------------------------------------------------------------------
# print information(changes, recent commits) of current repository#
    ##topic/working branch
    bar inline "repo branch: check if working branch existed (WAIT: It takes time) "
    repo branch

    ##run command "repo info"
    bar outline "it takes time to get information..."
    bar inline "repo status: uncommitted changes list saved to [ ${REPPFILE_STATUS} ]"
    echo "repo status" > ${REPPFILE_STATUS}

    ##remove colored output with 1) sed command, 2) --color option
    #repo status -j8 |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPPFILE_STATUS}
    repo --no-pager --color=never status -j8 >> ${REPPFILE_STATUS}

    ##list up repo commit, remote, branch, project, path
    reppfind |more -60

    ## repo info command is duplicated with reppfind functionality, so remove it.
    #bar inline "repo info: git repo/source path /branch rev saved to [ ${REPPFILE_STATUS} ]"
    #echo "repo info" >> ${REPPFILE_STATUS}
    #repo info |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPPFILE_STATUS}
    
    info "please check file [${REPPFILE_STATUS}]"
    warn "you can use this file to compare other repo."
}



function reppgo() {
## ---------------------------------------------------------------------------
# return git root path or return near git path
    local cmd="$1"

    case $cmd in
        root)  cd "${REPP_ROOT}"                    && return 0 ;;
        mani)  cd "${REPP_PATH}"                    && return 0 ;;
        git)   cd "$(gittcheck_gitpath print_y)"    && return 0 ;;
    esac

    local menu_items=('go ROOT　dir' 'go Manifests　dir' 'go GIT　root dir' 'exit')
    run_menu "${menu_items[@]}"
    case "$?" in
        1|11)  cd "${REPP_ROOT}"        ;;
        2|12)  cd "${REPP_PATH}"        ;;
    esac
    
    dest=.git
    local T=$(pwd)
    if [ "${REPP_ROOT}" = "${T}" ]; then
        echo "your are in repo root, use 'repp find @path' to list up all repositories" && return 0;
    fi

    ##find path to upper dirs until HOME or ROOT.
    dirs -c
    while [ "$T" != "$HOME" ] && [ "$T" != "/"  ]; do
        T=$PWD
        if [ -d "$T/${dest}" ]; then cd $T && return 0; fi
        pushd .. > /dev/null
    done

    ##not found in partents, now findout in child
    pushd -0 && dirs -c > /dev/null
    #echo "no .git found, stay HERE"

    local INPUT=( $(find ../.. -maxdepth 4 -name "${dest}" 2> /dev/null |head -60))
    #local INPUT=( $(reppfind @path) )

    if [ -n "${INPUT}" ];then run_menu "${INPUT[@]}" ;  fi
    cd "${menu_selected}/.."
}



function reppcommit(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local count=$1
    local out

    #echo "[$1][$count][$out]"
    if [ -z $count ]; then read -p "how many commit want to read? [#:number| enter:20| save:savefile| q(ctrl+c):exit]: " count; fi

    case $count in
        *[0-9]*) out='/dev/stdout';;
        '') out='/dev/stdout'
            count=20
            log "\nonly shows recent maxium 20 first-commits(git log -1) from all repository"
            ;;
        *)  out=${REPPFILE_COMMIT}
            count=${REPP_COUNT}
            log "\check file [$out], all -1 commits are saved"
            ;;
    esac

    echo "repo forall -c \"git log -1 --abbrev=6 --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%ad  %h  [%an] %d %s%n'\" |sort -r |head -${count:-50}"
    echo "> $out"

    bar outline "repo get recent commit"
    bar inline "date:YMD HMS]       [sha]   [author]      [commit title]                                            [git project                            branch"
    repo forall -j16 -c 'printf "%-100.100s %-80s \n" "$(git log -1 --abbrev=6 --date=format:"%Y-%m-%d %H:%M:%S" --pretty=format:"%ad  %h  [%an] %s")" "[${REPO_PROJECT}  ${REPO_RREV}]"' |sort -r |head -${count:-50} > $out
    #repo forall -c "git log -1 --abbrev=6 --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%ad  %h  [%an] %d %s%n'" |sort -r |head -${count:-50} > $out

}



function reppfind(){
## ---------------------------------------------------------------------------
# find git repository with path and project name with regexp
# $1 path or project
# usage: reppfind [path|project]
    local cmd="$1"
    
    bar inline "all repository info is save to ${REPPFILE_CSV}" > /dev/stderr
    clog "${REPPFILE_CSV} should be read by excel menu [data> text> select file> file open wizard]"
	if [ -f "${REPPFILE_CSV}" ]; 
	then info "reuse generated file [${REPPFILE_CSV}] or remove it";
	else repo forall -j1 -c 'printf "%.6s|%.7s|%-22.22s|%-74.74s|%.80s \n" "${REPO_LREV}" "${REPO_REMOTE}" "${REPO_RREV}" "${REPO_PROJECT}" "${REPO_PATH}"' > ${REPPFILE_CSV}
	fi

    case ${cmd} in
      comment) @로 시작하면 coloume을 출력
    ;; @rev)      echo "REPO_LREV";    awk -v FS="|" '{print $1}' ${REPPFILE_CSV}
    ;; @remote)   echo "REPO_REMOTE";  awk -v FS="|" '{print $2}' ${REPPFILE_CSV} |sort |uniq
    ;; @branch)   echo "REPO_RREV";    awk -v FS="|" '{print $3}' ${REPPFILE_CSV} |sort |uniq
    ;; @project)  echo "REPO_PROJECT"; awk -v FS="|" '{print $4}' ${REPPFILE_CSV} |sort
    ;; @path)     echo "REPO_PATH" > /dev/stderr;   awk -v FS="|" '{print $5}' ${REPPFILE_CSV} |sort
    ;; "")        printf "\e[1;33m%6.6s %7.7s %-22.22s %-74.74s %.80s \e[0m\n" "REPO_LREV" "REPO_REMOTE" "REPO_RREV" "REPO_PROJECT" "REPO_PATH"
                  cat ${REPPFILE_CSV} | tee  >(wc -l)
    ;; *)         printf "\e[1;33m%6.6s %7.7s %-22.22s %-74.74s %.80s \e[0m\n" "REPO_LREV" "REPO_REMOTE" "REPO_RREV" "REPO_PROJECT" "REPO_PATH"
                  cat ${REPPFILE_CSV} | grep -i --color=always ${cmd}
    ;;
    esac
}



function reppbranch(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest output file name
# $2 command
# $3 branch name or branch postfix
    local cmd=$1
    local name=$2

    case ${cmd} in
       ''|help) cat <<- EOF
				usage) repp branch help
				usage) repp branch list
				usage) repp branch create (shows commands) 
				usage) repp branch remove (shows commands) 
				usage) repp branch checkexist (shows commands & run default) 
				usage) repp branch checksum
				usage) repp branch compare 
EOF
    ;;    list) bar inline "show remote branches only including ${name} git project"
                showRUN repo --color=always forall -pc 'git ls-remote -h ${REPO_REMOTE} refs/heads/*${1}*' ${name} |more
    ;;  create|new) 
                under "please run one of these 'git push' commands to create branch in remote\n"
                info "<branch name> will be passing to 'git push' cmd in position of parameter \${1}\n"
                clog "infix:" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
                clog "prefix :" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}_\${REPO_RREV}' ${name:-<branch-prefix>}"                
                clog "postfix:" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${REPO_RREV}_\${1}' ${name:-<branch-postfix>}"
                clog "infix current git" "repo forall . -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
                clog "infix several git" "repo forall xxx/yyy ppp/qqq/rrr -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
    ;;  remove|delete) 
                under "please run one of these 'git push' commands to delete branch in remote\n"
                info "<branch name> will be passing to 'git push' cmd in position of parameter \${1}\n"
                clog "infix:" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
                clog "prefix :" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${1}_\${REPO_RREV}' ${name:-<branch-prefix>}"                
                clog "postfix:" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${REPO_RREV}_\${1}' ${name:-<branch-postfix>}"
    ;;  checkexist) 
                under "please run one of these 'git ls-remote' commands to check if branch is existed in remote\n"
                info "this command show all git project and show if the branch is existed"
                clog "prefix:" "repo forall -pc 'git ls-remote -h \${REPO_REMOTE} refs/heads/\$1_\${REPO_RREV}' ${name:-<branch-prefix>}"                
                clog "postfix:" "repo forall -pc 'git ls-remote -h \${REPO_REMOTE} refs/heads/\${REPO_RREV}_\$1' ${name:-<branch-postfix>}"
                
                bar inline "check exact ${name} remote branche is existed for all gits"
                repo forall -c 'printf "%80s " ${REPO_PROJECT}; git ls-remote -h ${REPO_REMOTE} refs/heads/$1' ${name} 
    ;;  checksum) ##don' use showRUN, md5sum includes showRUN command.
                bar inline "1. md5sum of local HEAD in all repository"
                repo forall -c 'git log -1 --pretty=format:%H%n' | md5sum

                bar inline "2. md5sum of remote all tracking branch in all repository"
                repo forall -c 'git ls-remote -h ${REPO_REMOTE} refs/heads/${REPO_RREV} | cut -f1' |md5sum
                #repo forall -c 'git ls-remote -h ${REPO_REMOTE} refs/heads/$1 | cut -f1' ${name:-${REPP_BRANCH}} |md5sum
    ;;  compare)  
                bar inline "generate branch info local, remote tracking branch, and specific remote branch"
                #repo forall -pc 'git diff --shortstat tagA tagB'
                fileA=$(mktemp); fileB=$(mktemp)
                repo forall -c 'printf "%s %s %s" $(git log -1 --pretty=format:%H%n) ${REPO_RREV} ${REPO_PROJECT}' > ${fileA}
                repo forall -c 'printf "%s %s %s" $(git ls-remote -h ${REPO_REMOTE} refs/heads/${REPO_RREV}) ${REPO_PROJECT}' > ${fileB}
                if [ -n "${name}" ]; then 
                    fileC=$(mktemp)
                    repo forall -c 'printf "%s %s %s" $(git ls-remote -h ${REPO_REMOTE} refs/heads/$1) ${REPO_PROJECT}' ${name} > ${fileC}
                fi
                
                info "please compare command: vimdiff ${fileA} ${fileB} ${fileC}"
    ;;       *) echo "usage) repp branch help"
    esac
}



function reppinit(){
## ---------------------------------------------------------------------------
# repo init helper
# $1 short repo init command
    ##option handle
    local cmd="$1"
    
    case $cmd in
       help|'')    cat <<-EOF
			ex) repp init -u ssh://${USER}@vgit.lge.com:29440/honda/linux/manifest -b tsu_25.5my_release
			ex) repp init -u https://android.googlesource.com/platform/manifest -b android-12.1.0_r1
			ex) repp init -b lampauto_r_release -m all.xml
			ex) repp init -u ssh://lamp.lge.com:29418/platform/manifest.git -b lampauto_r_release 
			     -m lampauto/lampauto-gm-recent.xml --reference=/data001/vc.integrator/mirror/lampauto_r_release/ 
			     --repo-url=ssh://lamp.lge.com:29418/repo/git-repo.git
			
EOF
            info 'please refer http://collab.lge.com/main/x/wY6wa'
            return 1
       ;; *) :
    esac
    
    
    #### parameter parsing
    local url revision manifest platform reference depth repo_url extra ret=0
    if ! options=$(getopt -l reference:,depth:,repo-url:,no-clone-bundle,partial-clone,no-tags,mirror -o b:m:p:u: -- "$@")
    then err 'please check "repo init --help"'; return 1; fi

    ##reset legacy positional parameter except $options
    eval set -- "$options"
    ##parse parameter from options using shift, which shifts the $1, $2, ... value sequencely 
    while true; do
        $DEBUG [$1][$2]    
        case $1 in
            ##when option has sub option, should shift 2 or just shift
            -u|--manifest-url)                                          url=$2;         shift 2;;
            -b|--manifest-branch)                                       revision=$2;    shift 2;;
            -m|--manifest-name)                                         manifest=$2;    shift 2;;
            -p|--platform)                                              platform=$2;    shift 2;;
            --reference)                                                reference=$2;   shift 2;;
            --depth)                                                    depth=$2;       shift 2;;
            --repo-url)                                                 repo_url=$2;    shift 2;;
            ##single option that need no additional sub value
            ##skip single option and remove getopt cmd
            -c|--current-branch)                                  extra="${extra} $1";  shift 1;;
            --no-clone-bundle|--partial-clone|--no-tags|--mirror) extra="${extra} $1";  shift 1;;
            --|*)                                                                  shift; break;;
        esac
    done

    #### parameter check
    ##if url has lamp and url is null, default url is lamp or return
    local sep='~'
    case ${url}$sep${revision} in
         $sep*lamp*) url="ssh://lamp.lge.com:29418/platform/manifest.git" ;;
         $sep*) err "-u manifest-url is necessary" ;;         
         *$sep*) : ;;
    esac
    ##if reference dir is existed, set reference as default.
    if [ -z "${reference}" ];then reference="${reference:-${path_mirror}/${revision}}"; [ ! -d "${reference}" ] && reference=''; fi
    ##issue https://github.com/OP-TEE/manifest/issues/157
    if [ -z "${repo_url}" ] && [ "${url}" != "${url/lamp/}" ];then repo_url='ssh://lamp.lge.com:29418/repo/git-repo.git'; fi
    
    #### run repo command
    ##url handle with replication server
    local file_info=$(mktemp)
    cmd_repoinit="repo init ${url:+-u ${url}} ${revision:+-b ${revision}} ${manifest:+-m ${manifest}} ${platform:+-p ${platform}} ${reference:+--reference=${reference}} ${depth:+--depth=${depth}} ${repo_url:+--repo-url=${repo_url}} ${extra} $@"

    ##make final repo init cmd
    bar outline "executed command:" >> ${file_info}
    printf "${cmd_repoinit}\n" >> ${file_info}

    ##execute cmd
    reppcheck_initcmd ${cmd_repoinit}
    if [ "$?" -eq 1 ]; then ret=1; fi

    ##show repo info
    bar outline >> ${file_info}
    cat ${file_info}; rm -f ${file_info}

    ##go next step or not
    if [ "$ret" -eq 0 ]; then info "to repo sync?:[enter:continue| ctrl+c:break] "; reppsync; 
    else repp connect help; fi
}



function reppsync(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
# ex) reppsync
    local njobs=$1
    local opt="${@:2}"
    
    if [ -z "$njobs" ]; then
        read -p "Please input job number to repo sync [enter:auto| number:ex)16| ctrl+c:exit]: " njobs;
        if [ -z $njobs ]; then  njobs=${NJOBS}; fi
    fi

    showRUN repo sync --no-tags --no-clone-bundle --fail-fast -cj${njobs:-16} ${opt}

    #"$@" 2> >(tee -a ${file_error})
    "$@" > >(tee -a ${file_error})
    case $? in
     0) ;;
     1) echo Generic error, usually because invalid command line options or malformed configuration;;
     2) echo Connection failed;;
     *) echo Unknown Error;;
    esac
}



function reppversion(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    echo "this version is expected to used, please check this version is matched to your local version"

    bar inline "expected"
    info "warning: this is the repo packaged with this project."
    $REPP_PATH/../repo/repo version

    printf "\n\n"
    bar inline "found"
    info "the local version currently you are using"
    bar inline "what"
    repo --version

    echo
    py_path=$(which python) >/dev/null
    py_ver="$(python --version 2>&1)"
    printf "[check] %s is working in [%s]\n" "${py_ver}" "${py_path}"

    bar inline "where"
    which repo
    which git

    local VER=$(repo --version | grep "repo version"  |tr -dc '[:digit:]')
    if (( ${VER:0:3} < 230 )); then
        under "you need to upgrade 'repo' to use full functionality\n"
		clog "1. remove old .repo:" rm -rf ${REPP_ROOT}/.repo
		clog "2. download to dir:" git clone https://gerrit.googlesource.com/git-repo ${path_mirror}/repo2 --mirror
		clog "3. replace repo and repo init:" [--repo-url=${REPP_URL}] --\> [${path_mirror}/repo2]
        pushd ${REPP_PATH} ; reppget_repcmd info ; popd
		clog "-->"
        echo "${REPP_CMD/${REPP_URL}/${path_mirror}/repo2}"
        #| sed -e 's#--repo-url=${REPP_URL}#--repo-url=${path_mirror}/repo2'
    fi
}



function reppcheck_gerritconnection(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
    echo "\$ $@" ;"$@"

    case $? in
       0) :
    ;; 1) echo Generic error, usually because invalid command line options or malformed configuration
    ;; *) echo Gerrit Connection Error
    esac
}



function reppcheck_sshconnection(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
    local server="$1" 
    local port="$2"
    local file_error="$(mktemp)"
    #echo "\$ ssh -T $1 -p $2 -vvv" ;
    showRUN ssh -T $server -p $port -vvv 2> $file_error

    case $(cat ${file_error}) in
        help)       echo "ssh connection error msg handler"
    ;; *success*)   echo "good, it works"
    ;; *Connection?refused*) 
                    bar outline "check log in ${file_error}"
                    grep -En "*Connection refused*" $file_error
                    
                    bar outline "check IP/PORT setting in (.ssh/config) with below"
                    ping $server -c2
    ;; *publickey*) err check publickey
    ;; *)           err "unknown error is occured, please check log [${file_error}]"
    esac

    #rm -f ${file_error}
}



function reppcheck_initcmd(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
    local file_error=$(mktemp)
    local ret=1 #return 1 is success, 0 is fail
    echo "\$ $@"
    time "$@" 2> >(tee -a ${file_error})
    #"$@" | tee -a ${file_error}


    case $(cat ${file_error}) in
        help)                           echo "init error handler"
    ;; *fatal*|*fail*|*error*)          err "check error log [${file_error}]"
    ;; *Permission?denied*publickey*)   err "check error permission"
    ;; *)                               ret=0
    esac
    
    [ "$ret" -eq 1 ] && echo "check http://collab.lge.com/main/pages/viewpage.action?pageId=1620608725"
    return $ret
}



function reppconnect(){
## ---------------------------------------------------------------------------
# check connection and report error
# $1 server
# $2 port
# $3 password
    local cmd="$1"
    case ${cmd} in 
        help) echo "repp connect vgit.lge.com 29420 tiger/tools tiger_release"; return 1;
    ;;     *) :
    esac


    local server_port=${REPP_REMOTE#*@}
    local server=${1:-${server_port%:*}}
    local port=${2:-$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')}
    local gitproject=${3:-${server_port#*/}}
    local branch=${4:-${REPP_BRANCH}}
    local ret


    #local port=$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')
    bar inline "step1: [local] check if ssh is installed"
    if [ -x "$(command -v ssh)" ]; then  log "ssh is installed in [$(which ssh)]"; else err "ssh is not installed, install it"; fi
    if [ -z $server ] || [ -z $port ];then warn "usage) repp connect vgit.lge.com 29418 tiger/tools tiger_release" && return 1;fi
    
    bar inline "step2: [remote] check if server tcp port is well listened"
    timeout 5 bash -c "</dev/tcp/$server/$port"
    if [ $? == 0 ];then echo "server $server over port $port is listened"; 
    else echo "server $server over port $port is not listened, please contact server manager"; fi

    bar inline "step3: [remote] check if sshd is serviced on this port $port "
    reppcheck_sshconnection $server $port

    bar inline "step4: [remote] check if gerrit service is valid"
    reppcheck_gerritconnection ssh $server -p $port gerrit version

    if [ -z $gitproject ];then info "usage) repp connect vgit.lge.com 29420 tiger/tools tiger_release" && return 1;fi
    if [[ "$gitproject" == *.git* ]]; then err ".git must be removed in [$gitproject]"; fi
    bar inline "step5: [remote] check if I can access git project"
    ret=$(ssh $server -p $port gerrit ls-projects --prefix ${gitproject})
    [ -n "$ret" ] &&  echo "can accessed [${ret}]" || err "check git project path [${gitproject}]"
    
    bar inline "step6: [remote] check if I can access the branch (default: master)"
    [ -z "${branch}" ] && branch="master" || branch="${branch}"
    ret=''
    ret=$(ssh $server -p $port gerrit ls-projects --prefix ${gitproject} -b ${branch})
    [ -n "$ret" ] &&  echo "can accessed [${branch}: ${ret% *}]" || err "check git branch is existed or permission allowed, contact project owner [${branch}]"
    
}



function reppserver(){
## ---------------------------------------------------------------------------
# find replication server
# $1 server-url
# $2 port-number
    local server_port=${REPP_REMOTE#*@}
    local server=${1:-${server_port%:*}}
    local port=${2:-$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')}

    ping $server -s 1016 -c 4 -A
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    if [ $? -ne 0 ]; then continue; fi
    ssh $server -p $port -o ConnectTimeout=2 -o ConnectionAttempts=1 gerrit show-caches
    if [ $? -ne 0 ]; then continue;fi
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    echo "please check 1) ipg/ewma from ping, 2) AvgGet from gerrit connection"
}



function reppfind_repodir(){
## ---------------------------------------------------------------------------
# find input-path up and down,
# $1:path name, $2:max depth to sub dir, $3:print or not
# ex) reppfind_repodir .repo 5
# ex) reppfind_repodir .git 2
    local T=$PWD
    local target=${1:-.repo}
    local down_depth=${2:-2} #default value:2
    local print=$3

    ## find in sub directory with depth
    readarray -t REPP_PATH_ALL < <(find . -maxdepth ${down_depth} -path "*${target}" |sort)
    case ${#REPP_PATH_ALL[@]} in
    1)  ## found sub dir
        REPP_PATH=$(readlink -f ${REPP_PATH_ALL[0]})
        ;;
    0)  ## not found, so find in parent directory upto $HOME
        while [[ "${PWD}" =~ "${HOME}" ]]; do
            if [ -d ${target} ]; then break; fi
            pushd ..
        done
        if [ -d ${target} ]; then REPP_PATH=$(readlink -f ${target});else REPP_PATH='';fi
        pushd -0 && dirs -c
        cd $T
        ;;
    *)  ## found multiple dir in sub dir
        if [ "$print" = "print_y" ]; then
            printf "subdir [%s]\n" ${#REPP_PATH_ALL[@]}
            printf "%s\n" ${REPP_PATH_ALL[@]};
        fi
        REPP_PATH=''
        ;;
    esac
}



function reppcheck_precondition(){
## ---------------------------------------------------------------------------
# pre-check
# $1 command
    ## find & move manifest dir
    local ret=1

    ## move to repo root
    reppfind_repodir .repo/manifests 5 print_n
    ## set variable REPP if manifest dir exists
    if [ -d "${REPP_PATH}" ];then
        pushd ${REPP_PATH}; REPP_ROOT=${REPP_PATH%/.repo*}
            #set global variable
        REPP_REMOTE=$(git remote -v |grep fetch |awk '{print $2}')
        REPP_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}| sed 's:.*/::')
        REPP_URL=$(cat ../repo/.git/config |grep url|sed 's/.*= \(.*\)/\1/')
        REPP_MIRROR=$(cat ../manifests.git/config |grep reference|sed 's/.*= \(.*\)/\1/')
        REPP_COUNT=$($REPP_PATH/../repo/repo list |wc -l)

        popd
        ret=0
    fi

    if [[ $ret -eq 1 && "$1" = "print_y" ]]; then
        printf "%s\n" ${REPP_PATH_ALL[@]};
        bar inline "WARNING"
        err "you are not in repo project, please check !";
    fi
    return $ret
}



function reppmenu(){
## ---------------------------------------------------------------------------
# show ui menu for this script
local MENU=(
"help: shows all command list"
"info: shows repository info such as manifest path, repo cmd, tree of manifests, etc
    ex) repp info, repp info default.xml, repp info event/manifest.xml"
"show: shows uncommited changes, top -1 commits, md5 sum, repo info for all repositories
    ex) repp show, repp show|more, repp show| grep build, cat ${REPPFILE_STATUS}"
"go: move path to repo root dir, manifest dir, git path nearby with similar depth.
    ex) repp go (selcetion menu popup)"
"commit: shows lastest commits(git log -1) from all repository (default 20)
    ex) repp commit, repp commit 4, repp commit log.txt(save as)"
"find: (list) search string in all [repo path] : [repo revision] : [repo name]
    ex) repp find, repp list|more, repp find build, repp list|grep -v build
    ex) repp find @rev [@rep| @remote| @branch| @git| @path)"
"init: repo init with automatic options
    ex) repp init -u ssh://${USER:+${USER}@}vgit.lge.com:29420/linux/manifest.git -b mib3_release
    ex) repp init -b lampauto_r_release -m lampauto/lampauto-gm-recent.xml
    ex) repp init -u https://android.googlesource.com/platform/manifest -b android-12.1.0_r1"
"sync: repo sync with optimized multi-job and options
    ex) repp sync, repp sync 8, repp sync 16 --force-sync(more options)"
"branch: repo push or repo ls-remote"
"mani: repo manifest handling"
"reset: reset all repositories to original state
    in case) use this, when repository has dirty commits."
"version: check repo & python version and provide repo upgrade"
"debug: debug REPO, REPP, GITT variable"
"connect: find accessibility for manifest git or normal git
    ex) repp connect, repp connect vgit.lge.com 29420 tiger/tools tiger_release
        repp connect [git-server] [port] [project]  [branch]"
"server: check delay from server or confirm the server status
    ex) repp server, repp server lamp.lge.com 29418"
)

    
printf ${green}
cat << PREFACE
==============================================================
 welcome to repp & gitt
 -------------------------------------------------------------
 command usage: ex) repp, repp info, repp show [default.xml]
 command usage: ex) gitt, gitt info, gitt show [currnet git]
 ex) repp find [string], repp sync 16 --force-sync, etc
 help: http://collab.lge.com/main/x/wY6wa
==============================================================
PREFACE
printf ${NCOL}


if [ "$1" = "help" ]; then 
    for m in "${MENU[@]}"; do clog "${m%%:*}" "${m##*:}"; done
    return 0; 
fi 

local COLUMNS=60
PS3=$'\e[00;35m=== Please input command! [enter:menu| number:choice| ctrl+c:exit] === : \e[0m'
select CHOICE in "${MENU[@]}"; do
    repp "${CHOICE%%:*}";
    if [ -n "$?" ]; then return 1;fi
done
}



function gittmenu(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
local MENU=(
"info: shows git path, gerrit info/url/remote, push command, commit info, sync time.
    ex) gitt info"
"show: shows git (default 15) commits history, diff history
    ex) gitt show, gitt show 20 --all"
"go: move to current .git path
    ex) gitt go"
"reset: clean with 'git reset --hard  && git clean -xdf'
    ex) gitt reset"
"find: branch, commit(author, rev, commit msg)
    ex) repp find, repp list|more, repp find build, repp list|grep -v build
    ex) repp find @rev [@rep| @remote| @branch| @git| @path)"
)



printf ${green}
cat << PREFACE
==============================================================
 welcome to gitt & repp
 -------------------------------------------------------------
 command usage: ex) gitt, gitt info, gitt show [currnet git]
 command usage: ex) repp, repp info, repp show [default.xml]
 ex) gitt find [string], gitt show, etc
 help: http://collab.lge.com/main/x/wY6wa
==============================================================
PREFACE
printf ${NCOL}

if [ "$1" = "help" ]; then 
    for m in "${MENU[@]}"; do clog "${m%%:*}" "${m##*:}"; done
    return 0; 
fi 

local COLUMNS=60
PS3=$'\e[00;35m=== Please input command! [enter:menu, number:choice, ctrl+c:exit] === : \e[0m'
select CHOICE in "${MENU[@]}"; do
    gitt "${CHOICE%%:*}";
    if [ -n "$?" ]; then return 1;fi
done
}




function gittcheck_gitpath(){
## ---------------------------------------------------------------------------
    ##readarray -t GITT_REMOTE < <(git remote -v |cut -f1|uniq)
    GITT_REMOTE=$(git remote|head -1)

    ##git config --get-regexp remote.$GITT_REMOTE |sort|grep -Ee "(projectname|review|url)"
    GITT_PROJECT=$(git config --get-regexp remote.*.projectname|cut -d' ' -f2)
    GITT_BRANCH=$(git branch -ar |grep -e '->' |sed -E 's#.*[/|>](.*)$#\1#')
    GITT_REVIEW=$(git config --get-regexp remote.*.review|cut -d' ' -f2|head -1)
    GITT_URL=$(git config --get-regexp remote.${GITT_REMOTE}.url|cut -d' ' -f2|head -1)
    GITT_PATH=$(git rev-parse --show-toplevel)
    if [ "$1" = "print_y" ]; then echo "${GITT_PATH}"; fi
}



function gittinfo(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# TODO: clone command
    local TEMP
    local review_gerrit=admin/repos
    bar inline "git path"
    if ! gittcheck_gitpath print_y ;then echo "we are not in git project" && return 1; fi

    ## "error: must check" must be checked!!!
    bar inline "show all remote info"
    clog ' remote:' ${GITT_REMOTE:="error: must check"}
    clog 'project:' ${GITT_PROJECT:="not defined"}
    clog ' branch:' ${GITT_BRANCH:="error: must check"}
    clog ' review:' ${GITT_REVIEW:="not defined"}
    clog '    url:' ${GITT_URL:="error: must check"}

    ##review system check
    case $(git config --get-regexp remote|cut -d' ' -f2) in
      help)             echo "site customization"
	;;*github.com*)     GIT_SITE=$(printf "https://%s" ${GITT_URL}|sed -E 's#^.*github.com:(.*.git)$#http://github.com/\1#')
	;;*vgit.lge.com*manifest*) case ${GITT_URL} in #remove starting string 'vgit.lge.com:29420/'
                              *vgit.lge.com:29420*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'na' ${review_gerrit}/${GITT_URL##*0/} ) ;;
                              *vgit.lge.com:29430*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'eu' ${review_gerrit}/${GITT_URL##*0/} ) ;;
                              *vgit.lge.com:29440*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'as' ${review_gerrit}/${GITT_URL##*0/} ) ;;
                              *vgit.lge.com:29550*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'adas' ${review_gerrit}/${GITT_URL##*0/} ) ;;
                              *vgit.lge.com:29999*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'devops_test' ${review_gerrit}/${GITT_URL##*9/} ) ;;
                              *) GIT_SITE="please add site custom setting" ;;
                              esac
	;;''|*)             GIT_SITE=$(printf "%s/${review_gerrit}/%s" $(echo ${GITT_REVIEW}|sed -E 's#(.*)[/]$#\1#') ${GITT_PROJECT} )
    ;;esac
    clog "review system site:" ${GIT_SITE} 
    clog "branch ${GITT_BRANCH} url on gitiles & gerrit:" 
    clog "gitiles: "${GIT_SITE/"${review_gerrit}"/"plugins/gitiles"}/+/refs/heads/${GITT_BRANCH} 
    clog " gerrit: "${GIT_SITE/"${review_gerrit}/"/"gitweb?p="}.git\;a=shortlog\;h=refs/heads/${GITT_BRANCH}

    bar inline "git push commands"
    TEMP=$(printf "git push $GITT_REMOTE HEAD:refs/heads/%s" ${GITT_BRANCH})
    clog " git push direct:" $TEMP
    clog " git push review:" ${TEMP/\/heads/\/for}

    bar inline "recent commit info"
    git show --stat --oneline HEAD

    bar inline "last synced time"
    #show last synced time
    oldIFS=${IFS}; IFS='';
    if [ -f ${GITT_PATH}/.git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y ${GITT_PATH}/.git/FETCH_HEAD );
    else clog "last manifest-synced date(check date of files below):" "\n$(ls -lct ${GITT_PATH}/.git| tail -1)";fi
    IFS=${oldIFS}
}



function gittshow(){
## ---------------------------------------------------------------------------
# show commit history by git log, or show commit by git show
# $1: "number of commit" or "commit sha1"
    #topic/working branch
    local depth="${1:-15}"
    
    if [[ ${#depth} -gt 3 ]] && [[ ${depth} =~ ^[0-9a-f]+$ ]]; then 
        bar outline "call native git"
        git show --stat ${depth}
        return 0 
    fi
    
    bar outline "gitt show is based on command: git log "
    bar inline "git commit history with option (to see all branche, gitt show 15 --all)"
    showRUN git log --decorate --graph -n${depth} --pretty=format:'%Cred%h -%C(yellow)%s %Cgreen(%ci) %C(blue)<%an>%Creset' 

    bar inline "git commit diff history"
    echo "--since(=after), --before(=until)"
    echo "6 hour, 2-day, 2-week, 1-month, 1-year"
    clog "ex:" "--since=2-weeks, --since=04:24, --before=6-hours, --after=2022-11-10 --before=2022-11-20-23"
    read -p "input add option [enter(default):--pretty="short" --name-only | input option with default]"

    git log --pretty="short" --name-only ${reply} |more -60
}



function formatprint(){
## ---------------------------------------------------------------------------

    local cmd=$*
    local index=0 line;

    #cmd preprocessor 
    case ${cmd} in 
                 help) echo "pre-process cmd"
    ;;   *git?status*) under "file changes list\n"
    ;;              *) echo "not found"
    esac

    readarray -t resultline < <( ${cmd[*]} )
    #resultline=("${cmd[*]}" "${resultline[@]}")
    #declare -p resultline

    ##read one line from array "${resultline[@]}"
    ##for line in "${resultline[@]}"; do while read item; do
    printf "%14s | %-14s -- \t%s\n" "indexed area" "working tree" "filelist"
    echo ${linemi}
    for line in "${resultline[@]}"; do
        #echo "KJK:[${line:0:1}][${line:1:1}]"
            ##custom handler for each item.
            case ${line:0:1} in
                help) echo "aaa"
            ;;    '#')   bar inline "file changes in branch: ${line}"
            ;;    '?')   printf "%14s | " "new" 
            ;;    '!')   printf "%14s | " "new"
            ;;    ' ')   printf "%14s | " ""            
            ;;    'A')   printf "%14s | " "added" 
            ;;    'M')   printf "%14s | " "modified"
            ;;    'D')   printf "%14s | " "deleted"
            ;;    'T')   printf "%14s | " "type changed"
            ;;    'R')   printf "%14s | " "renamed"
            ;;    'C')   printf "%14s | " "copied"
            ;;    'U')   printf "%14s | " "unmerged"
            ;;      *)   clog "must classfied"  "${line}"
            esac
            case ${line:1:1} in
                help) echo "aaa"
            ;;    '?')   printf "%-14s -- \t%s\n" "untracked" "${line:3}"
            ;;    '!')   printf "%-14s -- \t%s\n" "ignored" "${line:3}"
            ;;    ' ')   printf "%-14s -- \t%s\n" "untracked" "${line:3}"          
            ;;    'A')   printf "%-14s -- \t%s\n" "added" "${line:3}"
            ;;    'M')   printf "%-14s -- \t%s\n" "modified" "${line:3}"
            ;;    'D')   printf "%-14s -- \t%s\n" "deleted" "${line:3}"
            ;;    'T')   printf "%-14s -- \t%s\n" "type changed" "${line:3}"
            ;;    'R')   printf "%-14s -- \t%s\n" "renamed" "${line:3}"
            ;;    'C')   printf "%-14s -- \t%s\n" "copied" "${line:3}"
            ;;    'U')   printf "%-14s -- \t%s\n" "unmerged" "${line:3}"
            esac            
            #printf "%${width}s\n" "${item}"
            #index=$(( ++index % ${#cmd[@]} ))
    ##done <<< "${line}"; done
    done
}



function gittcommit(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: number of commit
# $2: other option such as --all (all branch)
    local cmd="$1"
    local opt="${@:2}"
    case $cmd in
       help)    cat <<-EOF
				usage) gitt commit help $1
				usage) gitt commit auto      #add auto commit				
				usage) gitt commit           #show commit info and diff with cached
				usage) gitt diff help        #show diff with specific rev
EOF
    ;; auto)    msg=$(date +"%y%m%d:%H%M")
                git commit -m "${msg}: ${1:-test}"
                git show --stat --oneline HEAD
                clog "[run]" "git push $GITT_REMOTE HEAD:refs/heads/${GITT_BRANCH}"
    ;; reset)   cat <<-EOF
				guide) git reset flow
				1) git log: check reset point in repository
				2) git reset <rev> <option>
				   current : repository index workspace| current status
				    --soft :      >>>>> index workspace| keep commit & file, retry from 'git push' 
				    --mixed:            >>>>> workspace| keep only  file, retry from 'git add' (default)
				    --hard :                     >>>>> | remove all, retry from scratch
				3) retry from each step
				flow) git log> git reset c3cef36787        > add modification> git add -A> git commit        > git push
				flow) git log> git reset c3cef36787 --soft > add modification> git add -A> git commit --amend> git push
				info) 'git reset --hard' restored by this 'git reflog > git reset --hard <relog rev>'
EOF
    ;;     *)   formatprint git status -s --porcelain
                printf "\n\n"
                read -p "to see diff with cached in detail [ enter:compare| line:compare with line | q(ctrl+c):break ]: " 
                case "$REPLY" in
                    help) clog "you can use with options:" "git diffi --line-numbers"
                ;;  line) git diffi --line-numbers
                ;;  *) git diffi
                esac
				if [ $? -ne 0 ];then echo "need to install 'sudo apt-get install icdiff'"; fi
    esac
}



function gittbranch_list(){
## ---------------------------------------------------------------------------
# show branch local & remote
# $1 all or filter
    local filter
    local opt="$1"

    ## list option must be wrapped with quoat ex) --list '*relese*'
    bar inline "branch local"
    echo "these branches are existed in local repository"
    clog "[local]" "could be synced by remote, if so, traced is marked"
    showRUN git branch -vv


    ## prevent globbing
    set -o noglob
    bar inline "sort by recently updated branches by new commit (newest from down)"
    echo "branch: remote tracked with filter (${filter:-all}) top 10 in local repository"
    echo "shows the branches downloaded when git fetch equivalent command was executed"
    clog "[not latest]" "could be latest by git pull"

    [ -z "${opt}" ] && filter="" || filter="--list *${opt}*"
    showRUN git branch -rvv --sort=committerdate ${filter} | tail -10


    [ -z "${opt}" ] && filter="*" || filter="*${opt}*"
    bar inline "lookup remote branch ${filer}"
    echo "branch: remote all with filter (${filter:-all}) by date top 10 in remote repository"
    clog "[always latest]" "read from remote live"
    warn "this command sort by date(--sort=-committerdate) is not correct, please watch out"
    set +o noglob
    
    showRUN git ls-remote -h ${GITT_REMOTE} refs/heads/${filter} | tail -10
    echo "get all branches and sort by date recent its commit"
    clog "> git fetch" 
    clog "> git for-each-ref --sort=committerdate refs/ --format='%(color:yellow)%(committerdate:short) %(color:red)%(objectname:short) %(color:green)%(refname:short) %(color:blue)%(authorname)%(color:reset) %(contents:subject)' "
    
    bar inline "find remote branch which are at same local HEAD"    
    git ls-remote -h ${GITT_REMOTE}| grep $(git log -1 --pretty=format:%H%n)
}



function gittbranch(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 command
# $2 branch name or branch postfix
    local cmd=$1
    local name=$2

    case $cmd in
       help) cat <<- EOF
				usage) gitt branch list <''|name-filter>
				usage) gitt branch create|new <name>
				usage) gitt branch delete|remove <name>
EOF
    ;; create|new)  if [ -z "${name}" ]; then err "branch name must be input" && return 1;fi
                showRUNQ git push ${GITT_REMOTE} HEAD:refs/heads/${name}
    ;; delete|remove)  if [ -z "${name}" ]; then err "branch name must be input" && return 1;fi
                showRUNQ git push ${GITT_REMOTE} --delete ${name}
    ;; list) gittbranch_list "${name}"
    ;; *) echo "usage) gitt branch help"
    ;; esac
}



function gittfind(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: regexp or string
# $2: file, dir and area
    local keyword="$1"
    local area="${@:2}"

    bar outline "search in commit with regexp(${keyword}) in files(${area})"
    
    source <(cat <<\EOL
    under "find only in committer in history\n"
    echo "ex) git log --author=".*${keyword}.*" ${area}"
    echo "ex) git log --owner=".*${keyword}.*" ${area}"
    showRUN git log --committer=".*${keyword}.*" ${area}

    under "find only in commit message of history\n"
    showRUN git log -i --grep="${keyword}" ${area}
    
    under "find in commit diff in history \n"
    echo "ex) git grep -e regexp1 --or -e regexp2"
    echo "ex) git grep -e regexp1 --and -e regexp2"
    showRUN git grep -n "${keyword}" ${area}
EOL
)

    ## show commit diff including keyword
    #git log -p -S"${keyword}" ${area}
     
    ## find string in function
    #under "find string in :fuction:file\n"
    #showRUN git log -L :"${keyword}":"${area}"
    ##run echo

}



function gittdiff(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 command
# $2 branch name or branch postfix
    local path="$1"
    local rev1="$2"
    local rev2="$3"
    
    local sep='~'

    case $path$sep$rev1$sep$rev2 in
    help*) cat <<- EOF
				usage) gitt diff help
				usage) gitt diff <path> <rev1> <rev2>
				ex) gitt diff HEAD <cached|HEAD^>                
				ex) gitt diff 
EOF
    ;;?*$sep?*$sep?*)  clog "3" "git diff"
    ;;?*$sep?*$sep)  clog "2" "git diff"
    ;;?*$sep$sep)  clog "1" "git diff"
                showRUN git difftool @:${path} @^:${path}
    ;;$sep$sep)  clog "0" "git diff"
				showRUN git difftool
    ;;      *)  clog "diff branch:" "in specific path"
                showRUN git difftool ${opt1}:${path} ${opt2}:${path}
    ;; esac
}



function gittreset(){
## ---------------------------------------------------------------------------
# reset git repositories
# $1 target

    local cmd=$1
    case ${cmd} in
        all)  repo forall -cj${NJOBS} 'git reset --hard ; git clean -xdf'
              echo "reset all repositories" 
    ;; ''|*)  if gittcheck_isgitproject; then
                showRUN git reset --hard; showRUN git clean -xdf
              else
                warn "this is not a git directory";
              fi
    esac
}



function gitt(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
local ret=0
if ! gittcheck_gitpath print_n;then err "we are not in git project" && return 1; fi

case "$1" in
    ##$1:below ${@:2}:parameters
          help)     gittmenu help
    ;;      '')     gittmenu "${@:2}"          
    ;;    info)     gittinfo 
    ;;    show)     gittshow "${@:2}"
    ;;      go)     cd "${GITT_PATH}"     
    ;;  commit)     gittcommit "${@:2}"
    ;;  branch)     gittbranch "${@:2}"        
    ;;    find)     gittfind "${@:2}"
    ;;    diff)     gittdiff "${@:2}"
    ;;   reset)     gittreset "${@:2}"
    ;;   debug)     reppdebug "${@:2}"
    ;;       *)     bar outline "call native git"
                    git "${@}";;
esac
return $ret
}



function repp(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
local ret=0

case "$1" in
         init)  : 
       ;;help|server|connect)  reppcheck_precondition print_n
       ;;   *)  reppcheck_precondition print_y  
                [ "$?" -ne 0 ] && return 1
esac

case "$1" in
     ##$1:cmd        ${@:2}:parameters
       help)        reppmenu help
    ;; '')          reppmenu "${@:2}"
    ;; info)        reppinfo  "${@:2}"
    ;; show)        reppshow "${@:2}"  
    ;; go)          reppgo "${@:2}"
    ;; commit)      reppcommit "${@:2}"
    ;; find|list)   reppfind "${@:2}"
    ;; init)        reppinit "${@:2}"
    ;; sync)        reppsync "${@:2}"
    ;; branch)      reppbranch "${@:2}"
    ;; mani)        reppmani "${@:2}"
    ;; reset)       gittreset all 
    ;; version)     reppversion "${@:2}"
    ;; debug)       reppdebug "${@:2}"
    ;; connect)     reppconnect "${@:2}"
    ;; server)      reppserver "${@:2}"
    ;; *)           bar outline "result of native repo"
                    repo "${@}"
esac
return $ret
}



function reppdebug(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'
    
    if ! gittcheck_isgitproject; then pushd ${REPP_PATH}; fi
    gittcheck_gitpath print_n ; 
    popd
    
    source <(cat <<\EOL
        bar inline "GITT_VARIABLE && REPP_VARIABLE"
        for var in \
        '${GITT_PROJECT}' '${GITT_REMOTE}' '${GITT_BRANCH}' '${GITT_REVIEW}' '${GITT_URL}' '${GITT_PATH}' \
        '${REPP_PATH}' '${REPP_ROOT}' '${REPP_REMOTE}' '${REPP_BRANCH}' '${REPP_URL}' '${REPP_MIRROR}' '${REPP_COUNT}'
        do
           dlog "$var\t" $(eval echo $var)
        done

        bar inline "[${GITT_PROJECT}] print repo variable"
        showRUN repo forall . -c 'echo ${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'

        bar inline "[all repo] print repo variable"
        dlog                '${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'
        repo forall -c 'echo ${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}' | more -60
EOL
)
    ##run echo
}



##============================================================================
## Main
##============================================================================
GITT_REMOTE= &&GITT_PROJECT= &&GITT_BRANCH= &&GITT_REVIEW= &&GITT_URL= &&GITT_PATH=
REPP_PATH= &&REPP_ROOT= &&REPP_REMOTE= &&REPP_BRANCH= &&REPP_URL= &&REPP_MIRROR= &&REPP_COUNT= &&REPP_CMD=
REPP_PATH_ALL=()
REPPFILE_STATUS={REPP_ROOT}/repp.status
REPPFILE_COMMIT={REPP_ROOT}/repp.commit
REPPFILE_CSV={REPP_ROOT}/repp.csv
REPPFILE_XML=repp.csv


(return 0 2>/dev/null) && sourced=1 || sourced=0
if [ $sourced -eq 0 ]; then repp $@;
else  ##if sourced
    echo "[WELCOME] repp & gitt utility is applied for current shell"
    ##hide local function, need to implements
fi

