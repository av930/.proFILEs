#!/bin/bash
## ==========================================================================
##  readme    : repo wrapper utility
##  mail      : joongkeun.kim@lge.com, av9300@gmail.com
## ==========================================================================
###---------------------------------------------------------- DEBUG OPTION
#DEBUG=["echo -e"|:], : means no-operation
#DEBUG=[ : | "printf ${RED}%s${NCOL}\n" ]
DEBUG=:
#DEBUG="printf ${RED}%s${NCOL}\n"

PATH_FULL=$(realpath "$BASH_SOURCE")
PATH_DIR="${PATH_FULL%/*}"
PATH_FILE="${PATH_FULL##*/}"
DIR_CURR=$(pwd)
LC_ALL=C.UTF-8
$DEBUG "[$_][$BASH_SOURCE][$0][${PATH_FULL}][${PATH_DIR}][${PATH_FILE}]"


if [ -e "${PATH_DIR:-.}/prelibrary" ]; then source ${PATH_DIR:-.}/prelibrary;
else source ${proFILEdir}/tools/prelibrary; fi
## custom builtin variable setting
ACCOUNT=vc.integrator
PATH_MIRROR="/data001/${ACCOUNT}"/mirror


##------------------------ alias & oneline func ------------------------------
##============================================================================
#### when running script, register git alias automatically
## load direct from below
source <(cat <<'EOF'
## alias
    #suppress repo update log: alias repp='_repp(){ repp $@ 2> >(sed '/.../,/cp/d') ;}; _repp'
## git alias
    git config --global alias.alias 'config --get-regexp ^alias\.'
    git config --global alias.st 'status'
    git config --global alias.ci 'commit --verbose'
    git config --global alias.loga 'log --color=always --oneline --decorate --graph -n 20 --all'
    git config --global alias.logo "log --color=always --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset %C(blue)<%an>%Creset' --abbrev-commit --date=relative"
    git config --global alias.tagcur 'describe --tags --abbrev=0 --match'
    git config --global alias.diffc 'difftool -t bc'
    git config --global alias.diffv 'difftool -t vimdiff'
    git config --global alias.difft 'difftool --dir-diff -t vimdiff'


## NEEDTO: sudo apt-get install icdiff
    #git config --global alias.diffi "difftool --extcmd 'icdiff'"
     git config --global alias.diffi "!_gitdiff() { git difftool --extcmd 'icdiff'; }; _gitdiff"
    #git config --global alias.diffi '!_gitdiff() { git difftool --extcmd "icdiff $@"; }; _gitdiff' --replace-all
     git config --global alias.clear "!_gitclear() { git reset --hard $1; git clean -xdf; }; _gitclear"
EOF
) 2> /dev/null


## oneline function defined below
## suppress print path
pushd() { command pushd "$@" > /dev/null ;}
popd() { command popd "$@" > /dev/null ;}
NJOBS=$(( $(nproc --all) / 4))
gittcheck_isgitproject(){ git -C "$1" rev-parse --is-inside-work-tree &> /dev/null ;}

##--------------------------- Menu Functions --------------------------------
##============================================================================

function tempfunc(){
## ---------------------------------------------------------------------------
# template for bash fuction
# $1 parameter explanation
# $2 parameter explanation
    local cmd=$1
    local opt=$2

    case $cmd in
       help) cat <<- EOF
				usage) gitt branch list <''|name-filter>
				usage) gitt branch create|new <name>
				usage) gitt branch delete|remove <name>
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) echo "default functionality"
    ;; esac
}



## repp ======================================================================================================================
function reppshow_manifesttree(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest file name
# $2 treedepth to display sub manifest
    local file
    local manifest=$(mktemp)
    local path='|--|--|--|--|--|--'
    local treedepth=${2:-1}
    local string=$3

    cat $1| sed '/<!--.*-->/d' | sed '/<!--/,/-->/d' > ${manifest}

    ##print name of manifest
    printf "%s$1 \n" "${path::${treedepth}}"

    (( treedepth=treedepth+3 ))
    if [ -n "${string}" ] ; then
        if grep -ne "$string" ${manifest}; then wave; fi
    else
    ##print name of branches not revision
    cat ${manifest}| sed -n 's/.*revision="\([^ |\t]*\)".*/\1/p'| grep -v '^[a-f0-9]*$'| sort| uniq| xargs -I {} printf "%60s {}\n"
    ##print only 10 revision for notice
    cat ${manifest}| sed -n 's/.*revision="\([^ |\t]*\)".*/\1/p'| grep -e '^[a-f0-9]*$'| head -10| xargs -I {} printf "%60s {}\n"
    fi

    ##sub manifests
    cat ${manifest}| sed -nE 's/.*include name="([^"]*)".*/\1/p' | \
    while read -r file; do
        if [ -n "${file}" ];then reppshow_manifesttree ${file} ${treedepth} ${string}; fi
    done
    (( treedepth=treedepth-3 ))
}



function reppmani(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest output file name
# $2 command
# $3 branch name or branch postfix
    local cmd=$1
    local item=$2
    local str=$3
    local filter=$4

    case ${cmd} in
        info|gen|find|change|diff|diffcheck) if [[ ! "${PWD}" =~ "${REPP_PATH}" ]]; then
            warn "you must move to manifest dir, path is changed automatically ${REPP_PATH}"
            info "you can go by 'repp go mani' or 'git go mani'"
            cd ${REPP_PATH}; fi
        ;; *)
    esac

    case ${cmd} in
        init)   ##remove repp.csv and all related files
                if  ! repp_initdb init ; then
                    warn "DB is not generated well, please check error"
                    bar inline "${REPPFILE_TXT}"
                    echo "you can use this for simple use, it generated only from manifest git"
                    #repo manifest --json 2> /dev/null | jq -jr '.project[]|.revision,"|",.groups,"|",.remote,"|",.upstream,"|",."dest-branch","|",.name,"|",.path,"|\n"' > ${REPPFILE_TXT}
                fi
    ;;    go)   gittgo mani
    ;;  find)   reppshow_manifesttree ${manifest:-${REPPFILE_MANI}} 0 ${item}
    ;;  info)   ##get global variable and repo init command.
                reppget_repcmd info

                bar inline "current manifest file"
                echo "${REPP_ROOT}/.repo/${REPPFILE_MANI}"

                ##show manifest file with included sub manifests.
                bar inline "manifests"
                clog  "    <name of manifest>                                      <including branches>"
                reppshow_manifesttree ${manifest:-${REPPFILE_MANI}} 0
                info "to see specific xml, run 'repp info <xml>'"

                ##show count of repository
                ### block infomation
                bar inline "misc information for this repositories"
                clog "number of repositories: " $REPP_COUNT

                bar inline "recently changed history [git log 10]"
                showRUN git log -10 --name-status --abbrev=6 --date=format:"%Y-%m-%d %H:%M" --pretty=format:"%C(yellow)%ad %C(red)%h %C(green)%s%C(reset)"

                bar inline "file name & only modified file, not add/delete files (press 'q' to stop)"
                info "you can find add/delete git projects here recent 12 weeks"
                showRUNQ "git log -p --color=always --pretty=oneline --diff-filter=M --since=12-weeks  |more -30"

    ;;   gen)   bar inline "current manifest.xml [${REPPFILE_MANI}] regnerated with option"
                echo 'ex) <project groups="qcos" name="common/nad/ntc" path="nad/tsu-src/ntc" remote="devops" revision="master"/>'
                echo "upper format will be generated by no option(enter)"
                clog "no-option" "generate revision as branch"
                clog "-r" "generate revision as HEAD rev"
                if (( "$(reppversion ver)" > 230 )); then
                    clog "-r --suppress-upstream-revision --suppress-dest-branch" "generate revision without upstream-revision or dest-branch"
                    clog "-m default.xml" "use default.xml as input"
                    clog "--json" "generate manifest to json format"
                fi
                read -p "input option :" opt
                if [[ ! "${opt}" =~ "--json" ]] || [[ ! "${opt}" =~ "-o" ]]; then opt+=" -o ${item:-${REPPFILE_XML}}"; fi
                showRUN repo manifest ${opt} 2> /dev/null

    ;;change)   under "please run one of these 'repp mani change' commands to generate cmd to change manifest easily\n"
                clog "usage)" "repp mani change <revision|name|path|remote|upstream|dest-branch|groups|dest|src|etc> <change-string> <filter>"
                clog "\n   verifiy :" "cat \${REPPFILE_XML} | <cmd> | grep --color=auto ${str}"
                clog "   preview :" "icdiff <( cat \${REPPFILE_XML} ) <( <cmd> )\n"
                cat <<- CHANGE
				   flow(input cmd): $ repp mani change remote vgit_new vgit_as
				   flow(generated): select postfilter cmd $ cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#'
				   flow(verify   ): cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#' | grep --color=auto vgit_new
				   flow(compare  ): $ icdiff <( cat ${REPPFILE_XML} ) <( cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#' )
				   flow(ok? save ): $ cat repp.xml | sed -E 's#remote="([^"]*vgit_as[^"]*)"#remote="\1vgit_new"#' > repp.xml
CHANGE

                bar inline "repp mani change revision migration_today"
                clog "change field<revision> to value<migration_today>" "generate 3 type <cmd>"
                cat <<- CHANGE
				     infix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="${str}"#'
				    prefix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="${str}\1"#'
				   postfix : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*)"#${item}="\1${str}"#'
CHANGE
                printf "\n"
                bar inline "repp mani change remote vgit_new vgit_as"
                clog "change field<remote> its contents is matching <vgit_as> to value <vgit_new>" "generate 3 type <cmd>"
                cat <<- CHANGE
				  infilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="${str}"#'
				 prefilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="${str}\1"#'
				postfilter : cat ${REPPFILE_XML} | sed -E 's#${item}="([^"]*${filter}[^"]*)"#${item}="\1${str}"#'
CHANGE

    ;;  diff)   bar inline "compare 2 different manifests what project is changed"
                clog 'ex)' 'repp mani diff <old manifest.xml> <new manifest.xml>'
                clog 'ex)' 'repp mani diff event/230426_mig.xml event/230712_upstream.xml'
                reppdiff diff "$item" "$str" "$filter"

    ;;  diffcheck)
                bar inline "after repp mani check, if branch changed, find missing commits (this is useful in migration)"
                reppdiff check "$item" "$str" "$filter"

    ;; help|*)   cat <<- EOF
				usage) repp mani info                                     #show manifest info,structure,log,diff
				usage) repp mani init                                     #force regenerate db by current manifest not reusing
				usage) repp mani go                                       #cd to manifest dir
				usage) repp mani gen <outfile>
				   ex) repp mani gen current.xml                          #default out: ${REPPFILE_XML}
				usage) repp mani find <string>                            #find string in current manifest-tree
				usage) repp mani change <revision|name|path|remote|upstream|dest-branch|groups|dest|src|etc> <str> <filter>
				   ex) repp mani change                                   #show command how to change manifest in detail, not change directly
				   ex) repp mani change remote vgit_new                   #show command: change "any string" to "vgit_new" in all remote field
				   ex) repp mani change remote vgit_new vgit_as           #show command: change only from "vgit_as" to "vgit_new" in remote field
				usage) repp mani diff event/old.xml <new.xml>             #compare old manifest to new manifest
				   ex) repp mani diff event/compare.xml                   #compare history event/compare.xml to current.xml
				   ex) repp mani diff default.xml event/230712_mig.xml    #compare history from 2 different manifests
				   ex) repp mani diff                                     #can choose manifest in recent 3 weeks, comparing to current manifest
				usage) repp mani diffcheck                                #post analysis after 'repp mani diff' for missed commits checking
EOF
    ;; esac
}



function csv_fromlnx_towin(){
## ---------------------------------------------------------------------------
## linux CSV file을 windows CSV file로 변경한다.
## ""로 묶여있는 field(여러줄가능)의 LF는 유지하고, 그외의 LF는 CRLF로 변경한다.
local tfile=$(mktemp)
awk 'BEGIN {
    RS=""
    FPAT="([^,\"]+)|(\"([^\"]|\"\")*\")|";  # 필드 패턴 정의
    OFS=",";                                # 출력 필드 구분자
    ORS="\r\n";                             # 출력 레코드 구분자 (CRLF)
}{
    for (i = 1; i <= NF; i++) {         # 필드가 double quote로 묶여있지 않은 경우에만 gsub 수행
         if ($i !~ /^".*"$/) {
            gsub(/\r?\n/, "\r\n", $i);  # CRLF 아닌것만 LF를 "\n"으로 변경
        }
    }
    print $0;                           # 수정된 레코드 출력
}' "$1" > $tfile
cat $tfile > "$1"

diff -uN $tfile "$1"
}



function reppforgen_csv(){
## ---------------------------------------------------------------------------
# repp forall gen으로 기본 csv를 생성하거나
# 입력된 repp forall <project -c 'cmd' option> 분석하여, reppforall.csv, repp_inscript.sh 파일을 생성한다.

    under "Welcome to reppforall generator\n"
    clog "${REPPFILE_FORALL},\n${REPPSCRIPT_IN}" "will be generated, please wait a few seconds"

    local ret=0 cmd=$1
    local tempf=$(mktemp)
    ## repo forall . -cj4 ' ~~~ ' 명령어 parsing
    reppcheck_initvar reppgitt

    ## reppforall.csv heading 생성
    ## (CSV file을 처리하기 위해 최종 처리전까지는 windows format으로 처리)
    ## 추후 REPO_UPSTREAM,REPO_DEST_BRANCH가 필요하면 $4,$5를 넣어야 한다.
    printf "http://collab.lge.com/main/display/~joongkeun.kim/reppforall,Refer please,,REPPSCRIPT_V1,NONE,REPPSCRIPT_V2,NONE,\r\n\
,,,REPPSCRIPT_PRE,NONE,REPPSCRIPT_POST,NONE,\r\n\
REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_RREV,REPO_PROJECT,REPO_PATH,REPP_SCRIPT,\r\n" > $REPPFILE_FORALL

    ## repoforall.csv의 body를 생성
    if [ ! "$cmd" = "gen" ]; then
        local arg opt pro sep cmd=
        for arg in "$@"; do
            $DEBUG "[$arg]"
            case $arg in
               ## -c를 기준으로 cmd와 project를 구분한다.
            -*c*)   [ -z "$pro" ] && { sep="$arg"; pro="$opt"; [ -z "$pro" ] && pro=all; opt= ; } || { opt+="$arg"; continue; }
            ;; ## '~~~'로 감싸진 command를 추출한다.
            *\ *) cmd=$(printf "'%s' " "$arg"); cmd+="$opt"; opt=
            ;; ## 들어오는 모든 text는 먼저 opt에 저장된다.
            *)    opt+=$(printf "%s " "$arg");
            esac
        done

        ## '~'로 묶인것이 없다면 모두 cmd로 처리한다.
        [ -z "$cmd" ] && { cmd="$opt"; opt=""; }

        ## 명령어에 존재하는 single quote 처리
        #cmd의 맨앞에 single quote가 존재할때만, 맨앞/맨뒤에 single quote를 제거한다.
        cmd=${cmd#\'} && cmd=${cmd%\'*}
        printf "%s\n" "${cmd}" > $REPPSCRIPT_IN
        chmod +x "$REPPSCRIPT_IN"

        [ "$pro" = ". " ] && pro=${GITT_PROJECT}  #set as current git project
        [ "$pro" = "all" ] && pro='.'             #match all git project

        ## 현재는 case2로 parsing하고 있음. case1경우에는 복잡도가 높아 case2로 개선함
        ##repp forall tiger/services/ethmgr tiger/metas/meta-tiger  -cj1 bash -c '[ -z "${REPO_RREV}" ] && echo ${REPO_PROJECT}' $USER $PWD
        ##pcase2)      project                                        sep cmd

        $DEBUG "pro~~~~~~" "$pro"; $DEBUG "sep~~~~~~" "$sep";
        $DEBUG "cmd~~~~~~" "$cmd"; $DEBUG "opt~~~~~~" "$opt"; $DEBUG "script~~~~~~" "$REPPSCRIPT_IN"
        [ -z "$sep" ] && { err "please check your command, you must input 'repp forall [-cj4]'"; return 1; }

        ## csv에서 repo forall로 들어온 project만 추출하여 reppforall.csv 생성
        for arg in $pro; do
            ## project가 존재하면 추출하고, 명령어(script)도 같이 기술한다.)
            #cat "${REPPFILE_CSV}"| awk -F'|' -v vp="$arg" -v vc="$pre '$REPPSCRIPT_IN' $opt" '$7 ~ vp {print $0 script}' >> "$tempf"
            ##awk에서 success or failure를 return하려면 아래와 같이 직접적으로 exit 구문으로 명시해줘야 한다.
            ##pcase1 cat "${REPPFILE_CSV}"| awk -F'|' -v vp="$arg" -v vc="$pre $REPPSCRIPT_IN $opt" '$7 ~ vp {print $0 vc; found=1} END {if (found) exit 0; else exit 1}' >> "$tempf"
            ##pcase2
            cat "${REPPFILE_CSV}"| awk -F'|' -v vp="$arg" -v vc="$REPPSCRIPT_IN" '$7 ~ vp {print $0 vc; found=1} END {if (found) exit 0; else exit 1}' >> "$tempf"
            if [ $? -ne 0 ]; then err "project [$arg] is not existed, if force to continue, edit direct : ${REPPFILE_FORALL}"; return 1; fi
        done
    fi
    ## excel에서 편집할수 있도록 repoforall.csv body 생성
    ## txt 파일인 $REPPFILE_CSV로 부터 sha-code를 6자리로 줄이고
    ##                                구분자인 '|'와 콤마(,)를 포함하는 파일을
    ##                                구분자로 ','로 하고 콜론(:)을 포함하는 csv로 file로 만드는 작업
    #cat "$REPPFILE_CSV"| colrm 7 40| awk 'BEGIN{FS="|"; OFS=","; ORS="\n";}{print "\042\042\075\042"$1"\042","\042"$2"\042,"$3","$6","$7","$8}' >> "$REPPFILE_FORALL"
    #cat "$REPPFILE_CSV"| colrm 7 40| awk 'BEGIN{FS="|"; OFS=",";}{gsub(/,/,":",$2);print $1","$2","$3","$6","$7","$8}' >> "$REPPFILE_FORALL"
    ##RS='\n'는 ctrl+M을 제거하고 \r\n로 대체하기 위해서 사용
    [ ! -s $tempf ] && cp "${REPPFILE_CSV}" $tempf
    cat $tempf| awk 'BEGIN{FS="|"; OFS=","; ORS="\r\n"}{gsub(/,/,":",$2);print "\042\042\075\042"$1"\042",$2","$3","$6","$7","$8","$9","}' >> "$REPPFILE_FORALL"
    ## column 2에 존재하는 :를 ,으로 바꾼다.
    #cat $tempf| awk 'BEGIN{FS="|"; OFS=","; ORS="\r\n"}{if ($2~/,/) {$2="\""$2"\""};print "\042\042\075\042"$1"\042",$2","$3","$6","$7","$8","$9","}' >> "$REPPFILE_FORALL"

    [ -f "$REPPFILE_FORALL" ] && bar inline "$REPPFILE_FORALL"
    [ -f "$REPPFILE_FORALL" ] && clog "${REPPFILE_FORALL##*/}:" "you can put your commands ${REPPFILE_FORALL##*/} and then run by 'repp forall'"
    [ -f "$REPPSCRIPT_IN" ] && bar inline "$REPPSCRIPT_IN"
    [ -f "$REPPSCRIPT_IN" ] && clog "${REPPSCRIPT_IN##*/}:" "${REPPFILE_FORALL##*/} can call script ${REPPSCRIPT_IN##*/} by describing."
    return 0
}



function reppforgen_sh(){
## ---------------------------------------------------------------------------
## reppforgen_sh 뒤에 오는 모는 parameter로 script를 만들어준다.
## 이를 위해 먼저, 입력된 command의 특수문자나 잘못된 quote나 error 구문이 있는지 검사하고 수정한다.
## '~~~', "~~~", ?를 제거하고 명령구문이 올바른지 test해준다.
## 생성된 명령을 CRLF를 제거하여 $REPPFILE_OUT에 넣어 실행할수 있도록 만들어 놓는다.
#echo "${cmd}"| awk 'BEGIN {RS=""; FS="\n"} {gsub(/^['\''"]|['\''"]$/, ""); print}'   #"~~~"만 삭제
#"~~~", '~~~'둘다 삭제
    ##RS=""//여러줄을 하나의 record로 처리; FS="\n" //한줄을 하나의 field로 처리
    wave
    [[ -z "$REPPFILE_OUT" ]] && { err "generated file name must be ready"; return 1; }
    [ "${@}" = "NONE" ] &&  return 0;
    local cmd=$(echo "${@}"| awk 'BEGIN {RS=""; FS="\n"} {gsub(/^["'\''"]|["'\''"]$/, ""); print}')

    #declare -p cmd
    if [ -z "${cmd%%\'*}" ]; then
        err "remove wrapping single quotes('~~~') from command\n"
        wave; echo $cmd; return 1
    fi
    if [ -z "${cmd%%\"*}" ]; then
        err "remove wrapping double quotes(\"~~~\") from command\n"
        wave; echo $cmd; return 1
    fi
    if  echo "${cmd}" |grep '? '; then warn "remove special character from command" ; fi
    if ! echo "${cmd}" | bash -n; then err "input command is not correct!"; return 1; fi

    ## 문제가 없으면 REPPFILE_OUT을 생성한다.
    echo "${cmd}" > $REPPFILE_OUT; #"~~~", '~~~'둘다 삭제
    sed -i 's/\r$//' "$REPPFILE_OUT"
}



function reppforall(){
## ---------------------------------------------------------------------------
# repp forall -c일때는 reppforgen로 연결하고
# repp forall 일때는 reppforall.csv 를 읽어 실행한다.

    REPPFILE_OUT=
    local fileincmd=$(mktemp)
    local opt

    #terminal에서 직접함수 호출하는것을 방지
    if [[ "${FUNCNAME[1]}" == "" || "${FUNCNAME[1]}" == "main" ]]; then warn "You can use 'repp forall'"; return 1; fi
    if [[ "$@" =~ '`' ]]; then
        clog "backquote(\`)" "is not supported 'repp forall' command"
        err "you can't use backquote, use \$(cmd)" instead of \`cmd\`;
        return 1;
    fi
    ## change from csv file with separator ',' but containing semi-colon in item.
    ##          to txt file with separator '`' but containing seme-colon in item.

    local cmd=$1
    case $cmd in
        help) cat <<- 'EOF'
			usage) repp forall gen                                               #generate default reppforall.csv to edit command
				    1. 'repp forall gen' will save reppforall.csv into .repp dir in root path
				    2. put muli-cmds in REPO_SCRIPT column like cmd1;cmd2|cmd3;cmd4;
				    3. run by 'repp forall'. it will ask how to run it ex) run all at once or run 1 by 1.

			        info) repo variables: $REPO_LREV, $REPO_GROUP, $REPO_REMOTE, $REPO_RREV, $REPO_PROJECT, $REPO_PATH, $REPO_ROOT
			              #not supported: REPO_I, REPO_COUNT, REPO_INNERPATH, REPO_OUTERPATH, REPO_UPSTREAM, REPO_DEST_BRANCH
			usage) repp forall -c '<cmd>'                                        #generate reppforall.csv and repp_inscript.sh including <cmd>
			usage) repp forall testcase                                           #copy reppforall.test.csv to reppforall.csv to test repp forall functionality
			usage) repp forall                                                   #run repo forall by using reppforall.csv
			usage) repp forall g|go|goo                                          #run repo forall without asking, with No-info, Project, Project&Command

			guide) example cmds REPO_SCRIPT column in reppforall.csv
			        echo REPO_PROJECT|xargs -n1 -I% sh -c 'echo $%'              #xargs
			        echo ${REPO_REMOTE} ; echo ${REPO_RREV}                      #multiple commands with ;
			        echo ${REPO_REMOTE} |grep -o vgit; echo ${REPO_REMOTE}       #multiple commands with |
			        echo ${REPO_REMOTE} && echo ${REPO_RREV}                     #multiple commands with &&
EOF
            return 0
        ;; testcase) local sfile="$PATH_DIR/reppforall.test.csv"
                cat "$sfile"| awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="\n";}  NR>=1 && NR<=3 {printf "%s\r\n", $0}' > "$REPPFILE_FORALL"
                for i in $(seq 4 1 $(awk 'BEGIN{RS="\r\n"} END{print NR}' "$sfile") ); do
                    awk 'BEGIN{FS="|"; RS="\n"; OFS=","; ORS=",";}       NR=='$i' {gsub(/,/,":",$2);print $1","$2","$3","$6","$7","$8}' ${REPPFILE_CSV}
                    awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="\r\n";}  NR=='$i' {if ($7!="") {print $7} else {print ""}}'             "$sfile"
                done >> "$REPPFILE_FORALL"
                info "Now, you can test repp forall functionality by 'repp forall' command"; return 0
        ;;  g|go|goo) opt=$cmd
        ;; '') :
        ;;  *) reppforgen_csv "$@";  return 0
    esac

    local fileencoding
    [ ! -f "$REPPFILE_FORALL" ]  && { err "file[${REPPFILE_FORALL}] is not existed!"; return 1; }

    ## change reppscript.sh to linux file format, same to sed -i 's/\x0D$//' file
    grep -q $'\r' "$REPPFILE_FORALL" && fileencoding=windows || fileencoding=linux
    [ "$fileencoding" = "linux" ] && csv_fromlnx_towin "$REPPFILE_FORALL"


    ## 공통 custom 변수및 공통 pre/post script 확장
    ## define custom variable REPPSCRIPT_V1, REPPSCRIPT_V2
    readarray -d\` -t array_var < <(cat "$REPPFILE_FORALL"| awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="`";} \
    NR>=1 && NR<=2 {gsub(/""/,"\"",$0); gsub(/\r/,"",$7);print $4"`"$5"`"$6"`"$7}')
    eval "${array_var[0]}=${array_var[1]}"
    eval "${array_var[2]}=${array_var[3]}"
    #REPPFILE_OUT=${REPPSCRIPT_PRE} ; reppforgen_sh "${array_var[5]}"
    #REPPFILE_OUT=${REPPSCRIPT_POST}; reppforgen_sh "${array_var[7]}"

    local reppscript_pre="${array_var[5]%$'\n'}"; #맨뒤에 \n은 삭제
    reppscript_pre="${reppscript_pre#\$'}" ; reppscript_pre="${reppscript_pre%'}"    # '~~~'' 삭제
    reppscript_pre="${reppscript_pre#*\"}" ; reppscript_pre="${reppscript_pre%\"*}"  # "~~~" 삭제
    local reppscript_post="${array_var[7]%$'\n'}" #맨뒤에 \n은 삭제
    reppscript_post="${reppscript_post#\$'}" ; reppscript_post="${reppscript_post%'}"    # '~~~'' 삭제
    reppscript_post="${reppscript_post#*\"}" ; reppscript_post="${reppscript_post%\"*}"  # "~~~" 삭제


    ##전체 csv를 읽어 array로 바꾸는 작업으로 이를 위해 먼저 reppforall.csv의 구분자를 comma(,)에서 backquote(``)로 바꾼다.
    #REPO_LREV 찾으면 그 다음줄부터 처리하게 되는데, 이를위해 awk에서 found=1로 설정후 다음줄로 이동
    #REPO_LREV (found 1이고) REPP_SCRIPT가 비어있지 않으면
    #gsub(/("|=)/,"",$1)          : change number to text
    #sed 's/,/`/g'                : change csv to txt
    #gsub(/""/,"\"",$7)           : change csv string "" to normal "
    #gsub(/\r/,"",$7)             : remove carrige return
    #그런후 마지막으로 출력, 즉 REPP_SCRIPT가 있는 line만 출력
    #cat "$REPPFILE_FORALL"| awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="\n"; found=0} /^REPO_LREV/ {found=1; next} found && ($1 !~ /^[0-9a-f]{10,}/ || $7 ~ /[[:print:]]+/) \
    #{gsub(/("|=)/,"",$1); gsub(/""/,"\"",$7); gsub(/\r/,"",$7);print $1"`"$2"`"$3"`"$4"`"$5"`"$6"`"$7}'> "$REPPFILE_FORALL".tmp
    #readarray -t arrayline < <(awk 'BEGIN{RS="\r\n"} {print}' "$REPPFILE_FORALL.tmp")
    readarray -d $'\r\n' -t arrayline < <(cat "$REPPFILE_FORALL"| awk 'BEGIN{FS=","; RS="\r\n"; OFS="`"; ORS="\r\n"; found=0} \
    /^REPO_LREV/ {found=1; next} found && ($1 !~ /^[0-9a-f]{10,}/ || $7 ~ /[[:print:]]+/) \
    {gsub(/("|=)/,"",$1); gsub(/""/,"\"",$7); gsub(/\r/,"",$7);print $1"`"$2"`"$3"`"$4"`"$5"`"$6"`"$7}')

    ## 결과값을 reppforall_result.csv에 write하려고 했으나, 다중 script를 호출하는 구조로 return값 처리가 어려워서 보류
    ## cat "$REPPFILE_FORALL"| awk '$1~/REPO_LREV/ {print; exit} {print}' > ${REPPFILE_FORALL%\.*}_result.csv

    ##REPO_XXX로 시작하는 heading 을 제외하고 그 다음줄 부터 처리, count=1
    ##먼저 실행할 내용을 보여준다. 이때 실행불가능한 cmd가 있으면 멈춘다.
    bbar cyan "check user input commands" "▼▼▼ show only 100 char \n"
    local count total pcmd cmd pro tmp=
    local oneline=()
    #laptime reset

    for ((count=0,total=0; count<${#arrayline[@]}; count++ )); do
        ##read oneline to array
        readarray -t -d\` oneline <<< "${arrayline[$count]}"
        #IFS='`' read -d'\n' -r -a oneline <<< "${arrayline[$count]}"
        #declare -p oneline | sed 's/\[/\n[/g'

        cmd=$(echo ${oneline[6]} | xargs -0)
        pro=${oneline[4]};

        if [[ "$pcmd" == "$cmd" ]]; then
            printf -v tmp "%s%s " "$tmp" "$pro"
            progress "magenta" "cmd is same to above [$count]"
            continue
        else
            # 이전에 누적된 tmp를 한 번에 출력
            printf "${cyan}%s${NCOL}\n" "$tmp"
            tmp=""
        fi
        pcmd=$cmd
        [ -z "$pro" ] && break

        #debug (( "$count" == 4 )) && break
        ## 만약 6번째 item이 print가능한 명령이 존재하면 명령을 보여줘라.
        if [[ -n "${cmd}" ]]; then
            printf -v cmd "%-.100s" "${cmd//\\n/}"
            bbar cyan "[$((total=total+1))] ${pro}" "${cmd}\n"
        fi

        if [[ "$cmd" =~ "repp forall" ]]; then err "csv must not include 'repp forall' cmd. it's recursive" ; return 1; fi

        (( $total == 0 )) && { err "No target git project is found in $REPPFILE_FORALL
        If create above file by 'repp forall gen', Please add <your command> in REPP_SCRIPT column using excel" ; return 1; }
    done
    #laptime
    ## REPPSCRIPT_V1, REPPSCRIPT_V2의 값을 보여준다.
    echo
    bbar yellow "check user input variables" "▼▼▼ show full\n"
    bbar yellow "REPPSCRIPT_V1" "$REPPSCRIPT_V1\n"
    bbar yellow "REPPSCRIPT_V2" "$REPPSCRIPT_V2\n"

    ##REPPSCRIPT_PRE, REPP_POSTSCRIPT를 먼저 보여준다.
    ## leading, trailing space 제거
    echo
    bbar magenta "check user common pre/post script" "▼▼▼ show full\n"
    bbar magenta "REPPSCRIPT_PRE"  "$( printf "\n%s" "${reppscript_pre:-not-defind}"  )\n"
    bbar magenta "REPPSCRIPT_POST" "$( printf "\n%s" "${reppscript_post:-not-defind}" )\n"

    ## repp forall 입력시 전체를 어떻게 실행할지 1회 물어본후, 각 명령어 실행시미다 다시 물어본다.
    local i ccmd cmd= pro= lrev from
    case "$opt" in    g|go|goo) :
        ;; '') read -p "$(echo -e "\n\n${cyan}[enter:execute by asking |g |go |goo: run all with log level |ctrl+c:break]:${NCOL}")" opt
        ;;  *) err "wrong option" ; return 1
    esac
    case "$opt" in ''|g|go|goo) :
        ;; *) err "you have to input either 'enter', 'g', 'go', or 'goo'";  return 1
    esac


    touch $REPPSCRIPT_OUT && chmod +x $REPPSCRIPT_OUT
    for ((count=0,total=0; count<${#arrayline[@]}; count++ )); do
        readarray -t -d\` oneline <<< "${arrayline[$count]}"

        ## project가 비워있으면 skip
        pro=${oneline[4]}; [ -z "$pro" ] && break

        ## debug show command
        #for i in "${!oneline[@]}"; do printf "[%d]=%q\n" "$i" "${oneline[$i]}"; done

        ## leading, trailing space 제거
        lrev=$(echo "${oneline[0]}" | xargs)
        cmd="${oneline[6]%$'\n'}" #맨뒤에 \n은 삭제

        if [ -z "$cmd" ];then continue; fi
        cmd="${cmd#\$'}" ; cmd="${cmd%'}"    # '~~~'' 삭제
        cmd="${cmd#*\"}" ; cmd="${cmd%\"*}"  # "~~~" 삭제

        ## 현재 context에서 실행을 위해 source로 file로 변환하여 호출한다.
        ## pre script + user command script + post script를 합쳐 실행파일을 만들고 이를 source로 실행할수 있도록 cmd에 할당한다.
        ## csv에 읽어온 script가 file이면 cat으로 out으로 넣고, cmd이면 printf로 out으로 넣는다.
        : > $REPPSCRIPT_OUT ##파일 내용 지우기
        [ "${reppscript_pre}" != "NONE" ] && printf "%s\n" "${reppscript_pre}" >> $REPPSCRIPT_OUT
        if [[ -f "${cmd}" ]]; then from=file
            #cmd를 파일과 변수 양쪽으로 저장
            ccmd=$(tee -a $REPPSCRIPT_OUT < "${cmd}")
        else from=' cmd'
            #REPPFILE_OUT=${REPPSCRIPT_OUTP}; reppforgen_sh "${cmd}";
            printf "%s\n" "${cmd}" >> $REPPSCRIPT_OUT
            #cmd안에 존재하는 file이 있는경우, 모두 모아 그 내용을 보여주기 준다.
            for i in ${cmd}; do eval "[[ -f "$i" ]] && cat "$i" >> $fileincmd" 2> /dev/null; done
            ccmd=$(cat $fileincmd)
            : > $fileincmd
        fi
        [ "${reppscript_pre}" != "NONE" ] && printf "%s\n" "${reppscript_post}" >> $REPPSCRIPT_OUT

        #if ! shellcheck -s bash -S error $REPPSCRIPT_OUT ; then err "input command is not correct!"; return 1; fi

        #g, go(with msg), goo(with fullmsg), enter, other를 물어본다.
        if [ "$opt" != "g" ]; then under "[$((total=total+1))] ${oneline[4]}\n"; fi
        if [ "$opt" != "g" ] || [ "$opt" != "go" ]; then bbar cyan "${oneline[5]}" "\n[ csv] ${cmd}\n[$from] ${ccmd:=same}\n"; fi
        if [ -z "$opt" ] || [ "$opt" = "debug" ] || [[ $opt =~ ^g[o]*$ ]]; then
            #debug echo ${REPPSCRIPT_OUT}
            #cmd="source $REPPSCRIPT_OUT";
            #run command
            ## 각 repository마다 다시 한번씩 물어보게 된다. g|go|goo를 입력하면 나머지는 물어보지 않고 바로 실행한다.
            [[ $opt =~ ^g[o]*$ ]] || read -p "$(echo -e "${yellow}[enter: run next |g |go |goo: run all with log level |debug:show log| other: skip next |ctrl+c: break all] :${NCOL}")" opt
            pushd "$REPP_ROOT/${oneline[5]}";
            case "$opt" in
                g|go|goo|'') :
                ;; debug) [[ $- == *x* ]] && set +x || set -x #toggle debug
                ;; *) opt= ; echo skipped && continue
            esac

            REPO_ROOT="$REPP_ROOT" REPO_LREV="${lrev}" REPO_GROUP="${oneline[1]}" REPO_REMOTE="${oneline[2]}" REPO_RREV="${oneline[3]}" \
            REPO_PROJECT="${oneline[4]}" REPO_PATH="${oneline[5]}" REPPSCRIPT_V1="${REPPSCRIPT_V1}" REPPSCRIPT_V2="${REPPSCRIPT_V2}" source $REPPSCRIPT_OUT

            # ## REPP_RESULT값이 설정되지 않았을때에 대한 default값 설정
            # if [ "$__ret" = "NONE" ]; then [ $? -eq 0 ] && __ret='OKAY' || __ret='FAIL'; fi
            # #windows파일인지 linux파일인지 판단
            # if [ "$fileencoding" = "windows" ];
            # then awk -v count="$((count+3))" -v ret="$__ret" 'BEGIN{RS=ORS="\r\n"} NR==count {print $0,ret}' "$REPPFILE_FORALL" >> ${REPPFILE_FORALL%\.*}_result.csv
            # else awk -v count="$((count+3))" -v ret="$__ret" 'BEGIN{RS=ORS="\n"} NR==count {print $0,ret}' "$REPPFILE_FORALL"   >> ${REPPFILE_FORALL%\.*}_result.csv
            # fi
            popd
        fi
    done
}

##아래는 repp forall 구현내용을 기록합니다.
:<< COMMENT
10. repp forall gen이나 repp forall -c <cmd>명령으로 reppforall.csv를 생성하게 된다.
 11. 2경우 모두 reppforgen_csv 에서 처리하며, gen이면 전체repo/빈cmd, -c <cmd>이면 해당repo/cmd 형태를 가진 csv를 생성한다.
 12. 여기서 repp forall testcase 명령으로 테스트를 위해 기존에 잘 동작하는 csv를 copy해온후 바로 repp forall로 구동해볼수 있다.
 14. 생성된 reppforall.csv를 xls로 열어 원하는 명령이 되도록 편집을 완료한다.
20. repp forall 명령으로 reppforall.csv에 기록된 repo를 돌아다니며, 각 cmd를 실행할수 있다.
 21. 먼저 csv_fromlnx_towin 함수를 통해 reppforall.csv가 linux format이면 windows로 바꾼다. (PC 편집저장시 window format으로 저장되므로)
30. csv heading를 읽어와 REPPSCRIPT_V1, REPPSCRIPT_V2등 먼저 변수들을 선언한다.
 31. 변수 reppscript_pre, reppscript_post에 csv에 정의된 pre/post script를 읽어 저장해놓는다.
 32. 이때 script들에 포함된 특수문자를 제거하기 위해 reppforgen_sh 함수(대체함)를 호출하여 정제한다.
40. 이제 reppforall.csv들의 본문(REPO_LREV 다음줄 기준)을 모두 읽어 arrayline 배열에 넣는다. (이를 위해 구분자를 backqoute로 하고, REPPSCRIPT가 존재하는 column만 저장)
 41. 작업개요를 보여주기 위해 arrayline에 들어간 작업할 repo 정보와 cmd(REPPSCRIPT)를 모두 출력해준다.
 42. REPPSCRIPT_V1/2변수와 REPPSCRIPT_PRE/POST script의 내용도 보여준다.
50. repp forall명령을 각 repo마다 물어보면서 실행할지 한꺼번에 실행할지, 정보는 얼마나 출력할지 물어본다.
 51. arrayline에서 한줄식 읽어와서 REPO_ROOT/LREV/GROUP/REMOTE/RREV/PROJECT/PATH/REPPSCRIPT_V1/REPPSCRIPT_V2/cmd 값을 저장한다.
 52. 읽어온 REPPSCRIPT(cmd)가 file이면 놔두고, cmd이면 file에 넣는다. 이후 source로 해당 file을 읽어오기 위함이다.
 53. 어째튼 REPPSCRIPT_PRE + REPPSCRIPT(cmd) + REPPSCRIPT_POST가 되도록 최종 실행 script 파일을 만든다.
60. 이제 사용자에게 실행방법을 압력받아, 위의 REPP_XXX변수들과 함께 source 구문으로 script를 현재 shell에 넣어 실행한다.
 61. 실행이 완료되면 arrayline에서 다음줄을 읽어와 위 51번부터 배열끝까지 반복한다. >>> 실행결과 처리가 필요할것으로 보인다.
COMMENT


##아래는 repp forall을 test하는 방법을 기술한다.
:<< COMMENT
1. 아래와 같이 repp forall -c '명령'을 넣어서 실행해보거나, reppforall.csv의 REPP_SCRIPT 영역에 repp forall -c를 제외하고 명령을 넣어서 실행해본다.
2. 먼저 아래 명령을 하나씩 입력한후 repp forall로 정상적으로 실행되는지 확인한다.
    >repp forall -c bash -c 'echo "${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}"'
    >repp forall honda/con/autosar tiger/metas/meta-tiger -cj1 \
        bash -c '[ "${REPO_REMOTE}" != "vgit_na" ] && echo "project:${REPO_PROJECT}" || echo "path:${REPO_PATH}" ' \
        $USER $PWD
    >repp forall -c bash -c 'case ${REPO_PROJECT} in
        */*/*|*/*/*/*)
            if [[ "${REPO_PATH}" =~ (.*build?)    ]]; then echo "path:[${BASH_REMATCH[1]}]"
            elif [[ "${REPO_PROJECT}" =~ (.*build?) ]]; then echo "project:[${BASH_REMATCH[1]}]"
            else echo "remote:[${REPO_REMOTE}]"
            fi
        ;;          *)  printf "~~~~~~~~~~~~~~~${REPO_PROJECT}[%s]\n" "$1 $2"
    esac' - $USER $PWD
    >repp forall . -c bash ~/.proFILEs/repo_var.sh - $USER $PWD
    >repp forall . -c 'revv accessall ${REPO_REMOTE} ${REPO_PROJECT}'
##<주의> repp forall -c <cmd>안에서
    #repp 지원명령은 bash없이 실행시켜야 한다. revv access는 bash -c 없이 실행시켜야 현재 context에서 실행됨
    #repp forall -c 'repp forall testcase' #즉, script에서 repp forall 명령은 재귀호출됨으로 실행이 불가
    #repp forall -c 'bash reppscript.in.sh' #reppscript로 시작하는 script역시 사용할수 없다. 재귀호출됨으로 안됨

3. repp forall testcase 명령으로 기존에 준비된 csv를 reppforall.csv를 copy한후, repp forall로 검증한다.
COMMENT



function reppdiff(){
## ---------------------------------------------------------------------------
# get repo command from exising repo project
# $1 show repo command (default: save info to each variable such as REPP_URL, REPP_BRANCH, ...)

    local cmd=$1
    local src=$2
    local target=$3

    [[ ! "${PWD}" = "${REPP_PATH}" ]] && pushd ${REPP_PATH}

    reppget_repcmd
    case ${cmd} in
        diff)
                ## listup xml by date and get input
                [ -z "${src}" ] && ( git log --since=3-weeks --first-parent --date=format:'%Y-%m-%d (%a) %H:%M:%S' --pretty=format:'%Cgreen%cd [%t]%Creset' --name-status| awk 'NF==1{date=$1}NF>1 && !seen[$2]++{print date,$0}' FS=$'\t' )
                if [ -z "${src}" ]; then
                    under "input format: <old manifest> <new manifest>\n"
                    echo "    ex) Daily/project_240621.xml mig_240701.xml  #compare both"
                    echo "    ex) Daily/project_240621.xml                 #compare to current"
                    read -p $'\n\ninput: ' opt

                    src=${opt% *}
                    [ -z ${opt#* } ] && clog "\ninput old [${opt}]" "will be compared to current manifest [${REPPFILE_MANI}]"|| clog "will be executed:" "repp mani diff ${opt}"
                fi
                echo
                warn "if branches are changed between <old manifest> and <new manifest>, you must 'repo sync' without -c option to get all commits !!"
                read -p '[enter:continue without sync| y:yes branches are changed, sync continue| ctrl+c:break]'
                [ "$opt" = "y" ] && repo sync -qj5

                ## assign target value
                if [ -z "$target" ]; then [[ "$opt" =~ " " ]] && [ -z "${opt#* }" ] && target="${opt#* }" || target=${REPPFILE_MANI}; fi

                ##check if both manifest files exists?
                if [ ! -f "${src}"    ]; then err "${src} file is not existed"; return 1; fi
                if [ ! -f "${target}" ]; then err "${target} file is not existed"; return 1; fi

                repo --no-pager diffmanifests --no-color --raw ${src:=${opt% *}} ${target} --pretty-format='> %s| %h| %an| %ci'|sed -e 's/\[m//g' >${REPP_DIR}/repp.diff.tmp
                #repo --no-pager diffmanifests --no-color --raw  Daily/POIP_240627.xml default.xml --pretty-format='>%s|%h|%an|%ci'|sed -e 's/\[m//g' >${REPP_DIR}/repp.diff.tmp
                cat ${REPP_DIR}/repp.diff.tmp| sed -e '/Merge commit/d;/Merge "/d'| while read -r line; do [ "${line:2:1}" = '>' ] && echo "${line/ /|}" || echo -e "|||\n|||\n${line// /|}" ; done > ${REPP_DIR}/repp.diff2
                cat ${REPP_DIR}/repp.diff2 | column -s'|' -t --table-columns status,subject,commit-id,author,date --table-wrap subject --output-width 200 > ${REPP_DIR}/repp.changes
                rm -f ${REPP_DIR}/repp.diff.tmp ${REPP_DIR}/repp.diff2
                showRUN repo diffmanifests ${src:=${opt% *}} ${target} --pretty-format='%Cred%h %Cgreen(%ci) %C(blue)<%an>%Creset %s'

                cat <<-EOL
		guide)   added projects(NOT compare) : path-added,   project-added   (in ${target} manifest)
		       removed projects(NOT compare) : path-removed, project-removed (in {src} manifest)
		       missing projects(NOT compare) : path-same,    project-changed
		  unreachable revisions(NOT compare) : need to 'repo sync' (without -c, fetch all project revision)
		          skip projects(NOT compare) : path-same, project-same, branch-same (No diff, SKIP)
		       changed projects( OK compare) : path-same, project-same, branch-changed
EOL
                info "diff list is saved to ${REPP_DIR}/repp.diff"
                info "changenote is saved to ${REPP_DIR}/repp.changes"

    ;;  diffcheck)
                local cpath cbrold cbrnew cremote cproject ccommitid deployed
                IFS=' '; cat ${REPP_DIR}/repp.diff | sed -e 's/\x1b\[[0-9;]*m//g'| while read -r -a line; do
                #echo "${line[@]}"
                    case ${line[0]} in
                         C) #compare case changed project
                            #3rd is remote, 7th is project,
                            cpath="${line[1]}"; cbrold="${line[2]}"; cbrnew="${line[3]}"
                            #cremote=$(cat ${REPPFILE_CSV} |grep ${cpath} | cut -d'|' -f3)
                            cremote=$(cat ${REPPFILE_CSV} |grep ${cpath} |awk -v FS="|" '{print $3}')
                            cproject=$(cat ${REPPFILE_CSV} |grep ${cpath} | awk -v FS="|" '{print $8}'|xargs)

                        ;;R)
                            ccommitid="${line[1]/|/}"
                            ##get change_id and find commmit in new branch, it is deployed.
                            deployed=$( revv commit find $(revvserver_item ${cremote} path) ${ccommitid} | sed '1d'|  jq -cC '.[].branch' | grep "${cbrnew}" )
                            [ -z "${deployed}" ] && info "[missing commits] ${cremote}> ${cproject}> ${cbrnew}> ${ccommitid}"
                    esac
                done
    esac
    popd
}



function reppget_repcmd(){
## ---------------------------------------------------------------------------
# REPPFILE_MANI 변수와 repo init 명령어를 추출한다.
# $1 명령어를 출력할지 여부 (default: save info to each variable such as REPP_URL, REPP_BRANCH, ...)
    local count file_tempa file_tempb

    if [ -z "${REPP_BRANCH}" ]; then
        printf "${RED}[warning] please check if you have switched to a topic branch from after repo init${NCOL}\n"
        printf "${RED}[warning] temporarily set to local branch name${NCOL}\n"
        printf "\tyou can set-up upstream branch with: git branch -u %s <branch-name>\n" "$(echo $(git remote -v |cut -f1))"
        REPP_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    fi

    ## find using manifest.xml
    file_tempa=$(command ls -Art ../*.xml | tail -n 1)
    count=$(grep -c include ${file_tempa})
    if [ -L "${file_tempa}" ];then
        file_tempb=$(readlink "${file_tempa}")
        REPPFILE_MANI=${file_tempb#*/}
    elif [ $count -eq 1 ]; then
        file_tempb=$(grep include $file_tempa |sed -E 's/<.*name="(.*)".\/>/\1/')
        REPPFILE_MANI=${file_tempb// /}
    else
        REPPFILE_MANI=default.xml
    fi

    if [ -n "$REPP_GROUPS" ] && [[ ! "${EXTRA_OPTION}" =~ "--groups"    ]] ;then EXTRA_OPTION="--groups=$REPP_GROUPS " ; fi
    if [ -n "$REPP_REF" ]    && [[ ! "${EXTRA_OPTION}" =~ "--reference" ]] ;then EXTRA_OPTION+="--reference=$REPP_REF "; fi
    if [ -n "$REPP_MIRR" ]   && [[ ! "${EXTRA_OPTION}" =~ "--mirror"    ]] ;then EXTRA_OPTION+="--mirror "             ; fi


    if [ "$1" = "info" ];then
        bar inline "repo-init cmd"
        ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        REPP_CMD="repo init -u $REPP_URL -b $REPP_BRANCH -m ${REPPFILE_MANI} ${EXTRA_OPTION} --repo-url=${REPP_REPOURL}"
        log "${REPP_CMD}"
    fi
    return 0
}



function reppinfo(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local manifest=$1

    pushd ${REPP_PATH}
    #oldIFS=${IFS}; IFS='';

    ##show repo dir path
    bar inline "repo path"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    log "${REPP_PATH}"

    ##get global variable and repo init command.
    reppget_repcmd info

    ##show manifest file with included sub manifests.
    bar inline "manifests"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    clog  "    <name of manifest>                                      <including branches>"
    reppshow_manifesttree ${manifest:-${REPPFILE_MANI}} 0
    info "to see specific xml, run 'repp info <xml>'"

    [ -n "$manifest" ] && return 0

    ##show count of repository
    ### block infomation
    bar inline "more information for this repositories"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ##show last synced time
    if [ -f .git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y .git/FETCH_HEAD );
    else clog "last manifest-synced time(check date of files below): " $(ls -ld .git) ;fi
    popd

    clog "md5sum for all repositories:"
    repo forall -j16 -c git log -1 --pretty=format:%H%n  2> /dev/null | md5sum

    clog "number of repositories: " $REPP_COUNT
    read -t 2 -p "Press Ctrl+C not to see extra information(generated by 'repp mani init') ... "

    ##manifest에 기록된 remote정보를 보여준다.
    bar inline "remotes & review sites"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #for (( i=0; i < ${#REPP_REMOTELIST[@]}; i++ )); do printf "remote: %s,\t\t review: %s\n" "${REPP_REMOTELIST[$i]}" "${REPP_REVIEWLIST[$i]}"; done
    #cat ${REPPFILE_JSON}|jq -cC '.remote[]'
    cat ${REPPFILE_JSON_REMOTE}|jq -cC '.|sort_by(.fetch)[]|{fetch, name, alias, view, pushurl, revision}'

    ##check if git submodule is activate
    ## repp_initdb에서 repp.csv.submodule을 만들어 놓았다.
    #cat ${REPPFILE_CSV}.submodule| xargs -I% bash -c 'set -- %; [ -e "$1/$2/.git" ] && cat $1/.gitmodules'
    #cat ${REPPFILE_CSV}.submodule| xargs -I% bash -c 'set -- %; echo [$1/$2]; [ -e "$1/$2/.git" ] && cat $1/.gitmodules'
    pushd "${REPP_ROOT}"

    bar inline "git submodule & lfs information"
    ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if [ -s ${REPPFILE_CSV}.submodule ]; then
    clog "git submodule repositories path(git):" "$(wc -l < ${REPPFILE_CSV}.submodule)";
    cat ${REPPFILE_CSV}.submodule| xargs -I{} bash -c \
    '   set -- {};
        if [ -e "$1/$2/.git" ]; then printf "\e[1;33m   active:\e[0m $1/$2\n"; cat $1/.gitmodules;
                                else printf "\e[0;31m inactive:\e[0m $1/$2\n"; fi
    ';fi

    if [ -s ${REPPFILE_CSV}.lfs ]; then
        clog "\ngit lfs repositories path(git):" "$(wc -l < ${REPPFILE_CSV}.lfs)";
        cat ${REPPFILE_CSV}.lfs;
    fi
    popd


    ##show duplicated repositories
    local f_dup=${REPPFILE_CSV}.dup
    awk -v 'FS=|' '{print $7}' ${REPPFILE_CSV} |sort|uniq -dc > $f_dup
    local f_count=$(wc -l < "$f_dup")
    clog "\nduplicated repositories:" "$f_count"
    # 파일의 라인 수가 20 일때만 화면출력
    if [ "$f_count" -le 20 ]; then cat "$f_dup";
    else info "duplicated repositories are over 20, so duplicated git list are saved to \n [ ${f_dup} ]";
    fi
    #IFS=${oldIFS}
}



function reppshow(){
## ---------------------------------------------------------------------------
# print information(changes, recent commits) of current repository#
    ##topic/working branch
    bar inline "repo branch: check if working branch existed (WAIT: It takes time) "
    repo branch 2> /dev/null

    ##run command "repo info"
    echo "repo status" > ${REPPFILE_STATUS}

    ##remove colored output with 1) sed command, 2) --color option
    #repo status -j8 |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPPFILE_STATUS}
    repo --no-pager --color=never status  >> ${REPPFILE_STATUS} 2> /dev/null &

    ##list up repo commit, remote, branch, project, path
    reppfind |more -60

    ## repo info command is duplicated with reppfind functionality, so remove it.
    #bar inline "repo info: git repo/source path /branch rev saved to [ ${REPPFILE_STATUS} ]"
    #echo "repo info" >> ${REPPFILE_STATUS}
    #repo info |sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" >> ${REPPFILE_STATUS}

    bar inline "repo status: uncommitted changes list saved to [ ${REPPFILE_STATUS} ], it takes about 2mins to get info"
    info "${REPPFILE_STATUS} you can use this file to check dirty commits left"
}



# local menu_items=('go ROOT　dir' 'go Manifests　dir' 'go GIT　root dir' 'exit')
# run_menu "${menu_items[@]}"
# case "$?" in
    # 1|11)  cd "${REPP_ROOT}"        ;;
    # 2|12)  cd "${REPP_PATH}"        ;;
# esac

function reppgo() {
## ---------------------------------------------------------------------------
# return git root path or return near git path
    local cmd="$1"

    case $cmd in
        help) cat <<- EOF
				usage) repp go              # go repo root dir
				usage) repp go root         # same to above
				usage) repp go mani         # go manifest dir
				usage) repp go git          # go current git root dir
				usage) repp go repo         # show menu to select similar-depth repo project
				usage) repp go <dir>        # show git path and move there
EOF
                return 1
      ;;repo)
                local INPUT=( $(find ${REPP_ROOT}/.. -maxdepth 4 -name ".repo" 2> /dev/null |head -60))
                if [ -n "${INPUT}" ];
                then run_menu "${INPUT[@]}";  cd "${menu_selected}/.."
                else INPUT=( $(find ${HOME} -maxdepth 4 -name ".repo" 2> /dev/null |head -60))
                     run_menu "${INPUT[@]}";  cd "${menu_selected}/.."
                fi
      ;;repp)   cd ${REPP_DIR}
      ;;mani)   cd ${REPP_PATH}
      ;;  '')   gitt go root
      ;;   *)   gitt go $cmd
    esac
}



function gittgo() {
## ---------------------------------------------------------------------------
# return git root path or return near git path
    local cmd="$1"
    local current_dir=${PWD}

    case $cmd in
        help) cat <<- EOF
				usage) gitt go root         # go repo root dir
				usage) gitt go mani         # go manifest dir
				usage) gitt go git          # go current git root dir
				usage) gitt go              # same to above
				usage) gitt go <dir>        # listup git path including 'dir' and move to select
				   ex) gitt go build        # lustup git path including 'build' and move to select
EOF
                return 0
      ;;root)   cd "${REPP_ROOT:-${GITT_PATH}}"; if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
      ;;mani)   cd "${REPP_PATH}"; if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
    ;;git|'')   cd "${GITT_PATH:?'can not find .git path'}"; if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
    esac

    if ! repp_initvar; then warn "your are not in repo"; return 1; fi
    if [ ! -f ${REPPFILE_CSV} ]; then reppfind $cmd; fi

    local INPUT=( $(cat ${REPPFILE_CSV} |grep ${cmd}| awk -v FS='\\|' '{print $8}'| sort) )
    if [ -n "${INPUT}" ];
    then
        run_menu "${INPUT[@]}"; cd "${REPP_ROOT}/${menu_selected##* }";
        if [ "${current_dir}" = "${PWD}" ]; then warn "path is not changed" && return 1; else return 0; fi
    else warn "you must find path manaully"; return 1
    fi
}



function reppcommit(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local cmd=$1
    local base=$2
    local target=$3
    local server
    case $cmd in
        last)
            bar outline "repo get newest N of last(-1) commit from each gits"
            bar inline "date:YMD HMS]       [sha]    [author]         [commit title]                                         [branch]                            [git project"
            repo forall -j16 -c 'printf "%-100.100s %-32.32s %-s \n" "$(git log -1 --abbrev=7 --date=format:"%Y-%m-%d %H:%M:%S" --pretty=format:"%ad  %h  [%an] %s")" "${REPO_RREV}" "${REPO_PROJECT}"' | sort -r |head -${base:-50}
            #repo forall -c "git log -1 --abbrev=6 --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%ad  %h  [%an] %d %s%n'" |sort -r |head -${base:-50}
      ;;diff)
            reppdiff diff "$base" "$target"

      ;;find)
            for server in na as eu devops_test review null; do
                if [ "$server" != "null" ]; then
                    if revvcommit find ${server} ${base}; then break; fi
                    clog "gerrit url:" $server/plugins/gitilies/$pro/+/$source
                    ## https://git.repp.com/as/plugins/gitiles/npro/build/+/f94ba87

                else  break; fi
            done
      ;;help|*) cat <<- EOF
				usage) repp commit last N            # show top N commits from each git HEAD
				   ex) repp commit last 40           # show top 40 commits form each git lastest HEAD
				usage) repp commit diff <from> <to>  # show diff commits <from.xml> and <to.xml>
				   ex) repp commit diff              # show selectable xml list and show diff between them
				usage) repp commit find <commit-id>  # find commit all remote review system & local repository
				   ex) repp commit find ecd867916b   # find commit ecd867916b in all server and print info

				 info) 'repp commit find' same to 'revv commit find <all-servers> <>'
EOF
    esac
return 0
}



function repp_initdb(){
## ---------------------------------------------------------------------------
# create DB from comparing repo manifest and repo forall
# $1 command
# usage: repp_initdb is used only by function call.

    local cmd=$1
    case $cmd in
       init) if [ "$REPP_INIT" -ge 1 ]; then rm -rf ${REPP_DIR} ; fi
      ;;  *) [ -f "${REPPFILE_CSV}" ] && { $DEBUG "\${REPPFILE_CSV}:${REPPFILE_CSV} reused above file or you can remove and refresh repository info"; return 0; }
    esac
    (( "$(reppversion ver 2>/dev/null)" < 230 )) && { reppversion toggle; warn "automatically update to latest repo version, you can restore 'repp version toggle'"; }
    if [[ ! $(column -V 2>/dev/null|grep util-linux) =~ "util-linux" ]] ;then
        clog "column need to reinstalled, please 'repp install'";
    fi

    #laptime reset;
    warn "REPP DB will be regenerated"; wave
    ## generate json from manifest, #suppress all log for generation json
    [ -d ${REPP_DIR} ] || mkdir ${REPP_DIR}
    repo manifest -r --json -o ${REPPFILE_JSON} &>/dev/null
    if (( "$(reppversion ver 2>/dev/null)" > 220 )) && ! [ -s ${REPPFILE_JSON} ]; then
        warn "check if you are in mirror repo, use source repo NOT mirror
        or failed by manifest error, check with 'repo manifest -r --json'"
    fi
    cat ${REPPFILE_JSON} | jq .remote > ${REPPFILE_JSON_REMOTE}


    #for debug:use 'declare -p items_alias'
    ## get <default> from json
    #readarray -d'|' -t item_default < <(cat  ${REPPFILE_JSON} |jq -j '.default|.revision,"|",.groups,"|",.remote,"|",.upstream,"|",."dest-branch","|",.name,"|",.path,"|"')
    readarray -d'|' -t line_default < <(cat ${REPPFILE_JSON} | jq -r '.default|{revision,groups,remote,upstream,"dest-branch",name,path,fetch} + .| to_entries | map("\(.key)=\(.value)") | join("|")' )
    ## get <remote> from json
    #readarray -t items_remote  < <(cat ${REPPFILE_JSON_REMOTE} |jq -r '.[]|{name,alias,fetch,pushurl,review,revision} + .| to_entries | map("\(.key)=\(.value)") | join("|")'| sort)

    ## get all <project> from json
    #cat ${REPPFILE_JSON} | jq -cC '.project[] | del(.groups, .remote, .upstream, ."dest-branch", .path) | select(length > 1) | {revision} + .'
    readarray -t items_project < <(cat ${REPPFILE_JSON} | jq -r '.project[]|{revision,groups,remote,upstream,"dest-branch",name,path} + .| to_entries | map("\(.key)=\(.value)") | join("|")'| sort -t'|' -k6,7)


    ## save to array
    local mani_out=()
    printf "takes time at first, creating .repp dir & DB files by analysing manifest\n\n"
    ## read one line from items_project array
    local linein lineout count=0
    local lrev group remote upstream dest_branch project path remote_alias

    ## save to array
    for lines in "${items_project[@]}"; do
        IFS='|' read -ra linein <<< "$lines"
        ##get project info, if null assign default value
               lrev=${linein[0]##*=};        [[ $lrev = null ]] &&        lrev=${line_default[0]##*=}
              group=${linein[1]##*=};       [[ $group = null ]] &&       group=${line_default[1]##*=}
             remote=${linein[2]##*=};      [[ $remote = null ]] &&      remote=${line_default[2]##*=};
                                           [[ $remote = null ]] &&      remote=$(revvserver_item "${REPP_REMOTE##*:}" key)
           upstream=${linein[3]##*=};    [[ $upstream = null ]] &&    upstream=${line_default[3]##*=}
        dest_branch=${linein[4]##*=}; [[ $dest_branch = null ]] && dest_branch=${line_default[4]##*=}
            project=${linein[5]##*=};     [[ $project = null ]] &&     project=${line_default[5]##*=}
               path=${linein[6]##*=};        [[ $path = null ]] &&        path=${line_default[6]##*=}
               path=${path//$'\r'/}; path=${path//$'\n'/}
               #printf "[%s] %s" $((count++)) "${path}"

        ## 칼럼순서대로 1:revision, 2:group, 3:remote, 4:upstream, 5:dest_branch, 6:rrev, 7:project, 8:path
        ##process item according to index
        [[ $lrev == "null" ]]    && { err "${lineout}"; return 1; }
        [[ $project == "null" ]] && { err "${lineout} name is null"; return 1; }
        [[ $path == "null" ]]    && { err "${lineout} name is null"; return 1; }

        #KJK_DEBUG [ "$remote" == "v9" ] && { set -x; read -p "KJK_DEBUG"; } || set +x
        #3.remote: alias를 원래 remote이름으로 변경한다.
        #remote_alias=$(cat ${REPPFILE_JSON_REMOTE} | jq --arg jq_remote "$remote" -r '.[] | select(.alias != null and .name == $jq_remote) | .alias')
        #[ -n "$remote_alias" ] && remote="$remote_alias"

        lineout="${lrev}|${group:-all,default}|${remote}|${upstream}|"
        if [[ $dest_branch == "$upstream" ]]; then
            lineout+="${dest_branch}|${upstream}|"
        else
            [[ $upstream == "null" ]] && lineout+="${dest_branch}|${lrev}|" || lineout+="${dest_branch}|${upstream}|"
            [[ $upstream != "null" ]] && clog "pull/push url is diff" "$(printf "[%-60.60s] %-40.40s %-40.40s" "$project" "$dest_branch" "$upstream")"
        fi
        lineout+="${project}|${path}|"
        mani_out+=("$lineout")
    done

    #laptime
    ## make result output
    #declare -p mani_out
    printf "%s\n" "${mani_out[@]}" >  ${REPPFILE_CSV}.json
    local prnmsg='%s|%12.12s|%8.8s|%-32.32s|%-32.32s|%-32.32s|%-74.74s|%.80s|%s'
    printf "${prnmsg}\n" ${mani_out[*]//|/ } > ${REPPFILE_TXT}


    #### repo forall로 db를 일단 생성해놓고, 이때 json파일이 생성되지 않았다면 repp.csv로 대체한다.
    repo forall -j1 -c 'echo "${REPO_LREV}|all,default|${REPO_REMOTE}|${REPO_UPSTREAM}|${REPO_DEST_BRANCH}|${REPO_RREV}|${REPO_PROJECT}|${REPO_PATH}|"' |sort -t'|' -k7,8 > ${REPPFILE_CSV}.repo
    [ -s "${REPPFILE_CSV}.repo" ] || { err "repo is not working, must check"; return 1; }
    if (( "$(reppversion ver 2>/dev/null)" > 220 )) && ! [ -f ${REPPFILE_JSON} ]; then
        warn "you are in mirror repo, temporary ${REPPFILE_CSV} is generated by force, it may show incorrect information"
        cp ${REPPFILE_CSV}.repo ${REPPFILE_CSV};
    fi

    # 모든 파일을 한 번에 메모리로 로드
    ## 핵심colume만 비교하기 위해 추출
    local matchlinenum_json matchlinenum_repo
    awk -v FS="|" '{print $1"|"$6"|"$7"|"$8}' ${REPPFILE_CSV}.json > ${REPPFILE_CSV}.json.cmp
    awk -v FS="|" '{print $1"|"$6"|"$7"|"$8}' ${REPPFILE_CSV}.repo > ${REPPFILE_CSV}.repo.cmp

    mapfile -t json_cmp_lines < "${REPPFILE_CSV}.json.cmp"
    mapfile -t repo_cmp_lines < "${REPPFILE_CSV}.repo.cmp"
    mapfile -t json_lines < "${REPPFILE_CSV}.json"
    mapfile -t repo_lines < "${REPPFILE_CSV}.repo"

    # json.cmp 라인을 인덱스에 매핑하는 해시맵 생성 (O(1) 검색용)
    declare -A json_line_to_idx
    for i in "${!json_cmp_lines[@]}"; do
        json_line_to_idx["${json_cmp_lines[$i]}"]=$i
    done

    # 파일이 다른지 확인
    if ! diff -q -B "${REPPFILE_CSV}.json.cmp" "${REPPFILE_CSV}.repo.cmp" &>/dev/null; then
        # 파일이 다른 경우 - 결과 배열 구성
        result_lines=()
        for i in "${!repo_cmp_lines[@]}"; do
            # i는 라인넘버, !repo_cmp_lines[i]는 모든 원소의 index값의 나열
            line="${repo_cmp_lines[$i]}"
            if [[ -v json_line_to_idx["$line"] ]]; then
                # 라인이 json.cmp에 존재하면 json에서 해당 라인 사용
                result_lines+=("${json_lines[${json_line_to_idx[$line]}]}")
            else
                # 존재하지 않으면 repo에서 해당 라인 사용
                result_lines+=("${repo_lines[$i]}")
            fi
        done

        # 결과를 파일에 한 번에 기록
        printf "%s\n" "${result_lines[@]}" > "${REPPFILE_CSV}"

        bar inline "${REPPFILE_CSV}"
        clog "bad case:content different" "join 'repo' and 'json' info"
        warn "${REPP_PATH}/${REPPFILE_MANI}\n        has mismatch  between 'repo manifest' and 'repo forall' \nand the reason why..."
        echo "1.existing project: new commits are added to existing repository, therefore the revision is changed from manifest"
        echo "2.     new project: new repositories created that not described in manifest, by build time download or manual work"
        wave
        diff -B <(awk -v FS="|" '{print $1"|"$7"|"$8}' ${REPPFILE_CSV}.json) <(awk -v FS="|" '{print $1"|"$7"|"$8}' ${REPPFILE_CSV})
    else
        # 파일이 같은 경우
        cp "${REPPFILE_CSV}.json" "${REPPFILE_CSV}"
        bar inline "${REPPFILE_CSV}"
        clog "good case:exactly same" "generated from manifest and verfied by repo"
    fi

    ##git submodule이 설정되어 있는 경우를 수집한다.
    #repo forall -cj4 '[ -s .gitmodules ] && printf "%80s" "${REPO_PATH} $(cat .gitmodules|grep -oP "(?<=path \= ).*")"' > ${REPPFILE_CSV}.submodule
    repo forall -cj16 'printf "%s""$( cat .gitmodules|grep -oP "(?<=path \= ).*" |xargs -I{} echo $REPO_PATH {})"' > ${REPPFILE_CSV}.submodule
    repo forall -cj16 '[ -e .gitattributes ] && [ -n  "$(git check-attr -a *|grep lfs)" ] && echo $REPO_PATH' > ${REPPFILE_CSV}.lfs

    laptime; wave; REPP_INIT=3 #repp DB까지 초기화 완료
    return 0
    #cat ${REPPFILE_JSON}|jq -cC '.project[]|{groups,remote,upstream,"dest-branch",revision,name,path}'
    #cat ${REPPFILE_JSON}|jq -jr '.project[]|.groups,"|",.remote,"|",.upstream,"|",."dest-branch","|",.revision,"|",.name,"|",.path,"\n"'
    #cat ${REPPFILE_JSON}|jq -jr '.project[]|.groups," ",.remote," ",.upstream," ",."dest-branch"," ",.revision," ",.name," ",.path,"\n"'
    #cat ${REPPFILE_JSON}|jq -cM '.project[]|{groups,remote,upstream,"dest-branch",revision,name,path}'|tr -d 'repp"'
    #cat ${REPPFILE_JSON} | jq -cC '.project[] | del(.groups, .remote, .upstream, ."dest-branch", .path) | select(length > 1) | {revision} + .'
    #value만 string으로
    #cat ${REPPFILE_JSON} | jq -r '.project[] | del(.groups, .remote, .upstream, ."dest-branch", .name, .path) | select(length > 1) | "\(.revision)|\(.[])"'
    #key/value를 string으로
    #cat ${REPPFILE_JSON} | jq -cC '.project[] | {revision,groups,remote,upstream,"dest-branch",name,path} + .| to_entries | map("\(.key)=\(.value)") | join("|")'
}



function reppfind(){
## ---------------------------------------------------------------------------
# find git repository with path and project name with regexp
# $1 path or project
# usage: reppfind [path|project]
    local aparam="$1"               #original input value
    local filter="${2:-.}"
    local cparam="$3"               #original input value
    local cshow="$3"                #select colum from input value
    local allname="REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH"
    local hide="$allname,"
    local aname cindex cname

    #repp find @remote na     @path@project
    #          aparam     filter  cshow
    case $aparam in
           '@rev') cindex=1 aname=REPO_LREV
    ;;   '@group') cindex=2 aname=REPO_GROUP
    ;;  '@remote') cindex=3 aname=REPO_REMOTE
    ;;      '@up') cindex=4 aname=REPO_UPSTREAM
    ;;    '@dest') cindex=5 aname=REPO_DEST_BRANCH
    ;;  '@branch') cindex=6 aname=REPO_RREV
    ;; '@project') cindex=7 aname=REPO_PROJECT
    ;;    '@path') cindex=8 aname=REPO_PATH
    ;;     '@all') cindex=0 aname="$allname"
    ;;         '') cindex=99 #no cindex
    ;;          *) cindex=9;
    esac

    [[ "$cparam" =~ "@rev"     ]] && { cname=REPO_LREV       ;cshow="${cshow//@rev/$cname,}"    ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@group"   ]] && { cname=REPO_GROUP      ;cshow="${cshow//@group/$cname,}"  ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@remote"  ]] && { cname=REPO_REMOTE     ;cshow="${cshow//@remote/$cname,}" ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@up"      ]] && { cname=REPO_UPSTREAM   ;cshow="${cshow//@up/$cname,}"     ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@dest"    ]] && { cname=REPO_DEST_BRANCH;cshow="${cshow//@dest/$cname,}"   ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@branch"  ]] && { cname=REPO_RREV       ;cshow="${cshow//@branch/$cname,}" ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@project" ]] && { cname=REPO_PROJECT    ;cshow="${cshow//@project/$cname,}";hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@path"    ]] && { cname=REPO_PATH       ;cshow="${cshow//@path/$cname,}"   ;hide="${hide/$cname,/}"; }
    [[ "$cparam" =~ "@all"     ]] && {                        cshow="$allname"                  ;hide=""                ; }
    [[ "$cparam" =  ""         ]] && {                        cshow="$aname"                    ;hide="${hide/$aname,/}"; }


    [ -f "${REPPFILE_CSV}" ] && info "use generated db, or you can refresh it by 'repp mani init'" || repp_initdb

    case ${aparam} in
        help) cat <<- EOF
		 info) \${REPPFILE_CSV} is saved. can be opened by excel menu [data> text> select file> file open wizard]
		       or can be reformatted by excel menu [data> text to columns> select delimter'|'> finish]
		usage) repp find                                   # show rev,remote,branch,project,path info for all repo
		usage) repp find <string>                          # list info of gits which has string <string> in all git info
		   ex) repp find build                             # list info of gits which has string 'build' in all git info
           ex) repp find .                                 # show info of current git
		   ex) cat \${REPPFILE_CSV}                         # cat output file
		usage) repp find <@key> <string> <@printkey>       # print key colume for all repo
		                 #key: @rev, @group, @remote, @branch, @project, @path, @up, @dest, @all
		usage) repp find @all                              # print all raw columns for all repo
		   ex) repp find @project                          # print project colume for all repo
		   ex) repp find @remote                           # print all remote
		   ex) repp find @remote na                        # print remote which including 'na' string
		   ex) repp find @remote na @path@project@rev      # print path & project & revision with specific remote
		   ex) repp find @group na @group@project          # print group & project with corresponding group
EOF

    ;; @*)        awk -v FS="|" -v vf="$filter" -v vo="$cindex" '$vo ~ vf{print $0}' ${REPPFILE_CSV}|\
                  column '-s|' -t --table-columns "$allname" --table-order "$cshow" --table-hide "$hide"| (sed -u 1q; sort|uniq|pCount)

    #;; @rev)      clog "<REPO_LREV>";    awk -v FS="|" -v vf="$filter" -v vo="$cindex" '$1 ~ vf{printf "[%-40.40s]  %s\n", $1,$vo}' ${REPPFILE_CSV} |pCount
    #;; @branch)                          awk -v FS="|" -v vf="$filter" -v vo="$cindex" '$4$5$6 ~ vf{printf "[%s] %s\n", $4"|"$5"|"$6"|", $vo}' ${REPPFILE_CSV} |sort |uniq |column -s'|' -t --table-columns '<REPO_UPSTREAM>,<REPO_DEST_BRANCH>,<REPO_RREV>'  |pCount -1
    #;; @all)     awk -v FS="|" -v vf="$filter" -v vo="$cindex" '$0 ~ vf{printf "[%s] %s\n"    , $0,"|"$vo}' ${REPPFILE_CSV} |sort |uniq |\
                  #column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH |pCount -1
                  #cat ${REPPFILE_CSV}|column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH |pCount -1
    ;; '')        #summary view by hiding REPO_GROUP,REPO_UPSTREAM,REPO_DEST_BRANCH from all items
                  cat ${REPPFILE_CSV}|colrm 7 40|\
                      column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH \
                      --table-hide REPO_GROUP,REPO_UPSTREAM,REPO_DEST_BRANCH |pCount -1
                  printf "\n\n"
                  info "Above \${REPPFILE_CSV} is generated, all repository info is save: ${REPPFILE_CSV}"
                  clog "\${REPPFILE_CSV}" "this file can opened by excel menu [data> text> select file> file open wizard], or reformatted by [data>text to columns> select delimter'|'> finish]"
                  clog "to see help: " "repp find help"
    ;; \.)        if ! gittcheck_isgitproject; then warn "you need to move the git dir"; return 1; fi
                  clog "current git info from manifest"
                  gitt_initvar; aparam=${GITT_PROJECT}
                  cat ${REPPFILE_CSV}| grep -i ${aparam}|\
                      column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH |\
                      grep --color=always -iE "(^|${aparam})" |pCount -1
                  #repo forall . -c 'echo $REPO_LREV\|$REPO_RREV\|$REPO_UPSTREAM\|$REPO_DEST_BRANCH' 2>/dev/null | column -s'|' -t --table-columns REPO_LREV,REPO_RREV,REPO_UPSTREAM,REPO_DEST_BRANCH
    ;; *)         #local prnmsg='%6.6s|%12.12s|%8.8s|%-32.32s|%-74.74s|%.80s'
                  clog "to find keyword in all item, use 'repp find @all |grep <keyword>' ";
                  #printf "\e[1;33m${prnmsg} \e[0m\n" "REPO_LREV" "REPO_GROUP" "REPO_REMOTE" "REPO_RREV" "REPO_PROJECT" "REPO_PATH"
                  #filter in grep, width in colume, highlight in grep
                  cat ${REPPFILE_CSV}| colrm 7 40| grep -i ${aparam}|\
                      column -s'|' -t --table-columns REPO_LREV,REPO_GROUP,REPO_REMOTE,REPO_UPSTREAM,REPO_DEST_BRANCH,REPO_RREV,REPO_PROJECT,REPO_PATH \
                      --table-hide REPO_GROUP,REPO_UPSTREAM,REPO_DEST_BRANCH| grep --color=always -iE "(^|${aparam})" |pCount -1
                  #printf "${prnmsg}\n" $( cat ${REPPFILE_CSV} | grep -i --color=always ${aparam}| sed 's/|/ /g' ) | pCount
    esac

}



function reppbranch(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 manifest output file name
# $2 command
# $3 branch name or branch postfix
    local cmd=$1
    local name=$2

    case ${cmd} in
       ''|help) cat <<- EOF
		 info) gitt branch info                    # show only current git branch info (local, remote branch and commits)

		usage) repp branch list                    # list all remote branches for all gits (it takes times)
		   ex) repp branch list '*release*'        # find *release* matching branches (asterix need to be closed by colon)
		usage) repp branch create                  # show commands can create branch for all, some gits by pre/in/postfix
		usage) repp branch remove                  # show commands can revove branch for all, some gits
		   ex) repp branch create release          # show commands to create 'release' branch
		usage) repp branch checksum                # print local repo checksum and remote tracking branch checksum
		usage) repp branch compare                 # compare which git is diff between local and remote tracking branch
		usage) repp branch compare <remote>        # compare which git is diff among local, remote tracking, a remote branch.
		   ex) repp branch compare mig_230426      # compare between 3 branches (local, remote, mig_230426 branch)
EOF
    ;;  list|find)
                under "please run one of these 'git ls-remote' commands to check if branch is existed in remote\n"
                info "this command show all git project and show if the branch is existed"
                clog "prefix:" "repo forall -pc 'git ls-remote -h \${REPO_REMOTE} refs/heads/\$1_\${REPO_RREV}' ${name:-<branch-prefix>}"
                clog "postfix:" "repo forall -pc 'git ls-remote -h \${REPO_REMOTE} refs/heads/\${REPO_RREV}_\$1' ${name:-<branch-postfix>}"

                bar inline "check exact ${name} remote branche is existed for all gits"
                #showRUNQ y repo forall -c 'printf "%30s| %-70s\n" ${REPO_REMOTE} ${REPO_PROJECT} $(git ls-remote -h ${REPO_REMOTE} refs/heads/$1)' ${name}
                #test case all) repp branch list, repp branch list '*', repp branch list '*mas*',  exact) repp branch list m/master, repp branch list 'm/master'
                set -o noglob
                showRUN repo forall -c 'printf "\t\t >>>> [%10s] ${YELLOW}%-60s${NCOL}\n" ${REPO_REMOTE} ${REPO_PROJECT}; git ls-remote -h ${REPO_REMOTE} refs/heads/${1}' ${name:-*}
                set +o noglob
    ;;  create|new)
                under "please run one of these 'git push' commands to create branch in remote\n"
                info "<branch name> will be passing to 'git push' cmd in position of parameter \${1}"
                info "variable preview: \${REPO_REMOTE}|\${REPO_RREV} $(repo forall . -c 'echo ${REPO_REMOTE}\|${REPO_RREV}' 2> /dev/null)\n"
                clog "infix:" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
                clog "prefix :" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}_\${REPO_RREV}' ${name:-<branch-prefix>}"
                clog "postfix:" "repo forall -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${REPO_RREV}_\${1}' ${name:-<branch-postfix>}"
                echo
                clog "ex) infix only current git" "repo forall . -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
                clog "ex) infix for several gits" "repo forall xxx/yyy ppp/qqq/rrr -pc 'git push \${REPO_REMOTE} HEAD:refs/heads/\${1}' ${name:-<branch-name>}"
    ;;  remove|delete)
                under "please run one of these 'git push' commands to delete branch in remote\n"
                info "<branch name> will be passing to 'git push' cmd in position of parameter \${1}\n"
                clog "infix:" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
                clog "prefix :" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${1}_\${REPO_RREV}' ${name:-<branch-prefix>}"
                clog "postfix:" "repo forall -pc 'git push \${REPO_REMOTE} --delete \${REPO_RREV}_\${1}' ${name:-<branch-postfix>}"
                echo
                clog "ex) infix only current git" "repo forall . -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
                clog "ex) infix for several git " "repo forall xxx/yyy ppp/qqq/rrr -pc 'git push \${REPO_REMOTE} --delete \${1}' ${name:-<branch-name>}"
    ;;  checksum) ##don' use showRUN, md5sum includes showRUN command.
                bar inline "1. md5sum of local HEAD in all repository"
                repo forall -c 'git log -1 --pretty=format:%H%n' | md5sum

                bar inline "2. md5sum of remote all tracking branch in all repository"
                repo forall -c 'git ls-remote -h ${REPO_REMOTE} refs/heads/${REPO_RREV} | cut -f1' |md5sum
                #repo forall -c 'git ls-remote -h ${REPO_REMOTE} refs/heads/$1 | cut -f1' ${name:-${REPP_BRANCH}} |md5sum

                info "you can use 'repp branch compare' to get which git is different"
    ;;  compare)
                bar inline "generate branch info local, remote tracking branch, and specific remote branch"
                #repo forall -pc 'git diff --shortstat tagA tagB'
                fileA=$(mktemp); fileB=$(mktemp)
                repo forall -c 'printf "%s %s %s\n" $(git log -1 --pretty=format:%H%n) ${REPO_RREV} ${REPO_PROJECT}' > ${fileA}
                repo forall -c 'printf "%s %s %s\n" $(git ls-remote -h ${REPO_REMOTE} refs/heads/${REPO_RREV}) ${REPO_PROJECT}' > ${fileB}
                if [ -n "${name}" ]; then
                    fileC=$(mktemp)
                    repo forall -c 'printf "%s %s %s\n" $(git ls-remote -h ${REPO_REMOTE} refs/heads/$1) ${REPO_PROJECT}' ${name} > ${fileC}
                fi

                info "please compare command: vimdiff ${fileA} ${fileB} ${fileC}"
                info "please compare command: icdiff ${fileA} ${fileB} |more -60"
    ;;       *) reppbranch help
    esac
}



function reppinit(){
## ---------------------------------------------------------------------------
# repo init helper
# $1 short repo init command
    ##option handle
    local cmd="$1"

    case $cmd in
       help|'')    cat <<-EOF
			 usage) repp init -u <manifest-url> -b <manifest-branch> -m <manifest-name> -p <platform> -c
			                  --reference=<mirror-path> --depth=<depth> --repo-url=<repo-url>
			                  --no-clone-bundle --partial-clone --no-tags --mirror
				ex) repp init -u ssh://${USER}@vgit.lge.com:29440/honda/linux/manifest -b tsu_25.5my_release
				ex) repp init -u https://android.googlesource.com/platform/manifest -b android-12.1.0_r1
				ex) repp init -b lampauto_r_release -m all.xml
				ex) repp init -u ssh://lamp.lge.com:29418/platform/manifest.git -b lampauto_r_release --git-lfs
				     -m lampauto/lampauto-gm-recent.xml --reference=/data001/vc.integrator/mirror/lampauto_r_release/
				     --repo-url=ssh://lamp.lge.com:29418/repo/git-repo.git
                ex) repp init -u ssh://lamp.lge.com:29418/platform/manifest.git -b lampauto_r_release --dissociate
                ex) repp init -u ssh://${USER}@vgit.lge.com:29440/honda/linux/manifest -b tsu_25.5my_release --partial-clone --clone-filter=blob:none

EOF
            info 'please refer http://collab.lge.com/main/x/xYv4j'
            return 1
       ;; *) :
    esac


    #### parameter parsing
    local url revision manifest platform reference depth repo_url extra ret=0
    if ! options=$(getopt -l reference:,depth:,repo-url:,no-clone-bundle,partial-clone,no-tags,mirror -o b:m:p:u: -- "$@")
    then err 'please check "repo init --help"'; return 1; fi

    ##reset legacy positional parameter except $options
    eval set -- "$options"
    ##parse parameter from options using shift, which shifts the $1, $2, ... value sequencely
    while true; do
        $DEBUG [$1][$2]
        case $1 in
            ##when option has sub option, should shift 2 or just shift
            -u|--manifest-url)                                          url=$2;         shift 2;;
            -b|--manifest-branch)                                       revision=$2;    shift 2;;
            -m|--manifest-name)                                         manifest=$2;    shift 2;;
            -p|--platform)                                              platform=$2;    shift 2;;
            --reference)                                                reference=$2;   shift 2;;
            --depth)                                                    depth=$2;       shift 2;;
            --repo-url)                                                 repo_url=$2;    shift 2;;
            ##single option that need no additional sub value
            ##skip single option and remove getopt cmd
            -c|--current-branch)                                  extra="${extra} $1";  shift 1;;
            --no-clone-bundle|--partial-clone|--no-tags|--mirror) extra="${extra} $1";  shift 1;;
            --|*)                                                                  shift; break;;
        esac
    done

    #### parameter check
    ##if url has lamp and url is null, default url is lamp or return
    local sep='~'
    case ${url}$sep${revision} in
         $sep*lamp*) url="ssh://lamp.lge.com:29418/platform/manifest.git" ;;
         $sep*) err "-u manifest-url is necessary" ;;
         *$sep*) : ;;
    esac
    ##if reference dir is existed, set reference as default.
    if [ -z "${reference}" ];then reference="${reference:-${PATH_MIRROR}/${revision}}"; [ ! -d "${reference}" ] && reference=''; fi
    ##issue https://github.com/OP-TEE/manifest/issues/157
    if [ -z "${repo_url}" ] && [ "${url}" != "${url/lamp/}" ];then repo_url='ssh://lamp.lge.com:29418/repo/git-repo.git'; fi

    #### run repo command
    ##url handle with replication server
    local file_info=$(mktemp)
    cmd_repoinit="repo init ${url:+-u ${url}} ${revision:+-b ${revision}} ${manifest:+-m ${manifest}} ${platform:+-p ${platform}} ${reference:+--reference=${reference}} ${depth:+--depth=${depth}} ${repo_url:+--repo-url=${repo_url}} ${extra} $@"

    ##make final repo init cmd
    bar outline "executed command:" >> ${file_info}
    printf "${cmd_repoinit}\n" >> ${file_info}

    ##execute cmd
    reppcheck_initcmd ${cmd_repoinit}
    if [ "$?" -eq 1 ]; then ret=1; fi

    ##show repo info
    bar outline >> ${file_info}
    cat ${file_info}; rm -f ${file_info}

    ##go next step or not
    if [ "$ret" -eq 0 ]; then info "to repo sync?:[enter:continue| ctrl+c:break] "; reppsync;
    else err "'repp connect help' or 'repp init help'"; fi
}



function reppsync(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
# ex) reppsync
    local cmd=$1
    local opts="${@:2}"
    local preopt njobs

    case $cmd in
        help) cat <<- EOF
			usage) repp sync                # sync with default option
			usage) repp sync debug          # for debugging with --trace
			usage) repp sync <option>       # default option) --no-tags --no-clone-bundle --fail-fast
			   ex) repp sync --force-sync   # go current git root dir
			   ex) gitt go build            # show git path including 'build' and move to select
EOF
        ;; debug)   info "you can use permission check with 'repp connect' command"
                    preopt="--trace" ; njobs=1
        # -[[:digit:]] ) ##same to '*[0-9])'
        #           njobs=${cmd}
        #    -*)    opts="${cmd} ${opts}"
        ;;    *)
                    clog "-m" "event/branch_migration.xml  # use input manifest.xml (to check if manifest work before commit) "
                    clog "-d" "                            # back to manifest revision"
                    clog "-f" "                            # force sync with overwriting"
                    clog "--jobs-network=" "8              # count of network thread [default 1], 8 recommand"
                    clog "--jobs-checkout=" "8             # count of checkout thread [default 8], 24 recommand"
                    clog "--auto-gc" "                     # with garbage collection [default no]"
                    info "default cmd: repo sync --no-tags --no-clone-bundle --fail-fast -cj8"

                    read -p  $'\n\nPlease add option to repo sync [enter:auto| opts:-qcj4| ctrl+c:exit]: ' opts;
                    if [ -z $opts ]; then njobs=${NJOBS}; fi
    esac

    showRUN repo ${preopt} sync --no-tags --no-clone-bundle --fail-fast -cj${njobs:-8} ${opts}

    #"$@" 2> >(tee -a ${file_error})
    "$@" > >(tee -a ${file_error})
    case $? in
     0) ;;
     1) echo Generic error, usually because invalid command line options or malformed configuration;;
     2) echo Connection failed;;
     *) echo Unknown Error;;
    esac
}



function reppreset(){
## ---------------------------------------------------------------------------
# reset git repositories
# $1 target

    local cmd=$1
    case ${cmd} in
            help)   cat <<-EOF
				usage) repp reset          # reset all repository to original revision
				usage) repp reset check    # show reset result (details: repp show)
				usage) repp reset project  # remove legacy 'repo sync' info to 'repo sync' again.

				 info) gitt reset          # provide detail control for one repository
EOF
        ;;   '')    info "repp reset help : for more usage\n"
                    ## git reset --hard;   #reset to local lastest commit status.
                    ## git clean -xdf      #remove uncommitted change
                    showRUNQ y repo forall -cj${NJOBS} 'git reset --hard FETCH_HEAD; git clean -xdf'

                    #showRUN repo sync -dlvj${NJOBS} --force-remove-dirty
                    info "\nfinish reset all repositories, and reset FETCH_HEAD"
        ;;project)  info "you can repo sync without conflicting legacy objects"
                    showRUNQ y echo "
                    ${REPP_ROOT}/.repo/project.list
                    ${REPP_ROOT}/.repo/project-objects/
                    ${REPP_ROOT}/.repo/projects/"
                    rm  -rf ${REPP_ROOT}/.repo/project.list \
                    ${REPP_ROOT}/.repo/project-objects/ \
                    ${REPP_ROOT}/.repo/projects/
        ;;check|*)  showRUN repo status -vj${NJOBS}
                    info "\n\n reset to manifest revision and check if uncommited change existed"
    esac
}



function reppvertoggle(){
## ---------------------------------------------------------------------------
local repo_executor=${proFILEdir}/bin/_repo
local repo_launcher_backup=${REPP_PATH%/*}/__repo
local repo_launcher=${REPP_PATH%/*}/repo

## update repo newest
if [ -d "${repo_executor}" ];
then
    git -C ${proFILEdir}/bin/_repo pull
else
    git clone https://gerrit.googlesource.com/git-repo -b stable ${repo_executor}
fi

## back or restore
if [ -d "${repo_launcher_backup}" ];
then ## restore
    [ -L "${repo_launcher}" ] && rm -f ${repo_launcher} || ( err "cannot restore, plz check"; return 1 )
    mv ${repo_launcher_backup} ${repo_launcher}

    ## restore PATH
    [[ -v PATH_OLD ]] && PATH=${PATH_OLD}

else ## backup & change
    mv ${repo_launcher} ${repo_launcher_backup}
    ln -s ${repo_executor} ${repo_launcher}

    ## add path for priority
    ## if variable is not defined, backup PATH, ban re-enterd
    [[ -v PATH_OLD ]] || PATH_OLD=$PATH
    PATH=${repo_launcher}:$PATH
fi
}



function reppversion(){
## ---------------------------------------------------------------------------
# print information of repo
# $1 manifests file (default is current manifests)
    local file_log=$(mktemp)
    python3 $(which repo) --version > ${file_log}

    local VER cmd="$1"
    case $cmd in
             help) cat <<-EOF
			usage) repp version toggle         # change repo version newest & restore
			usage) repp version ver            # show only repp version number exactly
			usage) repp version                # show repo, git, python version
EOF
        ;; toggle) reppvertoggle; return 0
    esac

    ## only 3digit length version code is valid to compare old version
    VER=$(cat ${file_log} | grep "repo version"  |tr -dc '[:digit:]')
    [ -z $VER ] && { VER=$(repo --version | grep 'launcher version' |tr -dc '[:digit:]'); }
    if [ "$cmd" == "ver" ]; then echo ${VER:0:3} && return 0; fi

    #if VER is not integer, in case of error
    [[ ${VER} != ?(-)+([0-9]) ]] && VER=000

    [ -d "${REPP_PATH%/*}/__repo" ] && warn "you are using toggled version"
    echo "this version is expected to used, please check this version is matched to your local version"

    bar inline "expected"
    info "warning: this is the repo packaged with this project."
    $REPP_PATH/../repo/repo version

    printf "\n\n"
    bar inline "found"
    info "the local version currently you are using"
    bar inline "what"
    cat ${file_log}

    echo
    py_path=$(which python) >/dev/null
    py_ver="$(python --version 2>&1)"
    printf "[check] %s is working in [%s]\n" "${py_ver}" "${py_path}"

    bar inline "where"
    which repo
    which git

    if (( ${VER:0:3} < 230 )); then
        under "you need to upgrade 'repo' to use full functionality\n"
        clog "1. remove old .repo:" rm -rf ${REPP_ROOT}/.repo
        clog "2. download to dir:" git clone https://gerrit.googlesource.com/git-repo ${PATH_MIRROR}/repo2 --mirror
        clog "3. repo init with below command:" --repo-url=[${REPP_REPOURL}] --\> [${PATH_MIRROR}/repo2]
        pushd ${REPP_PATH} ; reppget_repcmd info ; popd
        clog "-->"
        echo "${REPP_CMD/${REPP_REPOURL}/${PATH_MIRROR}/repo2}"
        #| sed -e 's#--repo-url=${REPP_REPOURL}#--repo-url=${PATH_MIRROR}/repo2'
    fi
}



function reppcheck_initcmd(){
## ---------------------------------------------------------------------------
# run command, get return code and print guide
    local file_error=$(mktemp)
    local ret=1 #return 1 is success, 0 is fail
    echo "\$ $@"
    time "$@" 2> >(tee -a ${file_error})
    #"$@" | tee -a ${file_error}


    case $(cat ${file_error}) in
        help)                           echo "init error handler"
    ;; *fatal*|*fail*|*error*)          err "check error log [${file_error}]"
    ;; *Permission?denied*publickey*)   err "check error permission"
    ;; *)                               ret=0
    esac

    [ "$ret" -eq 1 ] && echo "check http://collab.lge.com/main/pages/viewpage.action?pageId=1620608725"
    return $ret
}


#ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject}
function reppssh_server(){
## ---------------------------------------------------------------------------
# check if server can access code-review server by SSH protocol
# SSH protocol is used in local server to get source from code-review sever
    local server=$1
    local port=$2
    local user=$3
    local passwd=$4
    local cmd=${@:5}


    under "ssh access [${server}] port [${port}]  ${user})"
    clog cmd "${cmd}"
    ret=$(sshpass -p "${passwd}" ssh -q ${user}@${server} -p ${port} bash <<SSH_COMMAND
    ${cmd}
SSH_COMMAND
)
}



function reppcheck_server(){
## ---------------------------------------------------------------------------
# check if server can access code-review server by SSH protocol
# SSH protocol is used in local server to get source from code-review sever
    local server=$1
    local user=$2
    local port=$3
    local gitproject=$4
    local branch=$5
    local ret
    local file_error="$(mktemp)"

    #local port=$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')
    bar inline "step2.1-ssh: check local if ssh is installed (checked by $ACCOUNT)"
    clog try "install proper version of ssh"
    if [ -x "$(command -v ssh)" ]; then  log "ssh is installed in [$(which ssh)]"; else err "ssh is not installed, plz install it"; fi

    if [ -z $oriserver ]; then reppconnect help && return 1;fi
    bar inline "step2.2-tcp: check remote if tcp port is well listened (checked by $ACCOUNT)"
    clog try "check port num is correct? firewall is active? internet is on?"
    showRUN timeout 5 bash -c "</dev/tcp/${server}/$port"
    if [ $? == 0 ];then echo "server $server over port $port is listened";
    else echo "server $server over port $port is not listened, please contact server manager"; fi

    bar inline "step2.3-sshd: check remote if ${user} can access ${server} on ${port}port (checked by ${user})"
    clog try "check port num is correct? check account and ssh-key is matched and registered?"
    #echo "ssh -T $user@$server -p $port -vvv 2> $file_error"
    : '
    echo \n| ssh -T $user@$server -p $port -vvv 2> $file_error

    case $(cat ${file_error}) in
        help)       echo "ssh connection error msg handler"
    ;; *success*)   echo "good, SSHD is active on port [$port] in server [$server], you can connect"
    ;; *Connection?refused*)
                    err "check log in ${file_error}"
                    grep -En "*Connection refused*" $file_error
                    err "check IP/PORT setting in (.ssh/config) with below"
                    ping $server -c2
                    return 1
    ;; *publickey*) err check publickey
                    read -p "go or stop? [enter:continue | ctrl+c:stop]"
    ;; *)           err "unknown error is occured, please check log [${file_error}]"
                    return 1
    esac
    '
    bar inline "step2.4-project: check remote if ${user} can access git project (checked by ${user})"
    clog try "check git name path is correct and can access"
    ret=$(ssh -q ${user}@10.158.7.50 -p 22 bash <<SSH_COMMAND
    ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject}
SSH_COMMAND
)
    [ -n "$ret" ] &&  echo "gitproject existed and accessed [${gitproject}]" || err "check git project is existed or permission allowed [${gitproject}]"

    bar inline "step2.5-branch: check remote if ${user} can access the branch on the project (checked by ${user})"
    clog try "check branch name path is correct and can access"
    #ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject} -b ${branch}
    ret=$(ssh -q ${user}@10.158.7.50 -p 22 bash <<SSH_COMMAND
    set -x
    ssh $user@$server -p $port gerrit ls-projects --prefix ${gitproject} -b ${branch}
SSH_COMMAND
)
    [ -n "$ret" ] &&  echo "branch existed and accessed [${branch}]" || err "check git branch is existed or permission allowed [${branch}]"

    under "you can check 'READ' accessibility for all branch & repository (wait 30s) (checked by ${user})\n"
    read -p "check accessibility for all repository  [enter:continue| ctrl+c:exit]: "

    ssh -q ${user}@10.158.7.50 -p 22 bash <<'SSH_COMMAND'
    mkdir -p ~/repo.test && cd ~/repo.test
    repo init -u ssh://vgit.lge.com:29440/honda/linux/manifest -b tsu_25.5my_release 2> /dev/null
    repo sync -qcj8 --no-tags --no-clone-bundle --fail-fast 2> /dev/null
    repo forall -qc bash -c '
    GERRIT=( "vgit_na:29420" "vgit_eu:29430" "vgit_as:29440" "vgit_adas:29550" "vgit_devops_test:29999" "lamp_review:29418" )
    for _item in ${GERRIT[@]};do
        if [ ${_item%:*} = "${REPO_REMOTE}" ]; then
            [ -z "$(ssh $REPO__${USER}@$0 -p ${_item#*:} gerrit ls-projects --prefix ${REPO_PROJECT} -b ${REPO_RREV} --limit 1)" ] && printf "[ERROR] project:%-50s path:%s" "${REPO_PROJECT}" "${REPO_PATH}"
        fi
    done
    ' vgit.lge.com  2> /dev/null
SSH_COMMAND
#$(revvserver_item ${oriserver} subdomain) #vgit.lge.com
#repo forall -c 'echo \${REPO_REMOTE}:\${REPO_PROJECT}:\${REPO_PATH}:\${REPO_LREV}:\${REPO_RREV}' > ~/repo.test/repo.result
        #[ ${_item%:*} = "${REPO_REMOTE}" ] && printf "[%-60.50s] " "${REPO_I}/${REPO_COUNT}/${REPO_PROJECT}" && ssh $REPO__${USER}@$0 -p ${_item#*:} gerrit ls-projects --prefix ${REPO_PROJECT} -b ${REPO_RREV} --limit 1
}



function reppconnect(){
## ---------------------------------------------------------------------------
# check connection and report error
# $1 server
# $2 port
# $3 password
    reppcheck_initvar reppgittrevv

    local cmd="$1"
    case ${cmd} in
       help)    cat <<-EOF
			  usage) repp connect [server]  [user]          [gitproject]   [branch]
			 -----------------------------------------------------------------
			default) repp connect ${REPP_REMOTE} $ACCOUNT   ${REPP_PROJECT}    ${REPP_BRANCH}
			     ex) repp connect na        testaccount     tiger/tools  tiger_release
			     ex) repp connect na        joongkeun.kim   tiger/tools  tiger_release
			     ex) repp connect na        testaccount     tiger/tools
			     ex) repp connect na        testaccount
			     ex) repp connect na        testaccount
			     ex) repp connect
EOF
                return 1;
    ;;     *) :
    esac

    local user oriserver server gitproject branch port
    local temp_p=$(expr "${REPP_URL}" : ".*[0-9]/\(.*\)\..*")
    [ -z "$4" ] && info "use default branch: ${GITT_BRANCH:-${REPP_BRANCH}}"        ;branch=${4:-${GITT_BRANCH:-${REPP_BRANCH}}} ;
    [ -z "$3" ] && info "use default git project: ${GITT_PROJECT:-${REPP_PROJECT}}" ;gitproject=${3:-${GITT_PROJECT:-${REPP_PROJECT}}} ;
    [ -z "$2" ] && info "use default account: $USER"                                ;user=${2:-$USER} ;
    [ -z "$1" ] && info "use default server: ${GITT_REMOTE:-${REPP_REMOTE}}"        ;oriserver=${1:-${GITT_REMOTE:-${REPP_REMOTE}}} ;
    server=$( revvserver_item ${oriserver} subdomain ); port=$(revvserver_item ${oriserver} port)

    clog "should be this format:ex)" "[testaccount][$oriserver][$server][$gitproject][$branch]"
    dnlog [$user] [$server] [$oriserver] [$gitproject] [$branch]

    under "step1: check gerrit permission for ${user} from WEB(HTTP) by account admin[${ACCOUNT}]\n"
    showRUN revvcheck_server ${oriserver} log                                              ;wave
    showRUN revvcheck_account ${oriserver} ${user} log                                     ;wave
    showRUN revvcheck_permission ${oriserver} ${user} ${gitproject} ${branch} read         ;wave

    under "step2: check git permission for ${user} from SERVER(SSH) user[${user}]\n"
    showRUN reppcheck_server ${server} ${user} ${port} ${gitproject} ${branch}
    #showRUN reppcheck_server ${buildserver} ${port} ${user} ${repo init cmd}
}



function reppfind_repodir(){
## ---------------------------------------------------------------------------
# find input-path up and down,
# $1:path name, $2:max depth to sub dir, $3:print or not
# ex) reppfind_repodir .repo 5
# ex) reppfind_repodir .git 2
    local T=$PWD
    local target=${1:-.repo}
    local down_depth=${2:-2} #default value:2

    ## find in sub directory with depth
    readarray -t REPP_PATH_ALL < <(find . -maxdepth ${down_depth} -path "*${target}" |sort)
    case ${#REPP_PATH_ALL[@]} in
    1)  ## found one in sub dir
        REPP_PATH=$(readlink -f ${REPP_PATH_ALL[0]})
        ;;
    0)  ## not found, so find in parent directory upto $HOME
        while [[ "${PWD}" =~ "${HOME}" ]]; do
            if [ -d ${target} ]; then break; fi
            pushd ..
        done
        if [ -d ${target} ]; then REPP_PATH=$(readlink -f ${target});else REPP_PATH='';fi
        pushd -0 && dirs -c
        cd $T
        ;;
    *)  ## found multiple dir in sub dir
        under "found repo in subdir [count: ${#REPP_PATH_ALL[@]}]\n"
        printf "%s\n" "${REPP_PATH_ALL[@]// /\n}"
        REPP_PATH=''
        ;;
    esac
}



function repp_initvar(){
## ---------------------------------------------------------------------------
# find input-path up and down,

    ## move to repo root
    reppfind_repodir .repo/manifests 5
    ## set variable REPP if manifest dir exists
    if [ ! -d "${REPP_PATH}" ];then $DEBUG ${REPP_PATH_ALL[@]}; $DEBUG "you are not in repo project, please check !"; return 1;fi
    REPP_ROOT=${REPP_PATH%/.repo*}
    ## 이미 초기화된 dir인지 판단.
    if [ ! -f "${REPP_ROOT}/.repo/project.list" ] || [ ! -d "${REPP_ROOT}/.repo/projects" ] || [ ! -d "${REPP_ROOT}/.repo/project-objects" ];
    then  err "repo sync is need, please check" ; return 1
    else  REPP_INIT=1 #repo sync까지 완료
    fi

    (( "${REPP_INIT}" > 1 ))  && [ -d "${REPP_PATH}" ] && [[ "${REPP_PATH}" =~ "${REPP_ROOT}" ]] && return 0


    pushd ${REPP_PATH}
    REPP_DIR=${REPP_ROOT}/.repp
    [ -f ${REPP_ROOT} ] || mkdir -p ${REPP_DIR}

    ##전체 filelist
    REPPFILE_STATUS=${REPP_DIR}/repp.status             #현재 repo의 변경 파일이름과 상태(status)를 저장
    REPPFILE_COMMIT=${REPP_DIR}/repp.commit             #현재 repo의 변경 파일이름과 내용(commit)을 저장
    REPPFILE_XML=repp.xml                               #repp mani에서 전체 manifest를 하나의 manifest 파일로 생성시 결과파일
    REPPFILE_JSON=${REPP_DIR}/repp.json                 #repo manifest로부터 생성된 repo json 파일
    REPPFILE_JSON_REMOTE=${REPP_DIR}/repp_remote.json   #repp.json에서 remote정보만 추출한 파일, /tmp/에 임시저장됨
    REPPFILE_TXT=${REPP_DIR}/repp.txt                   #위 json을 parsing한 결과를 formatted txt로 저장한 파일, 구분자(|)
    REPPFILE_CSV=${REPP_DIR}/repp.csv                   #위 json 파일과 repo forall을 비교하여 최종 생성된 파일 DB, 구분자(|)로 excel로 읽을때는 변환필요.
                                                        #repp.csv항목은 repo forall list와 동일하며, 세부 git정보만 더 포함되어 있다.
    #repp.csv.json                                      #manifest json을 parsin하여 생성된 DB
    #repp.csv.repo                                      #repo forall로부터 생성된 DB, json파일로 생성이 어려울때 최종사용하게 된다.
    #repp.csv.lfs                                       #repp.csv항목중에 git lfs로 구성된 git list
    #repp.csv.dup                                       #repp.csv항목중에 git이 2개이상인 git list
    #repp.csv.submodule                                 #repp.csv항목이 소유한 git submodule list
    REPPFILE_FORALL=${REPP_DIR}/reppforall.csv          #repp forall 작업을 진행하기 위한 script. repp forall gen로 생성됨. 구분자(,)
    REPPFILE_SCRIPT=${REPP_DIR}/reppscript              #repp forall에서 사용하는 script를 저장하는 파일들이다. in.tm.pre.post등이 존재한다.
    REPPSCRIPT_IN=${REPPFILE_SCRIPT}.in.sh              #repp forall -c <cmd> 부분으로 만들어진 임시 script
    REPPSCRIPT_OUT=${REPPFILE_SCRIPT}.out.sh            #pre + in + post = out으로 최종 실행되는 script

    #reppforall.csv.tmp                                 #reppforall.csv를 실제 실행할때 구분자(`)로 변경하여 처리하기 위한 중간파일


    #REPP_PROJECT=$(git remote -v |grep fetch | sed -E 's#.*[0-9]+(.*).git.*$#\1#')
    #REPP_PROJECT=$(git config --get-regexp remote.*.url  |head -1|cut -d' ' -f2)
    REPP_PROJECT=$(git config --get-regexp remote.* |grep -Ee "(projectname|url)" |head -1|grep -Po '\w/\K.\w+[^?]+')
    REPP_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null| sed 's:.*/::')  #GITT_BRANCH
    REPP_REVIEW=$(git config --get-regexp remote.*.review|cut -d' ' -f2|head -1)        #GITT_REVIEW
    REPP_URL=$(git config --get-regexp remote.$(git remote|head -1).url|cut -d' ' -f2|head -1) #GITT_URL

    #REPP_REMOTE=$(revvserver_item $(git remote -v |grep fetch | grep -oP '(?<=:)[0-9]+(?=/)') remote)
    if [[ -z $REPP_REMOTE ]]; then
        REPP_REMOTE=$(cat ${REPPFILE_JSON} 2>/dev/null |jq -r '.default.remote')
        if [[ -z "${REPP_REMOTE}" ]] || [[ "${REPP_REMOTE}" == "null" ]] ; then
            reppget_repcmd
            local tmp=$(git config --get-regexp ^remote.*.url | sed 's/.*:\([0-9]*\).*/\1/')
            REPP_REMOTE=$(grep '<remote ' ${REPPFILE_MANI} | sed -n 's/.*name="\([^"]*\)".*/\1/p')
        fi
    fi
    if [[ -z "${REPP_REMOTE}" ]] || [[ "${REPP_REMOTE}" == "null" ]] ; then warn "REPP_REMOTE is null, must check"; fi

    #REPP_URL=$(git remote -v |grep fetch |awk '{print $2}')
    #REPP_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}| sed 's:.*/::')
    REPP_REPOURL=$(cat ../repo/.git/config |grep url|sed 's/.*= \(.*\)/\1/')
    #REPP_REF=$(cat ../manifests.git/config |grep reference|sed 's/.*= \(.*\)/\1/')
    REPP_REF=$(git config --get-regexp repo.reference |head -1|cut -d' ' -f2)
    REPP_MIRR=$(git config --get-regexp mirror |head -1|cut -d' ' -f2)
    REPP_GROUPS=$(git config --get-regexp manifest.groups |head -1|cut -d' ' -f2)
    REPP_COUNT=$($REPP_PATH/../repo/repo list |wc -l)

    REPP_REMOTELIST=( $(repo manifest 2>/dev/null |grep review | sed -E 's#.*name="([^"]*[^"]*)".*#\1#') )
    REPP_REVIEWLIST=( $(repo manifest 2>/dev/null |grep review | sed -E 's#.*review="([^"]*[^"]*)".*#\1#') )
    REPP_INIT=2 #repp script 적용완료
    popd

    return 0
}



function gitt_initvar(){
## ---------------------------------------------------------------------------
# find input-path up and down,

    local temp
    if ! gittcheck_isgitproject; then
        GITT_REMOTE=; GITT_PROJECT=; GITT_BRANCH=; GITT_PATH=; GITT_URL=; GITT_REVIEW=;
        return 1
    fi

    ##readarray -t GITT_REMOTE < <(git remote -v |cut -f1|uniq)
    GITT_REMOTE=$(git remote|head -1)

    #git config --get-regexp remote.$GITT_REMOTE |sort|grep -Ee "(projectname|url)"
    #git config --get-regexp remote.*.projectname|cut -d' ' -f2
    temp=$(git config --get-regexp remote.* |grep -e "projectname" |head -1|cut -f2 -d' ')
    if [ -n "${GITT_PROJECT}" ] && [ "${temp}" = "${GITT_PROJECT}" ]; then return 0; else GITT_PROJECT=${temp}; fi
    if [ -z "${GITT_PROJECT}" ]; then GITT_PROJECT=$(git config --get-regexp remote.* |grep -Ee "(url)" |head -1| sed -E 's#.*://[^/]+/(.*)#\1#'); fi

    #NEEDTO WORK: find more secure way to get current branch revision
    GITT_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null| sed 's:.*/::')
    [ -z "${GITT_BRANCH}" ] && GITT_BRANCH=$(git branch -ar |grep -e '->' |sed -E 's#.*[/|>](.*)$#\1#')
    [ -z "${GITT_BRANCH}" ] && GITT_BRANCH=$(git branch -ar |grep -e 'm/' |sed -E 's#.*[/|>](.*)$#\1#')
    [ -z "${GITT_BRANCH}" ] && warn "'repo start <workingbranch> --all' is recommended"
    [ -z "${GITT_BRANCH}" ] && ( err "check your branch with 'git branch'
    repo start <working branch> --all       # make working branch
    source repp                             # reload repp script"
    )

    GITT_URL=$(git config --get-regexp remote.${GITT_REMOTE}.url|cut -d' ' -f2|head -1)
    GITT_REVIEW=$(git config --get-regexp remote.*.review|cut -d' ' -f2|head -1)
    GITT_REVIEW=${GITT_REVIEW:="${GITT_URL/${GITT_PROJECT}/}"}
    GITT_PATH=$(git rev-parse --show-toplevel)
    return 0
}



function revv_initvar(){
## ---------------------------------------------------------------------------
# find repo, gitt, review variable
    local ret=0
    local key_id key
    #default initial gerrit API key is na (vgit_na).


    #key_id=$(revvserver_item ${GITT_REMOTE:-${REPP_REMOTE:?"run 'repp_initvar' first"}} key)
    key=$(revvserver_item ${GITT_REMOTE:?'ERROR: check server info!!'} pass)

    if (( 40 > ${#key} )); then
        warn "if problem continue, check gerrit http key value in [~/.key_server] \n
        you can generate file [.key_server] : cmd[revvserver gen] and add access key"
        ret=1
    fi

    # if ! revvcheck_server ; then
    #     err "please check correct account&key is saved using revv server "
    #     ret=1
    # fi

    return $ret
}


function reppcheck_initvar(){
## ---------------------------------------------------------------------------
# find repo, gitt, review variable

    local cmd=$1
    local besttry=false
    if  [ "${cmd:0:1}" = "O" ]; then besttry=true ; fi
    ## --------------------------------------------------------
    if [[ "${cmd}" =~ "repp" ]]; then
        if ! repp_initvar ;then #repo project가 아닐때
            if ! "$besttry" ; then warn "repo is not initialized well, please check" && return 1;fi
        else
            [[ "${cmd}" =~ "mani" ]] || repp_initdb
        fi
    fi
    ## --------------------------------------------------------
    if [[ "${cmd}" =~ "gitt" ]]; then
        if ! gitt_initvar ; then
            [[ ! "${cmd}" =~ "go" ]] && { warn "you are not in git project" && return 1; }
        fi
    fi
    ## --------------------------------------------------------
    if [[ "${cmd}" =~ "revv" ]]; then
        if ! revv_initvar ; then warn "you don't have a permission, please check" && return 1;  fi
    fi
    return 0
}



function gittsshcmd(){
## ---------------------------------------------------------------------------
# find replication server
# $1 server-url
# $2 port-number
    local server_port=${REPP_URL#*@}
    local server=${1:-${server_port%:*}}
    local user=${2:-${USER}}
    local port=${3:-$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')}

    case $cmd in
       help) cat <<- EOF
				usage) gitt sshcmd checkserver                         # show current branch info
				usage) gitt branch delete|remove <name>         # delete branch with exact-name, with confirm 'y'
				   ex) gitt branch create my_temp_branch        # create my_temp_branch, with confirm 'y'
				 info) gitt diff                                # see gitt diff to compare branch
EOF

    ;; checkserver)
        if [ -z "${server}" ] || [ -z "${port}" ] ; then info "usage) revv server status vgit.lge.com 29999"; return 1;fi
        ping $server -s 1016 -c 4 -A
        printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
        if [ $? -ne 0 ]; then continue; fi
        ssh ${user}@$server -p $port -o ConnectTimeout=2 -o ConnectionAttempts=1 gerrit show-caches
        if [ $? -ne 0 ]; then continue;fi
        printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
        echo "please check 1) ipg/ewma from ping, 2) AvgGet from gerrit connection"

    ;; *) gittbranch help
    ;; esac

}




shortname_of_branch() {
    local input="$1"
    # branch name에서 뒤에서부터 _가 2번 나올때까지 삭제하고 prefix만 취해서 검색
    local out="${input%_*_*}";
    if [ ${#out} -gt 12 ] || [ ${#out} -le 6 ]; then echo "${input:0:10}" ; else echo "$out"; fi
}


function gittinfo(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# TODO: clone command
    local TEMP THEAD
    local review_gerrit=admin/repos

    ## git path
    bar inline "git path"
    clog 'current git path:' "${GITT_PATH}"

    ## git remote info
    ## "error: must check" must be checked!!!
    bar inline "show all remote info"
    clog ' remote:' ${GITT_REMOTE:="error: must check"}                        #remote name
    clog 'project:' ${GITT_PROJECT:="not defined"}                             #project name
    clog ' branch:' ${GITT_BRANCH:="error: must check"}                        #branch name
    clog ' review:' ${GITT_REVIEW:="not defined"}                              #git review site
    clog '    url:' ${GITT_URL:="error: must check"}                           #git review url

    ##review system check
    case $(git config --get-regexp remote|cut -d' ' -f2) in
      help)             echo "site customization"
    ;;*github.com*)     GIT_SITE=$(printf "https://%s" ${GITT_URL}|sed -E 's#^.*github.com:(.*.git)$#http://github.com/\1#')
    ;;*vgit.lge.com:*)
        case ${GITT_URL} in #remove starting string 'vgit.lge.com:29420/'
           *vgit.lge.com:29420*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'na' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29430*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'eu' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29440*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'as' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29550*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'adas' ${review_gerrit}/${GITT_URL##*0/} )
        ;; *vgit.lge.com:29999*) GIT_SITE=$(printf "http://vgit.lge.com/%s/%s" 'devops_test' ${review_gerrit}/${GITT_URL##*9/} )
        ;;                    *) GIT_SITE="please add site custom setting" ;;
        esac
    ;;''|*)             GIT_SITE=$(printf "%s/${review_gerrit}/%s" "$(echo ${GITT_REVIEW}|sed -E 's#(.*)[/]$#\1#')" ${GITT_PROJECT} )
    ;;esac
    clog "source repository url :" ${GIT_SITE}                                     #http review url
    clog "review commit url     :" $(echo "$GIT_SITE" |sed -E "s#http:(.*)admin/repos/(.*)#https:\1q/project:\2+branch:"${GITT_BRANCH}"#")
    clog "source browser gitiles:" ${GIT_SITE/"${review_gerrit}"/"plugins/gitiles"}/+/refs/heads/${GITT_BRANCH}                #source from gitiles
    clog "source browser gerrit :" ${GIT_SITE/"${review_gerrit}/"/"gitweb?p="}.git\;a=shortlog\;h=refs/heads/${GITT_BRANCH}    #source from gerrit

    ## git clone & push command
    bar inline "git clone & push commands"
    clog " git clone:" "git clone ${GITT_URL} -b ${GITT_BRANCH}"               #make git clone command
    TEMP=$(printf "git push $GITT_REMOTE HEAD:refs/heads/%s" ${GITT_BRANCH})
    clog " git push review:" ${TEMP/\/heads/\/for}                             #make git push command for
    clog " git push direct:" $TEMP                                             #make git push command head

    ## git recent local command
    bar inline "recent local commit info"                                      #extract last commit info with only 1000 character
    git --no-pager show --stat --color=always --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset %C(blue)<%an>%Creset  %<(1000,trunc)' HEAD

    # if ! diff -qB <(git rev-parse FETCH_HEAD) <(git rev-parse HEAD); then       #current head is changed
    THEAD=$(git log -1 --pretty=format:%H%n)
    if ! git ls-remote -h ${GITT_REMOTE}| grep "$THEAD";then
        warn "git changed: local and remote is differ"
        git --no-pager log --color=always --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset %C(blue)<%an>%Creset' --abbrev-commit --date=relative HEAD.."$THEAD"
    fi

    ## git submodule & lfs
    pushd "${GITT_PATH:?"You are not in git project"}"
    bar inline "git submodule & git lfs"
    ## sub module 정보가 있으면 출력
    if [ -f .gitmodules ]; then info "$( cat .gitmodules|grep -oP "(?<=path \= ).*" |xargs -I{} bash -c '[ -e {}/.git ] && echo "this git HAS active git-submodule: [{}]" || echo "this git has not active git-submodule: [{}]"' )"; fi
    if [ ! -f .gitmodules ] && [ -n "$(awk -v VAR=${GITT_PATH} 'VAR~$2{print $2}' ${REPPFILE_CSV}.submodule 2>/dev/null)" ]; then info "this git IS git-submodule: [${GITT_PATH/$REPP_ROOT/}]"; fi
    ## lfs 정보가 있으면 출력
    if [ -f "${REPPFILE_CSV}.lfs" ] && [ -n "$(grep ${GITT_PATH/$REPP_ROOT\//} ${REPPFILE_CSV}.lfs)" ]; then info "this git HAS git-lfs file"; git lfs ls-files; fi
    popd

    ## git last sync time
    bar inline "last synced time"                                              #extract sync time
    oldIFS=${IFS}; IFS='';
    if [ -f ${GITT_PATH}/.git/FETCH_HEAD ]; then clog "last manifest-synced date: " $(stat -c %y ${GITT_PATH}/.git/FETCH_HEAD );
    else clog "last manifest-synced date(check date of files below):" "\n$(ls -lct ${GITT_PATH}/.git| tail -1)";fi
    IFS=${oldIFS}

    bar inline "show branchout list from current branch within 4 months (botton is newest)"
    remote_commits=$(git ls-remote -h ${GITT_REMOTE} refs/heads/$(shortname_of_branch ${GITT_BRANCH})*)

    # 최근 4개월간 commit중에서 branch-out된 브랜치를 모두 listup하기위해, 해당 commit에 맞는 branch를 출력한다.
    local tmp
    git log --since="4 months ago" --pretty=format:'%H %ci <%an> %s' --reverse | while read -r sha; do
        tmp=${sha:67} #author 시작되는 column
        printf "$remote_commits" | grep --color=never "${sha%% *}" && printf "%2s ${green}%s ${magenta}%s> ${blue}%s${NCOL}\n" "" "${sha:41:25}" "${tmp%%>*}" "${tmp#*>}"
    done
}



function gittshow(){
## ---------------------------------------------------------------------------
# show commit history by git log, or show commit by git show
# $1: "number of commit" or "commit sha1"
    #topic/working branch
    local depth="${1:-15}"

    if [[ ${#depth} -gt 3 ]] && [[ ${depth} =~ ^[0-9a-f]+$ ]]; then
        bar outline "call native git"
        git show  --pretty=fuller --stat ${depth}
        return 0
    fi

    bar outline "gitt show is based on command: git log "
    bar inline "git commit history with option (to see all branche, gitt show 15 --all)"
    showRUN git log --decorate --graph -n${depth} --pretty=format:'%Cred%h -%C(yellow)%s %Cgreen(%ci) %C(blue)<%an>%Creset'

    bar inline "git commit history with diff file list"
    echo "filter: --since(=after), --before(=until)"
    echo "date  : 6 hour, 2-day, 2-week, 1-month, 1-year"
    clog "ex:" "--since=2-weeks, --since=04:24, --before=6-hours, --after=2022-11-10 --before=2022-11-20-23\n"
    read -p "input add option [default:--pretty="short" --name-only with your input option] "

    bar inline "file name only (press 'q' to stop)"
    #git log --color=always --pretty="short" --name-only ${reply} --pretty=format:'%Cred%h -%C(yellow)%s %Cgreen(%ci) %C(blue)<%an>%Creset' |more -60
    git log --color=always --pretty="short" --name-only ${reply} --pretty=format:'%Cred%H %Cgreen(%ci) %n%C(yellow)%s %C(blue)<%an>%Creset'

    clog "to see only modified file & contents, not add/delete files:" "git log -p --color=always --pretty=oneline --diff-filter=M ${reply}"
}



function formatprint(){
## ---------------------------------------------------------------------------

    local cmd=$*
    local index=0 line;

    #cmd preprocessor
    case ${cmd} in
                 help) echo "pre-process cmd"
    ;;   *git?status*) under "file changes list\n"
    ;;              *) echo "not found"
    esac

    readarray -t resultline < <( ${cmd[*]} )
    #resultline=("${cmd[*]}" "${resultline[@]}")
    #declare -p resultline

    ##read one line from array "${resultline[@]}"
    ##for line in "${resultline[@]}"; do while read item; do
    printf "%14s | %-14s -- \t%s\n" "indexed area" "working tree" "filelist"
    echo ${linemi}
    for line in "${resultline[@]}"; do
        #echo "KJK:[${line:0:1}][${line:1:1}]"
            ##custom handler for each item.
            case ${line:0:1} in
                 help)   :
            ;;    '#')   bar inline "file changes in branch: ${line}"
            ;;    '?')   printf "%14s | " "new"
            ;;    '!')   printf "%14s | " "new"
            ;;    ' ')   printf "%14s | " ""
            ;;    'A')   printf "%14s | " "added"
            ;;    'M')   printf "%14s | " "modified"
            ;;    'D')   printf "%14s | " "deleted"
            ;;    'T')   printf "%14s | " "type changed"
            ;;    'R')   printf "%14s | " "renamed"
            ;;    'C')   printf "%14s | " "copied"
            ;;    'U')   printf "%14s | " "unmerged"
            ;;      *)   clog "must classfied"  "${line}"
            esac
            case ${line:1:1} in
                 help)   :
            ;;    '?')   printf "%-14s -- \t%s\n" "untracked" "${line:3}"
            ;;    '!')   printf "%-14s -- \t%s\n" "ignored" "${line:3}"
            ;;    ' ')   printf "%-14s -- \t%s\n" "tracked" "${line:3}"
            ;;    'A')   printf "%-14s -- \t%s\n" "added" "${line:3}"
            ;;    'M')   printf "%-14s -- \t%s\n" "modified" "${line:3}"
            ;;    'D')   printf "%-14s -- \t%s\n" "deleted" "${line:3}"
            ;;    'T')   printf "%-14s -- \t%s\n" "type changed" "${line:3}"
            ;;    'R')   printf "%-14s -- \t%s\n" "renamed" "${line:3}"
            ;;    'C')   printf "%-14s -- \t%s\n" "copied" "${line:3}"
            ;;    'U')   printf "%-14s -- \t%s\n" "unmerged" "${line:3}"
            esac
            #printf "%${width}s\n" "${item}"
            #index=$(( ++index % ${#cmd[@]} ))
    ##done <<< "${line}"; done
    done
}



function gittcommit(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: number of commit
# $2: other option such as --all (all branch)
    local cmd="$1"
    local opt="${@:2}"
    case $cmd in
       auto)    msg=$(date +"%y%m%d:%H%M")
                git commit -m "${msg}: ${opt:-test}"
                git show --stat --oneline HEAD
                clog "[run]" "git push $GITT_REMOTE HEAD:refs/heads/${GITT_BRANCH}"
    ;; reset)   gittreset help
    ;; info)    formatprint git status -s --porcelain
                printf "\n\n"
                read -p "to see diff with cached in detail [ enter:compare| line:compare with line | q(ctrl+c):break ]: "
                case "$REPLY" in
                    help) clog "you can use with options:" "git diffi --line-numbers"
                ;;  line) git difftool --extcmd 'icdiff --line-numbers'
                ;;  *) git difftool --extcmd 'icdiff'
                esac
                if [ $? -ne 0 ];then echo "need to install 'sudo apt-get install icdiff'"; fi
    ;; help|*)    cat <<-EOF
				usage) gitt commit info         # show commit info and diff with cached
				usage) gitt commit auto         # add auto commit
				   ex) gitt commit auto misc    # add auto commit with msg 'misc'
				usage) gitt commit reset        # show useful reset command

				 info) gitt diff                # diff advanced with HEAD, HEAD^, staged, unstaged, revision
				 info) gitt info                # overall info for current git
				 info) gitt branch info         # branch info
EOF
    esac
}



function gittbranch_info(){
## ---------------------------------------------------------------------------
# show branch local & remote
# $1 all or filter

    ## local branch
    #list option must be wrapped with quoat ex) --list '*relese*'
    bar inline "info: branch local"
    clog "[local]" "* marked is current branch"
    showRUN git branch -vv

    ## remote branch
    bar inline "info: branch remote"
    clog "[remote]" "tracking branch"
    echo ${GITT_BRANCH}

    ## remote branch which are same to local HEAD
    bar inline "find remote branch which are at same local HEAD"
    clog "[always latest]" "read from remote live"
    git ls-remote -h ${GITT_REMOTE}| grep $(git log -1 --pretty=format:%H%n)
    if [ $? -eq 0 ]; then warn "local branch is same to remote branch";
    else warn "there is no remote branches same to current HEAD pointing, please below log"; fi

    local tmp=$(shortname_of_branch ${GITT_BRANCH})
    bar inline "git log the related branches(${tmp}), tag info omitted (last 4 months)"
    git log --color=always --graph --decorate --pretty=format:'%Cred%h%Creset %s %Cgreen(%cr)%Creset %C(red)%d%Creset' --since="4 months ago" \
        $(git for-each-ref --format='%(refname:short)' refs/heads/ | grep ${tmp}) |sed -E 's/tag:[^,]*,? ?/|/g'
    echo
    info "if you want to see omitted TAG infomation (${red}|${NCOL}) use 'git loga'"
}



function gittbranch_list(){
## -------------------- -------------------------------------------------------
# show branch local & remote
# $1 all or filter
    local opt=$1
    local filter

    read -p "'git fetch' is needed to get recent branch details [enter:continue| ctrl+c:break] :"
    git fetch --all
    bar inline "remote tag] recent 20 by date (bottom is newest create tag)"
    echo "get all branches and sort by date recent its tag"
    showRUNQ "git for-each-ref --color=always --sort=creatordate refs/tags \
    --format='%(color:yellow)%(committerdate:short) %(color:red)%(objectname:short) %(color:green)%(refname:short) %(color:blue)%(authorname)%(color:reset) %(contents:subject)' | tail -20"


    bar inline "remote branch] recent 20 by date (bottom is newest commit added)"
    showRUNQ "git for-each-ref --color=always --sort=committerdate refs/remotes \
    --format='%(color:yellow)%(committerdate:short) %(color:red)%(objectname:short) %(color:green)%(refname:short) %(color:blue)%(authorname)%(color:reset) %(contents:subject)' | tail -20"


    # echo "branch: remote all with filter (${filter:-all}) in remote repository"
    # set -o noglob
    # [ -z "${opt}" ] && filter="" || filter="--list *${opt}*"
    # set +o noglob

    # bar inline "lookup remote branch ${filer}"

    # clog "[always latest]" "read from remote live"
    # showRUN git ls-remote -h ${GITT_REMOTE} refs/heads/${opt} | more -60

    under "find: sort by recently updated branches by new commit findkey: ${opt:-'*'} (bottom is newest commit added)\n"
    # echo "shows the branches downloaded when git fetch equivalent command was executed"
    # clog "run 'git pull'" "to fetch all latest remote branches"
    #set -o noglob
    #[ -z "${opt}" ] && filter="" || filter="--list *${opt}*"
    #showRUN git branch -rvv --sort=committerdate ${filter} | more -60
    #set +o noglob
    showRUNQ git branch -rvv --sort=committerdate --list ${opt} | tail -60
}


function gittbranch(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 command
# $2 branch name or branch postfix
    local cmd=$1
    local name=$2
    local target=$3

    case $cmd in
       help) cat <<- EOF
				usage) gitt branch info                         # show current branch info
				usage) gitt branch list <''|name-filter>        # show remote recent 20 tag/branches
				   ex) gitt branch list *my*                    # find branches including 'my'
				usage) gitt branch create|new empty             # show guide to create empty branch
				usage) gitt branch create|new <name>            # create new branch with exact-name, with confirm
				usage) gitt branch delete|remove <name>         # delete branch with exact-name, with confirm 'y'
				   ex) gitt branch create my_temp_branch        # create my_temp_branch, with confirm 'y'
				usage) gitt branch diff <branchA> <branchB>     # compare commit history between 2 branches
				 info) gitt diff                                # see gitt diff to compare branch by snapshot not history
EOF
    ;; create|new)  if [ -z "${name}" ]; then err "branch name must be input" && return 1;fi
                if [[ "${target}" =~ 'empty' ]]; then
                    info "to create branch with empty commit"
                    echo "git switch --orphan <new-branch-name> #switch to new empty branch"
                    echo "git commit --allow-empty -m 'Initial commit to create branch' #add empty commit"
                    echo "git push ssh://vgit.lge.com:29440/honda/con/autosar HEAD:refs/heads/<branch-name>"
                fi

                bar inline "create branch: new branch will be created from current HEAD"
                showRUNQ y git push ${GITT_REMOTE} HEAD:refs/heads/${name}

    ;; delete|remove)  if [ -z "${name}" ]; then err "branch name must be input" && return 1;fi
                bar inline "delete branch: branch [${name}] will be removed from REMOTE"
                showRUNQ y git push ${GITT_REMOTE} --delete ${name}
    ;; info)    gittbranch_info
    ;; list)    #test case all) gitt branch list, gitt branch list '*', gitt branch list '*mas*',  exact) gitt branch list m/master, gitt branch list 'm/master'
                #gittbranch_list \'"${name:-*}"\'
                set -o noglob
                gittbranch_list "${name:-*}"
                set +o noglob
    ;; diff)    if [ -z "${name}" ]; then err "branch name must be input, if you don't know use 'gitt branch list'" && return 1;fi
                local tempvar=$(git branch -rvv --sort=committerdate --list ${name} |sed 's/^[[:space:]]*//'| cut -d' ' -f1)
                [ "$name" = "$tempvar" ] || { warn "branch name is wrong";  bar inline "must be input as the following"; git branch -rvv --sort=committerdate --list *${name}* *${target}*; return 0; }
                bar inline "show tree between [${name}] [${target}]"
                git fetch --all
                local base=$(git merge-base "${name}" "${target}") || { git fetch --all; }
                git log --color=always --graph --decorate=short --oneline --boundary ${base}.. "${name}" "${target}" \
                    --pretty=format:'%C(yellow)%h -%C(reset)%s %Cgreen(%ci) %C(red)%d%Creset' |sed -E 's/tag:[^,]*,? ?//g'

                under  "\n\n> [${target} only commits]\n"
                showRUN git log --shortstat --decorate=no --pretty=format:'%C(yellow)%h -%C(reset)%s %C(blue)<%an>%Creset' ${name}..${target}

                under  "< [${name} only commits]\n"
                showRUN git log --shortstat --decorate=no --pretty=format:'%C(yellow)%h -%C(reset)%s %C(blue)<%an>%Creset' ${target}..${name}


    ;; *) gittbranch help
    ;; esac
}



function gittfind(){
## ---------------------------------------------------------------------------
# print information(commit info) of current repository#
# $1: regexp or string
# $2: file, dir and area
    local keyword="$1"
    local area="${@:2}"

    case $keyword in
    ''|help) cat <<- EOF
				usage) gitt find '<string>'                     #find <string> in committer, message, code-diff
				                                                #please brace string with single quoat('~~~')
				   ex) gitt find 'docker' dock                  #find string 'docker' in file 'dock'
EOF
             return 0;
    ;; *)   bar outline "search in commit with regexp(${keyword}) in files(${area:-file list or path})"
    esac

    source <(cat <<'EOL'
    under "find string(${keyword}) in committer in history(${area:-all})\n"
    echo "ex) git log --author=".*${keyword}.*" ${area}"
    echo "ex) git log --owner=".*${keyword}.*" ${area}"
    checkifSHA ${keyword} &&  git log -1 ${keyword}
    showRUN git log --committer=".*${keyword}.*" ${area}


    under "find string(${keyword}) in commit message of history (${area:-all}) with file-changes\n"
    showRUN git log -i --name-status -F --grep="${keyword}" ${area}

    under "find string(${keyword}) in commit diff in file history(${area:-all}) \n"
    echo "ex) git grep -e regexp1 --or -e regexp2"
    echo "ex) git grep -e regexp1 --and -e regexp2"
    showRUN git grep -n "${keyword}" ${area}

    under "find function(${keyword}) in file history(${area:-all}) \n"
    read -p "[enter:continue| ctrl+c:break]"
    showRUN git log -L :${keyword}:${area}
EOL
)

    ## show commit diff including keyword
    #git log -p -S"${keyword}" ${area}

    ## find string in function
    #under "find string in :fuction:file\n"
    #showRUN git log -L :"${keyword}":"${area}"
    ##run echo

}



function gittdiff(){
## ---------------------------------------------------------------------------
# read file and print line "include" keyword
# $1 command
# $2 branch name or branch postfix
    local cmd="$1"
    local path="$2"
    local rev1="$3"
    local rev2="$4"

    local cmd_diff="git difftool"

    if command -v icdiff > /dev/null ; then cmd_diff="git difftool --extcmd icdiff";fi
    if [ -z "${path}" ]; then path=.;fi

    case $cmd in
    help) cat <<- EOF
				 info) if default <path> is omitted, . (current dir) will be used
				usage) gitt diff work <path>                        #  staged >>> diff <<< unstaged(workspace)
				usage) gitt diff staged <path>                      #    HEAD >>> diff <<< staged
				usage) gitt diff HEAD <path>                        #    HEAD >>> diff <<< unstaged & staged(add empty path)
				usage) gitt diff HEAD^ <path>                       #    HEAD >>> diff <<< HEAD^

				usage) gitt diff branch <path> <branchA> <branchB>  #branch A >>> diff <<< branch B, <path> is mandatory
				   ex) gitt diff branch . vgit_na/tsu_26my_release vgit_na/tcua_release
				       if this not working, please put 'current local branch name' as parameter

				usage) gitt diff commit <path> <commitA> <commitB>  #commit A >>> diff <<< commit B, <path> is ignored
				   ex) gitt diff commit . HEAD^ 03c2df

				flow) gitt branch list                              # find remote branch name : origin/master
				      gitt fetch                                    # get all branch for comparing
				      gitt diff branch . HEAD origin/master         # compare current branch to origin/master
				      gitt diff branch . default origin/master      # compare default branch to origin/master
EOF
    ;;  work)   under "      staged >>> diff <<< unstaged\n"
                showRUNQ ${cmd_diff} -- ${path} |more -60
    ;;staged)   under "        HEAD >>> diff <<< staged\n"
                showRUNQ ${cmd_diff} --cached -- ${path} |more -60
    ;;HEAD|head)     under "        HEAD >>> diff <<< unstaged/staged\n"
                warn "automatically 'git add empty path' to show diff untracked new file"
                git add -N . #to compare new untracked file
                showRUNQ  ${cmd_diff} HEAD -- ${path} |more -60
    ;;HEAD^|head^)   under "        HEAD >>> diff <<< HEAD^ \n"
                #= showRUN ${cmd_diff} @ @^ ${path}
                showRUNQ ${cmd_diff} HEAD HEAD^ ${path} |more -60
    ;;branch)   under "    branch A >>> diff <<< branch B \n"
                warn "to see remote branch, run 'gitt branch list'"
                showRUNQ ${cmd_diff} ${rev1} ${rev2} ${path} |more -60
    ;;commit)   under "    commit A >>> diff <<< commit B \n"
                showRUNQ ${cmd_diff} ${rev1}..${rev2} |more -60
    ;;  file)   under "    current >>> diff <<< current-1 \n"
                showRUNQ ${cmd_diff} @:${path} @^:${path} |more -60
    ;;  *|'')   gittdiff help
    ;; esac
}



function gittreset(){
## ---------------------------------------------------------------------------
# reset git repositories
# $1 target

    local cmd=$1
    case ${cmd} in
        clear)   showRUNQ y "git reset --hard @{upstream} && git clean -xdf"

    ;; help|*)   cat <<-EOF
				usage) gitt reset clear #remove all changes and reset with comfirm 'y'
				usage) gitt reset       #show detail reset commands below, run manully.

				info) git reset flow
				1) git log: check reset point in repository
				2) git reset <rev> <option>
				   current : workspace index repository | description
				   -----------------------------------------------------------------------------------------------------
				    --soft : workspace index <<<<       | keep commit & file, could retry from 'git push'
				    --mixed: workspace <<<<             | keep only  file, could retry from 'git add' (default)
				    --hard : <<<<                       | remove all, need to retry from scratch
				3) retry from each step
				flow) git log> git reset c3cef36787        > add modification> git add -A> git commit        > git push
				flow) git log> git reset c3cef36787 --soft > add modification> git add -A> git commit --amend> git push
				info) 'git reset --hard' restored by this 'git reflog > git reset --hard <relog rev>'
EOF
    esac
}



## revv ======================================================================================================================


JSON_IDFY=")]}'"
function revvcheck_server(){
## ---------------------------------------------------------------------------
# check gerrit is permitted for input user on git project > branch
# usage) revvcheck_server na log
# $1: target review system
# $2: log flag

    local server=$1
    local flag=$2

    [ "$REVV_TAG" = "$server" ] && return 0
    local key=$(revvserver_item ${server}  pass)
    local user=$(revvserver_item ${server} user)

    if [ -z "${server}" ];
    then port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)'); server=$(revvserver_item ${port} http)
    else port=$(revvserver_item ${server} port); server=$(revvserver_item ${server} http);
    fi
    #$DEBUG ["$server"]["$port"]

    ## gerrit api에 access가 가능한지를 gerrit version을 제대로 return하는지 여부로 판단한다.
    [ "${flag}" = "log" ] && info "curl -su ${user}:${key} ${server}/a/config/server/version |sed '1d'| jq -cC '.'"
    REVV_VER=$(curl -su ${user}:${key} ${server}/a/config/server/version |sed '1d'| jq -cC '.')
    if ! [[ "${REVV_VER}" =~ [2-9].[0-9].[0-9]* ]]; then REVV_VER='NA'; err "gerrit is not working, please check"; return 1; fi

    if [ "${flag}" = "log" ]; then
        bar inline "step1.1-gerritserver: [remote] check if gerrit server is active (checked by $user)"
        clog try "check gerrit service is online from web"
        echo "ok. gerrit is working ${REVV_VER}"
    fi
    return 0
}



function revvcheck_account(){
## ---------------------------------------------------------------------------
# check gerrit is permitted for input user on git project > branch
# usage) revvcheck_account na joongkeun.kim log
# $1: target review system
# $2: target user
# $3: log flag


    local server=$1
    local user=$2
    local flag=$3
    local key_id=$(revvserver_item ${server} sub)
    local key=$(revvserver_item ${key_id} pass)
    local ret=()

    #local port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)')
    if [ -z "${server}" ];
    then port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)'); server=$(revvserver_item ${port} http)
    else port=$(revvserver_item ${server} port); server=$(revvserver_item ${server} http);
    fi

    readarray -d',' -t ret < <(curl -su ${ACCOUNT}:${key} ${server}/a/accounts/?suggest\&q=${user}|sed '1d'| jq -c '.[]|{_account_id,username,name,email}'|sed  's/[{}"]//g')
    ! [[ "${ret[*]}" =~ "${user}" ]] && err "there is no account [${user}] in gerrit" && return 1

    ##get username & accountID from gerrit
    REVV_USERID="${ret[0]#*:}"
    REVV_USER="${ret[1]#*:}"

    if [ "${flag}" = "log" ]; then
        bar inline "step1.2-gerritserver: [remote] check if ${user} can access gerrit (checked by $ACCOUNT)"
        clog try "check current account is in gerrit system"
        echo "ok. gerrit account existed: ${ret[@]}"
        #declare -p ret
    fi
    return 0
}



function revvcheck_permission(){
## ---------------------------------------------------------------------------
# check gerrit is permitted for input user on git project > branch
# usage)  revvcheck_permission as joongkeun.kim honda/con/autosar tsu_26my_release create
# $1: target user
# $2: target review system
# $3: gitproject
# $4: branch
# $5: permission(https://gerrit-review.googlesource.com/Documentation/access-control.html#access_categories)
#     Abandon,Create(Create Reference),Delete(Delete Reference),Forge Author, Forge Committer,Forge Server,Owner,Push,Direct Push
#     Push Merge Commits,Create Annotated Tag,Read,Rebase,Revert,Submit,Submit (On Behalf Of),Edit Hashtags,Edit Topic Name
#

    local server=$1
    local user=$2
    local oriproject=$3 ;
    local gitproject=${oriproject//'/'/'%2F'}
    local branch=$4
    local perm=$5
    local flag=$6
    local key_id=$(revvserver_item ${server} sub)
    local key=$(revvserver_item ${key_id} pass)
    local log ret

    revvcheck_account ${server} ${user}

    #local port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)')
    if [ -z "${server}" ];
    then port=$(echo ${REPP_URL#*@} | grep -oP '(?<=:)[0-9]+(?=/)'); server=$(revvserver_item ${port} http)
    else port=$(revvserver_item ${server} port); server=$(revvserver_item ${server} http);
    fi
    if [ -z "${oriproject}" ];then info "guide) repp connect help" && return 1;fi

    ##[ "${oriproject}" = "${REPP_PROJECT}" ] && server=origin #change remote name for manifest git to origin
    #curl -su vc.integrator:'F3ZYZofW1J~~~' http://vgit.lge.com/as/a/projects/honda%2Flinux%2Fbuild_tsu/check.access?account=7986\&ref=refs%2fheads%2fmaster\&perm=read
    bar inline "step1.3-gerritserver: [remote] check if ${user} can access git project (checked by $ACCOUNT)"
    clog try "check git name path is correct and can access"
    log=$(curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject}/check.access?account=${REVV_USERID})
    ret=$(echo "${log}" |sed '1d'| jq -c '.')
    ! [[ "${ret#*:}" =~ 200 ]] && err "check gerrit project error: ${log}" && return 1
    echo "ok. gerrit account[${REVV_USER}] can access by[read]: ${oriproject}"
    echo ${linemi}

    bar inline "step1.4-gerritserver: [remote] check if ${user} can access branch on the project (checked by $ACCOUNT)"
    clog try "check git/branch is correct and can access it [case sensitive]"
    dnlog "commit" "read,submit,push,pushMerge,revert,forgeCommitter,forgeAuthor,editTopicName,label-Code-Review"
    dnlog "branchtag" "create,delete,createTag,createSignedTag"
    dnlog "server" "priority,streamEvents,administrateServer"
    [ -z "${branch}" ] && branch="master"
    [ -z "${perm}" ] && perm="read"
    log=$(set -x; curl -su ${ACCOUNT}:${key} ${server}/a/projects/${gitproject}/check.access?account=${REVV_USERID}\&ref=refs%2fheads%2f${branch}\&perm=${perm})
    readarray -d $'\n' -t ret < <(echo "${log}" |sed '1d'| jq -rM '.message,.status')
    ! [[ "${ret[1]}" =~ 200 ]] && { err "check gerrit project error: ${log}"; return 1;}
    ##get username & accountID from gerrit
    echo "ok. gerrit branch[${branch}] existed and can accessed with[${perm}] permission by[${REVV_USER}]"

    return 0
}


function test_revvserver_item() {
## ---------------------------------------------------------------------------
## check all format is well printed
## print remote (gerrit server) info for all supported format
## awk print 2nd line to last-1 line
#revvserver show |awk -F '|' 'NR>1{print $1}'
    local cmd=$1
    for _item in $(revvserver show |awk -F '|' 'NR>2 {print last} {last=$1}');do
        if [ "$cmd" = info ]||[ "$cmd" = check ]; then revvcheck_server $_item log; fi

        if [ "$cmd" = info ]; then
        for _test in http port sub domain subdomain path url remote debug;do
            bbar cyan "${_item##*/}:$_test"  "$(revvserver_item "${_item##*/}" "$_test")\n"
        done
        fi
    done
}



function revvconnect(){
## ---------------------------------------------------------------------------
# check connection and report error
# $1 server
# $2 port
# $3 password
    local cmd="$1"
    case ${cmd} in
       help)    cat <<-EOF
			  usage) revv connect [server]  [user]          [gitproject]   [branch]
			 -----------------------------------------------------------------
			default) revv connect ${REPP_REMOTE} $ACCOUNT   ${REPP_PROJECT}    ${REPP_BRANCH}
			     ex) revv connect na        testaccount     tiger/tools  tiger_release
			     ex) revv connect na        joongkeun.kim   tiger/tools  tiger_release
			     ex) revv connect na        testaccount     tiger/tools
			     ex) revv connect na        testaccount
			     ex) revv connect na        testaccount
			     ex) revv connect
EOF
                return 1;
    ;;     *) :
    esac

    local user oriserver gitproject branch port
    local temp_p=$(expr "${REPP_URL}" : ".*[0-9]/\(.*\)\..*")
    [ -z "$4" ] && info "use default branch: ${GITT_BRANCH}"        ;branch=${4:-${GITT_BRANCH}} ;
    [ -z "$3" ] && info "use default git project: ${GITT_PROJECT}"  ;gitproject=${3:-${GITT_PROJECT}} ;
    [ -z "$2" ] && info "use default account: $USER"                ;user=${2:-$USER} ;
    [ -z "$1" ] && info "use default server: ${GITT_REMOTE}"        ;oriserver=${1:-${GITT_REMOTE}} ;
    port=$(revvserver_item ${oriserver} port)

    #clog "should be this format:ex)" "[testaccount][$oriserver][$gitproject][$branch]"
    bbar PURPLE "[$user] in" "\nchecked under [$oriserver] [$gitproject] [$branch]\n\n"

    under "step1: check gerrit permission for ${user} from WEB(HTTP) by account admin[${ACCOUNT}]\n"
    showRUN revvcheck_server ${oriserver} log                                              ;wave
    showRUN revvcheck_account ${oriserver} ${user} log                                     ;wave
    showRUN revvcheck_permission ${oriserver} ${user} ${gitproject} ${branch} read         ;wave
}



function revvinfo(){
## ---------------------------------------------------------------------------
# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch

    local cmd=${1:-info}
    #local branch=$4

    case ${cmd} in
       help)    cat <<-EOF
				usage) revv info                                   #show gerrit POST command
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) clog "test" "test api"
    ;; esac
}



function revvaccount(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account (from 'revv account')
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    if [ "$subcmd" != help ] ; then
        local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
        local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
        local key=$(revvserver_item $sub pass)
        local user=$(revvserver_item $sub user)
    fi
    local source=${3:-$USER}
    local target=$4
    local extra=$5
    local file=$(mktemp)
    local out


    #local branch=$4
    [ -z "$user" ] && user=$ACCOUNT
    local SEP='~'
    case ${cmd}${SEP}${subcmd} in
           *~help)
            echo "check your cmd [${cmd}]"; cat <<-EOF
			usage) revv user      na joongkeun.kim                             # check account is existed and its groups
			   ex) revv user      na joon                                      # check all accounts named joon
			   ex) revv user      na 7602             none none                # for api, get user info only
			usage) revv sshkey    na joongkeun.kim                             # get registered SSH-KEY
			usage) revv group     na sa515m_developer                          # check group existance and list sub-groups & all members
			   ex) revv group     na sa515m_                                   # find groups has *'sa515m_'*
			   ex) revv group     na 16d578384091ad1~ none none                # for api, get group info only
			usage) revv groupadd  na sa515m_developer joongkeun.kim            # add member to group
			usage) revv groupdel  na sa515m_reviewer  joongkeun.kim            # delete member from group
			usage) revv groupmem  na sa515m_reviewer  joongkeun.kim            # check member is in group and its sub-groups
EOF
    ;;      user~*)
            [ "$extra" != "none" ] && bar inline "check if account is existed & get account info "
            curl -su ${user}:${key} ${server}/a/accounts/?suggest\&q=${source} |sed '1d'|jq -cC .[]|pCount

            [ "$(cat /tmp/pCount)" -ne 1 ] && return 0

            if [ "$extra" != "none" ]; then
                bar inline "list group name which account belongs to"
                curl -su ${user}:${key} ${server}/a/accounts/${source}/groups |sed '1d'| jq -cC '.[]|{name, created_on}' | more -60
            fi

    ;;    sshkey~*)
            info "config: " "${server}/na/settings/#SSHKeys"
            bar outline "get registered SSH-key for account [${source}] in server [$server]"
            #curl -su ${user}:${key} ${server}/a/accounts/${source}/sshkeys |sed '1d'| jq -cC '.[]|{ssh_public_key, comment}'
            out=$(curl -su ${user}:${key} ${server}/a/accounts/${source}/sshkeys)
            if [ "$(echo "${out}" | head -1)" = "${JSON_IDFY}" ];
            then echo "$out"| sed '1d'| jq -cC '.[]|{ssh_public_key, comment}'
            else err "$out"
            fi

    ;;  groupadd~*)
            bar outline "add member to group"
            curl -su ${user}:${key} ${server}/a/groups/${source}/members/${target} -X PUT

    ;;  groupdel~*)
            bar outline "delete member from group"
            curl -su ${user}:${key} ${server}/a/groups/${source}/members/${target} -X DELETE

    ;; groupmem~*)
            bar outline "find member from group"
            curl -su ${user}:${key} ${server}/a/groups/${source}/members|grep ${target}

    ;;    group~*)
            if [ "$extra" != "none" ]; then
                info "config: " "${server}/admin/groups/q/filter:${source}"
                info "please visit url for creating & removing user/group"
                bar inline "find group by name"
            fi

            out=$(curl -su ${user}:${key} ${server}/a/groups/${source})
            if [ "$(echo "${out}" | head -1)" = "${JSON_IDFY}" ];
            then echo "$out"| sed '1d'| jq -cC '.|{id, name}'
            else
                #curl -su ${user}:${key} ${server}/a/groups/?m=${source} |sed '1d'| jq '.'
                out=$(curl -su ${user}:${key} ${server}/a/groups/?m=${source})
                if [ "$(echo "${out}" | head -1)" = "${JSON_IDFY}" ];
                then echo "$out"| sed '1d'| jq '.'
                else err "$out"
                fi
                return 0
            fi

            if [ "$extra" != "none" ]; then
                #gerrit에 대한 permission은 위 처리로 충분하여 아래는 예외처리를 하지 않았다.
                bar inline "list sub-group by ${source} group"
                curl -su ${user}:${key} ${server}/a/groups/${source}/groups/ |sed '1d'| jq -c '.[]|{name, created_on}'
                bar inline "show group member by ${source} group to its decendents"
                curl -su ${user}:${key} ${server}/a/groups/${source}/members?recursive |sed '1d'| jq -cC '.[]|{name, email}'  | more -60
            fi

    ;;*)    err "please check command ex)revv user help, revv group help"
    esac
}



function revvproject(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)
    local project=$3
    local url_gerrit="${server}/a/projects/${project//'/'/'%2F'}"
    local parent=$4
    local extra=$5
    local file=$(mktemp)


    #local branch=$4
    [ -z "$user" ] && user=$ACCOUNT
    local SEP='~'
    case ${cmd}${SEP}${subcmd} in
           *~help)
            echo "check your cmd [${cmd}]"; cat <<-EOF
			usage) revv project       na mustang/tm/src                            # find project with project-name
			usage) revv project       na vendor/qct/sa515m/_lge_only               # find project and its child projects
			usage) revv projectadd    na sample/target sample/parent               # add git project from parent with empty master
			usage) revv projectadd    na sample/target                             # add git project from All-project with empty master
			usage) revv projectdel    na sample/target                             # get remove page url in gerrit
			usage) revv projectparent na sample/target sample/parent               # change parent of the project
			 info) project delete is not supported in CLI, WEB support it, please access it revv projectdel cmd

EOF
    ;;projectadd~*)
            bar inline "check if project already existed"
            local temp=$(curl -su ${user}:${key} $url_gerrit |sed '1d' | jq -cC '.name')
            if [ -n "${temp}" ]
            then err "[${temp}] already legacy project existed" && return 1;
            else clog "passed, no legacy project" "ok, continue to create"
            fi

            if [ -n "${parent}" ]; then
                temp=$(curl -su ${user}:${key} ${server}/a/projects/${parent//'/'/'%2F'} |sed '1d' | jq -cC '.name')
                if [ -z "${temp}" ]; then err "but no parent project, stop to create"; return 1; fi
            fi

            bar inline "add new project inherited All-projects(default), and create emtpy master"
            curl -su ${user}:${key} $url_gerrit -H "Content-Type:application/json" \
                 --data "{\"description\":\"revvcreate\",\"parent\":\"${parent:-'All-Projects'}\", \"create_empty_commit\":true }" \
                 -X PUT |sed '1d' > $file
            clog "result for creaing project: "
            cat $file| jq -C .

    ;;projectdel~*)
            bar inline "check if project already existed"
            local temp=$(curl -su ${user}:${key} $url_gerrit |sed '1d' | jq -cC '.name')
            if [ -n "${temp}" ]
            then clog "[${temp}] already legacy project existed" "ok, please remove manually"
            else err "no existing project, stopped" && return 1
            fi

            bar inline "'removing project' by CLI is not supported in gerrit"
            dnlog "so only provide url link, you cand remove git project there"
            dnlog "[guide] To delete project (visit):" "${server}/admin/repos/${project},commands"
            printf "\n\n"

    ;;projectparent~*)
            bar inline "check if project already existed"
            local temp=$(curl -su ${user}:${key} $url_gerrit |sed '1d' | jq -cC '.name')
            [ -z "${temp}" ] && { clog "[${temp}] already legacy project not existed"; return 1; }

            if [ -n "${parent}" ]; then
                temp=$(curl -su ${user}:${key} ${server}/a/projects/${parent//'/'/'%2F'} |sed '1d' | jq -cC '.name')
                if [ -z "${temp}" ]; then err "but no parent project, stop to create"; return 1; fi
            fi

            bar inline "changing parent of project"
            [ -z "${parent}" ] && (warn "git created whose parent is All-project(default)" && return 0)
            curl -su ${user}:${key} $url_gerrit/parent -H "Content-Type: application/json" --data "{\"parent\":\"${parent}\"}" -X PUT > $file
            clog "result for changing parent: "
            cat $file| sed '1d'| jq . | more -60
            printf "\n\n"

    ;;  project~*)
            dnlog "[gerrit url] gerrit cli:" "curl -su ${user}:${key} $url_gerrit | sed '1d'| jq  -cC '.[]'"

            info "config: " "${server}/admin/repos/${project}"
            bar inline "find project and show project url"
            curl -su ${user}:${key} ${server}/a/projects/?m=${project} |sed '1d' > $file
            clog "matching project: "  $(cat $file| jq -C 'keys[]'| pCount)

            [ "$(cat /tmp/pCount)" -ne 1 ] && return 0
            #cat $file| jq --arg jq_var "${server}/admin/repos/" -c '$jq_var + .[].id' | nl
            local temps=http://$(revvserver_item $server subdomain)
            echo $temps$(curl -su ${user}:${key} ${server}/a/projects/?m=${project} |sed '1d' | jq -rM '..|select(contains("gitweb?")?)')
            echo $temps$(curl -su ${user}:${key} ${server}/a/projects/?m=${project} |sed '1d' | jq -rM '..|select(contains("plugins")?)')

            bar inline "parent-project info"
            curl -su ${user}:${key} $url_gerrit |sed '1d' | jq -cC '.|{name,parent}'
            curl -su ${user}:${key} $url_gerrit/access |sed '1d' > $file
            cat $file| jq --arg jq_var "${server}/admin/repos/" -c '"config: " + $jq_var + .inherits_from.name'

            bar inline "grand parent-project info"
            cat $file| jq -cC '.inherits_from|{name,parent}'
            cat $file| jq --arg jq_var "${server}/admin/repos/" -c '"config: " + $jq_var + .inherits_from.parent'

            bar inline "child-project info inherited from ${project}, plz wait..."
            curl -su ${user}:${key} $url_gerrit/children/?recursive| sed '1d'| jq  -cC '.[].name' | more -60
            printf "\n\n"
    ;;*)    err "please check command ex)revv project help"
    esac
}


function revvpermission(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local file=$2

    case ${cmd} in
    ##accessapiparent, accessapigroup, accessapipermission 함수는 직접호출용으로 만들어진것으로 아니며, revv access로 부터 호출되도록 구현되었다.
    accessgroup*) bar inline "show permission group"
                ## group.url이 null일때는 실제 null이라는 문자열로 replace를 하고, null이 아닐때는 #를 server주소로 변경해준다.
                #cat $file|jq --arg jq_var "${server}" -c '.groups[]| {url:(.url| if .==null then "null" else gsub("#"; $jq_var) end), name}'
                cat $file|jq -c '.groups[]| {name}' >&2
    ;; accesspermission*) bar inline "show permission setting"
                ## json중 group에서 url경우에는 null이라는 문자열로 변경하고, 있을때는#대신 server주소를 넣고, name경우에는 /를 _로 변경하고 tostring(문자열로변환)하고, gsub으로 문자열을 replace한다.
                ## 3fe63d48b76~,jlr_vcm_developer
                ## 3fcc47cb801~,mustang_tm_reviewer
                ## stdin으로 부터 awk를 통해 아래와 같은 변환식파일을 만들어놓고, 변환식이 들어있는 파일을 stdin으로 sed로 입력받아 실제 파일인 $file을 변경한다.
                ## 그런데 실제파일중에 일부인 .local부분만 필요함으로 그 부분을 process substition오로 입력받아서 처리한다.
                ## 이때 jq -C '.local'로 처리했지만, compact하게 출력하기 위해 jq -cC '.local|to_entries | map({(.key): .})[][][]' 를 사용할수도 있다.
                local cmdfile=$(mktemp);
                cat $file|jq --arg jq_var "${server}" -crM \
                '.groups[]| {url:(.url| if .==null then "null" else gsub("#"; $jq_var) end), name:(.name| gsub("/"; "_"))} |tostring |gsub("{|\"|}";"") |gsub("url.*uuid-|name:";"")'|\
                awk -F, '{print "s/"$1"/"$2"/g;"}'> $cmdfile

                ## compact하게 나오지 않고 full display를 하는 경우
                ## [ "$(cat /tmp/pCount)" -gt 10 ] && { read -t 2 -p "Press Ctrl+C not to see more ..."; cat $cmdfile|sed -f - <(cat $file|jq -C '.local'); }
                ## compact display
                ## jq -cC '.local |to_entries[] | .value.permissions | to_entries[] | {key: .key, value: .value}') 여기서 action과 force값을 제외
                cat $cmdfile| sed -f - <(cat $file | jq -cC '.local | to_entries[] | .value.permissions | to_entries[] |
                    {key: .key, value: (.value | walk(if type == "object" then del(.action, .force) else . end))}') >&2
    ;; accessparents*) bar inline "show permission parents git"
                ## 입력된 project의 부모 project 정보를 stdout, stderr로 동시 출력한다.
                cat $file|jq 'if .inherits_from then .inherits_from | {name, id, parent, state} | del(.web_links) else "No more parents" end' >&2
    ;; *) :
    esac
}


## ---------------------------------------------------------------------------
function revvaccess(){
# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    local project=${3:-${GITT_PROJECT:-${REPP_PROJECT}}}
    local group=${4:-$USER} #gerrit group name
    local branch=$5 #^refs/heads/26my_migg_.*

    if [ "$subcmd" != "help" ]; then
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)
    local group_id=$(revvaccount group "$server" "$group" none none)
    fi

    [ -z "$user" ] && user=$ACCOUNT
    local sep='~'
    case ${cmd}$sep${subcmd} in
          *~help)  cat <<-EOF
				usage) revv access[all|add|group|groupall|permission|permissionall|parents|parentsall]   na <project>
				   ex) revv access              na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission info for current git
				   ex) revv accessall           na vendor/qct/sa515m/sa515m_modem/modem_proc  #get all permission info including parents
				   ex) revv accessgroup         na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission group for current git
				   ex) revv accessgroupall      na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission group including parents
				   ex) revv accesspermission    na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission setting for current git
				   ex) revv accesspermissionall na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission setting including parents
				   ex) revv accessparents       na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission parents for current git
				   ex) revv accessperentsall    na vendor/qct/sa515m/sa515m_modem/modem_proc  #get permission parents including parents
				usage) revv accessadd na <project>  <group> <'branch-regexp'>                 #add migration permission to a group
				   ex) revv accessadd na qct/modem  26my_migrator '^refs/heads/26my_migg_.'   #add migration permission to 26my_migrator

				 info) repp connect help : you can check your basic access permission for a git.
EOF
    ;;accessadd~)
                clog "add migration permission $group_id $branch"
                [ -z "$group_id" ] && { err "group is not existed, check $group"; return 1; }
                cat|json_pp >temp.json << TEMP_JSON
                {"add" : { ""$branch"" : {"permissions" :   {
                    "forgeCommitter"            : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "abandon"                   : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "label-Code-Review"         : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}, "label":"Code-Review"},
                    "create"                    : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "label-CodeReview-Verified" : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}, "label":"CodeReview-Verified"},
                    "pushMerge"                 : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "label-Verified"            : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}, "label":"Verified"},
                    "submit"                    : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}},
                    "push"                      : {"rules" : {""$group_id"" : {"action":"ALLOW","force":true}}},
                    "forgeAuthor"               : {"rules" : {""$group_id"" : {"action":"ALLOW"             }}}
                }}}} }
TEMP_JSON
        showRUNQ y curl -su ${user}:${key} ${server}/a/projects/${project//'/'/'%2F'}/access -H "Content-Type:application/json" -d @temp.json -X POST

    ;;access*~)
                #cat $file|jq --arg jq_var "${server}" -crM '.groups[]| {url:(.url| if .==null then "null" else gsub("#"; $jq_var) end), name}| tostring | gsub("{|\"|}";"")| gsub("url.*uuid-|name:";"")'|\
                #    sed 's:/: :g' |awk -F, '{print "s/"$1"/"$2"/g;"}' |sed -f - <(cat $file|jq '.local') > b.txt
                # cat $file|jq -cC '.local|to_entries | map({(.key): .})[][][]'
                case ${cmd} in accessgroup*|accesspermission*|accessparents*|accessall|access) :
                                                                                          ;;*) revvaccess help; return 1
                esac

                while [ "$project" != "null" ] ; do
                    local file=$(mktemp);
                    ##현재 project의 access정보를 가져온다.
                    curl -su ${user}:${key} ${server}/a/projects/${project//'/'/'%2F'}/access |sed '1d' > $file

                    if [ ! -s "$file" ] || $(cat $file | grep -q 'Not found'); then { err "${project} is not existed"; break; }; fi
                    info "config: " "${server}/admin/repos/${project},access"
                    clog "rawfile:" "cat $file|jq -cC '.'"

                    ##cat rule.txt | sed -f - <(cat /tmp/tmp.frgiex2IBv | jq '.local|walk(if type == "object" then del(.force) else . end)')
                    ##cat $file|jq --arg jq_var "${server}" -crM '.groups[]| {url:(.url| if .==null then "null" else gsub("#"; \$jq_var) end), name:(.name| gsub("/"; "_"))} |tostring |gsub("{|\"|}";"") |gsub("url.*uuid-|name:";"")'|awk -F, '{print "s/"\$1"/"\$2"/g;"}'
                    wave
                    case ${cmd} in
                        accessgroup*|\
                        accesspermission*|\
                        accessparents*)     [ "$(revvpermission ${cmd} $file)" = "No more parents" ] && break
                        ;;accessall|access)      revvpermission accessgroup $file
                                                 revvpermission accesspermission $file
                                            [ "$(revvpermission accessparent $file)" = "No more parents" ] && break
                    esac
                    [[ ! "$cmd" =~ "all" ]] && break; ##accessall일때는 반복
                    ##부모 project의 이름을 가져온다.
                    #cat $file |jq -rM '.inherits_from.web_links[] | select(.url | contains("plugins")) | .url' |sed -E 's#\/(.*)/plugins.*#\1#'
                    project="$(cat $file |jq -rM '.inherits_from.id')"
                done
    esac
}



function revvbranch(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)
    local source=${3:-$USER}
    local target=$4
    local extra=$5


    #local branch=$4
    [ -z "$user" ] && user=$ACCOUNT
    local SEP='~'
    case ${cmd}${SEP}${subcmd} in
           *~help|*~)
            echo "check your cmd [${cmd}]"; cat <<-EOF
			   ex) revv branch    na mustang/tm/src tsu_25.5my_release         # find branch with branch-name
			   ex) revv branchadd na mustang/tm/src tsu_25.5my_release_new     # create branch (will ask base branch)
			   ex) revv branchdel na mustang/tm/src tsu_25.5my_release_old     # remove branch
			 info) 'empty branch' can be created by 'revv projectadd' not 'revv branchadd'
			       therefore if you want 'empty branch', refer 'gitt branch create empty'
EOF
            clog "\ncopy & modify this:" "revv branch ${GITT_REMOTE:-${REPP_REMOTE}} "${GITT_PROJECT:-${REPP_PROJECT}}" "${GITT_BRANCH:-${REPP_BRANCH}}""

    ;;branchadd~*)
            bar inline "create branch with base revision"
            if [ -z "${extra}" ]; then read -p "input base branch which new branch is created from: ";fi
            showRUNQ y curl -su ${user}:${key} ${server}/a/projects/${source//'/'/'%2F'}/branches/${target} -H "Content-Type:application/json" --data "{"revision":"${extra:-${REPLY}}"}"  -X PUT

    ;;branchdel~*)
            bar inline "delete branch by name"
            showRUNQ y curl -su ${user}:${key} ${server}/a/projects/${source//'/'/'%2F'}/branches/${target} -X DELETE
            clog "if cannot delete branch, use cli with force option" "git push vgit_na HEAD:refs/heads/tsu_26my_release -f"

    ;;   branch~*)
            bar inline "find branches by name"
            curl -su ${user}:${key} ${server}/a/projects/${source//'/'/'%2F'}/branches/?m=${target} | sed '1d'| jq  -cC '.[]|{ref,revision}' | more -60

    ;;*)    err "please check command ex)revv branch help"
    esac
}



function revvcommit(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local subcmd=$2
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)

    local source=${3:-$USER}
    local target=$4
    local extra=$5
    local file=$(mktemp)

    #local branch=$4
    [ -z "$user" ] && user=$ACCOUNT
    case ${cmd} in
       find)
            local change_id=$(curl -su ${user}:${key} ${server}/a/changes/${source} |sed '1d'| jq -r '.change_id')
            if [ -z "${change_id}" ]; then
                err "NOT Found in $server change_id for commit_id [${source}]"
                echo "this commit is not in this gerrit system."
                clog "info:" "it could bue direct pushed commit or maybe in other servers"
                return 1;
            fi
            curl -su ${user}:${key} ${server}/a/changes/?q=${change_id}| sed '1d' > ${file}

            local pro branch changenumber path
            under "commit & user info from gerrit server\n"
            jq -c '.[]' "${file}" | while read -r change; do
                changenumber=$(echo "$change" | jq -r '._number')
                pro=$(echo "$change" | jq -r '.project')
                branch=$(echo "$change" | jq -r '.branch')
                submitter=$(echo "$change" | jq -r '.submitter._account_id')

                clog "gerrit url:" "$server/c/$pro/+/$changenumber"
                revvaccount user na "$submitter" none none

                echo "$change" | jq '{project,branch,change_id,_number,subject,status,submitted}'
                echo

                under "commit info from current source\n"
                path="$REPP_ROOT/$(repo list -p "$pro" 2> /dev/null)"
                clog "local git path:" "$path"
                git -C "$path" show --quiet "$source"

                wave
            done

    ;;*|help)
            cat <<-EOF
			usage) revv commit find [na|as|eu|devops_test|review] <commit-id>    # find commit info from server
			   ex) revv commit find na 57a4eeeca914                              # get change-id from commit-id

			info) 'review' is lamp-sever, others are vgit server, these servers must be predefined.
			info) to find in all server, use 'repp commit find 57a4eeec'.
EOF

    esac
}



function revvforall(){
## ---------------------------------------------------------------------------
# repoforall for revv
# ex) revv forall branch vgit_na              #check branch ${REPO_RREV}
# ex) revv forall branchadd vgit_na _temp     #check branch ${REPO_RREV}_temp
# ex) revv forall branchdel vgit_na _temp     #check branch ${REPO_RREV}_temp
# $1 account
# $2 server
# $3 gitproject
# $4 branch
###### *는 쓰지말자. 대신 명시적으로 써야 한다. @all, @curr 등으로 사용하자
    local cmd=$1
    local target=$2 #no need * for all file in gerrit, remove
    local source=$3

    case $cmd in
        help) cat <<-EOF
			usage) revv forall <cmd> <target_branch> <base_branch>
			guide) revv forall is working based on the manifest.xml.
			 info) Ocmd: print 1st command without run
			       Dcmd: run 1st command & debug info & exit
			       Pcmd: print all command without run
			       Ecmd: run command, if error occurs then exit
			        cmd: run command, if error occurs then continue

			 info) @branch: current branch, @remote: current remote, @project: current project
			 info) use 'revv forall setgit' to apply specific gits, this setting is remained until reset.
			   ex) revv forall setgit        .                           # repo forall . (for current project)
			   ex) revv forall setgit sample/poky sample/meta-browser    # repo forall some projects (for only input projects)
			   ex) revv forall setgit                                    # reset, therefore all gits is applied

			   ex) revv forall branch        master                      # check if branch(master) exist
			   ex) revv forall Ebranch       master                      # check if branch(master) exist, if error occurred, will stop.
			   ex) revv forall Pbranch       master                      # print command without running
			   ex) revv forall Dbranch       master                      # print debug info with running 1st cmd
			   ex) revv forall branch        @branch                     # check if current branch is existed in remote
			   ex) revv forall branchlist                                # print all branches
			   ex) revv forall branchlist    '*my*'                      # print all branches including 'my'
			   ex) revv forall branchlist    mas                         # print all branches including 'mas'
			   ex) revv forall branchadd     new master                  # create branch 'new' based from 'master'
			   ex) revv forall branchadd     @branch master              # create branch as written in manifest revision from master
			   ex) revv forall branchaddpre  new_ @branch                # create branch with name of new_<current_branch> from current
			   ex) revv forall branchaddpost _new @branch                # create branch with name of <current_branch>_new from current
			   ex) revv forall branchaddpost _new master                 # create branch 'master_new' from 'master'
			   ex) revv forall branchdel     master                      # delete branch 'master'
			   ex) revv forall branchdel     @branch                     # delete current branch (current remote branch)
			   ex) revv forall branchdelpre  new_ @branch                # delete branch with name of new_<current_branch> from current
			   ex) revv forall branchdelpost _new @branch                # delete branch with name of <current_branch>_new from current

			   ex) revv forall project                                   # check if projects exist listed in manifest
			   ex) revv forall projectadd    parent                      # add projects listed in manifest
			   ex) revv forall projectdel                                # list up all url can delete the git

			   ex) revv forall accessurl     @project                    # list up all url can access setting
EOF
            return 0
    ;; setgit)  info "setgit is delivered to 'repo forall <git list>', this setting is sustain until reset it"
                echo "flow) cat ${REPPFILE_CSV} |awk -F'|' {'print \$7'} > project.list"
                echo "flow) revv forall setgit \$(cat project.list) #select gits"
                echo "flow) revv forall Pbranch master #do job for any selected gits"
                echo "flow) revv forall setgit #reset, remove selected git setting"

                echo "flag_forall=${@:2} #print selected gits" ; #setgit is all next cmd from @:2
                source  <(echo 'flag_forall="${@:2}"'); return 0
    ;;   branch*|?branch*) :
    ;; project*|?project*) :
    ;;   access*|?access*) :
    ;;                  *)  err "please check usage: not registerd cmd, use 'revv forall help' "; return 1
    esac

    set -o noglob
    local tempr=/tmp/revv.ret
    if [ -f "${tempr}" ]; then rm -f "${tempr}"; touch "${tempr}"; fi
    #test case all) revv forall branchlist, gitt branch list '*', revv forall branchlist '*mas*'
    [[ "${target}" =~ "*" ]] && clog "[warn]" "asterisk * is not permitted in gerrit, automatically removed"
    case ${cmd::1} in
      O|D) repo forall ${flag_forall}                   -evcj1 bash 'revvscript.sh' $cmd ${target//\*/} ${source} 2>/dev/null
    ;;  E) ## if missing-project exists, repo forall -e option cannot stop bash subprocess, so continue to end
           err $(repo forall -c '') #only print log: skipping project
           repo forall ${flag_forall} --ignore-missing -evcpj1 bash 'revvscript.sh' $cmd ${target//\*/} ${source} 2>/dev/null
    ;;P|*) repo forall ${flag_forall}                   -vcpj4 bash 'revvscript.sh' $cmd ${target//\*/} ${source}
    esac

    set +o noglob
    #supress show result msg, only E|NONE type show log.
    case ${cmd::1} in  P|O|D) return 0; esac

    read -p $'\n\nshow result log: [ctrl+c: exit | enter: continue]? '
    bar inline ""
    cat ${tempr} |grep --color=always FAIL | tee /dev/tty | wc -l
    bar inline ""
    cat ${tempr} |grep --color=always OKAY | tee /dev/tty | wc -l
    #pr -2 -t <(cat ${tempr} |grep FAIL)
}


function revvshowcmd(){
## ---------------------------------------------------------------------------
# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local cmd=$1
    local server=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} http)
    local sub=$(revvserver_item ${subcmd:-${GITT_REMOTE:-${REPP_REMOTE}}} sub)
    local key=$(revvserver_item $sub pass)
    local user=$(revvserver_item $sub user)

    local usercmd=${2-${USER}}
    local oriproject=${3:-${GITT_PROJECT:-${REPP_PROJECT}}}
    local gitproject=${oriproject//'/'/'%2F'}
    #local branch=$4

    [ -z "$user" ] && user=$ACCOUNT
    case ${cmd} in
       help)    cat <<-EOF
				usage) revv cmd help                                    #show account info from gerrit server
				usage) revv cmd <server> <account> <gitproject>         #make gerrit POST command
				   ex) revv cmd eu joongkeun.kim mustang/tm/src         #make gerrit POST command with parameter
				   ex) revv cmd eu joongkeun.kim
				   ex) revv cmd eu
				   ex) revv cmd
EOF
            bar outline "info gerritserver: ex) show gerrit account"
            showRUN curl -su ${user}:${key} ${server}/a/accounts/?suggest\&q=${usercmd} |more

    ;; *)
            bar outline "show gerrit account commands"
            cat <<-EOF
			## check if <user> account is existed           ex) curl -su ${user}:${key} ${server}/a/accounts/?suggest\&q=${usercmd}| more
			## list group <user> belongs to                 ex) curl -su ${user}:${key} ${server}/a/accounts/${usercmd}/groups |sed '1d'| jq  '.[].name'| sort |more
			## find group which has string <group-name>     ex) curl -su ${user}:${key} ${server}/a/groups/?m=<group-name>

			## show group member for <group-name>           ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/members?recursive
			## list sub-group in <group-name>               ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/groups/
			## add account to group                         ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/members/${usercmd} -X PUT
			## check account is existed in <group-name>     ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/members|grep ${usercmd}
			## remote accout from group                     ex) curl -su ${user}:${key} ${server}/a/groups/<group-name>/members/${usercmd} -X DELETE
			## get ssh-key for specific account             ex) curl -su ${user}:${key} ${server}/a/accounts/${usercmd}/sshkeys
EOF
            bar outline "show gerrit project which name has <project-name>"
            cat <<-EOF
			##find git project named <gitproject>           ex) curl -su ${user}:${key} ${server}/a/projects/?m=${gitproject:-"<project-name>"}
			##find labels, parents[id], basic info          ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}
			##find child projects of <project name>         ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/children/?recursive| sed '1d'| jq  '.[].name'
EOF
            bar outline "show gerrit branch which name has <branch-name>"
            cat <<-EOF
			##list branches including named <branch>        ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/branches/?m=<branch-name>
			##remove branch                                 ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/branches/<branch-name> -X DELETE
			##create branch with base revision              ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/branches/<branch-name> -H "Content-Type: application/json" --data '{"sha": "049405ab2885e6c6844b212f83b43f835c904"}'  -X PUT
EOF
            bar outline "show gerrit tag which name has ${tag}"
            cat <<-EOF
			##list tag named <tag-name>                     ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/tags?m=<tag-name>
			##show tag date, tag revision, committer        ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/tags/<tag-name>
EOF
            bar outline "show gerrit commit with branch info"
            cat <<-EOF
			##show commit msg with data, author, committer  ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/commits/<full-sha-code>
			##show branches that commit beloings to         ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/commits/<full-sha-code>/in
			##show files that commit has changed            ex) curl -su ${user}:${key} ${server}/a/projects/${gitproject:-"<project-name>"}/commits/<full-sha-code>/files
			##show all hashtaged commit                     ex) curl -su ${user}:${key} ${server}/a/changes/?q=hashtag
			##show hastag with HITT or TAT2                 ex) curl -su ${user}:${key} ${server}/a/changes/?q=hashtag:HITT+OR+hashtag:TAT2
EOF
    esac
}



function revvserverstatus(){
## ---------------------------------------------------------------------------
# find replication server
# $1 server-url
# $2 port-number
    local server_port=${REPP_URL#*@}
    local server=${1:-${server_port%:*}}
    local user=${2:-${USER}}
    local port=${3:-$(echo ${server_port} | grep -oP '(?<=:)[0-9]+(?=/)')}

    if [ -z "${server}" ] || [ -z "${port}" ] ; then info "usage) revv server status vgit.lge.com 29999"; return 0;fi
    ping $server -s 1016 -c 4 -A
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    if [ $? -ne 0 ]; then continue; fi
    ssh ${user}@$server -p $port -o ConnectTimeout=2 -o ConnectionAttempts=1 gerrit show-caches
    if [ $? -ne 0 ]; then continue;fi
    printf "${yellow}--------------------------------------------------------------------------------------\n${NCOL}"
    echo "please check 1) ipg/ewma from ping, 2) AvgGet from gerrit connection"
}



function revvdebug(){
## ---------------------------------------------------------------------------

# read information from gerrit
# $1 account
# $2 server
# $3 gitproject
# $4 branch
    local server=$(revvserver_item ${1:-na} http)
    local key=$(revvserver_item $2 pass)
    local cmd=${2-${ACCOUNT}}
    local gitproject=${3//'/'/'%2F'}
    #local branch=$4

    case ${usercmd} in
       help)    cat <<-EOF
				usage) revv info                                   #show gerrit POST command
EOF
    ;; create|*new*)  showRUNQ echo "tempfunc"
    ;; list) echo tempfunc
    ;; *) echo "default functionality"
    ;; esac
}




##==========================================================================================================================
## below functions allow parameter "*, ?, +, ..." with non-globbing option
#__noglob() { $@; set +o noglob ;}
#must enable globbing within fuction at the begining.
#alias revv='set -o noglob; revv'
#alias gitt='set -o noglob; gitt'
#alias repp='set -o noglob; repp'

##==========================================================================================================================
function revv(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1: command
# $2: server
# $3: account

#set +o noglob
local MENU=(
"     info: shows repository info such as manifest path, repo cmd, tree of manifests, etc"
"      cmd: list useful command from gerrit"
"  connect: check if input account can access branch in gitproject on server"
"   server: check/add/listup predefined git server list or status"
"    debug: show variable REPO, REPP, REPPFILE, GITT variable used in script"
"   forall: repoforal for revv branch commands"
"     user: check if account is existed & get account info "
"   sshkey: get registered SSH-key for an account in server "
"    group: find/findmember/add/delete group by name"
"  project: find/add/delete project or change parents of project"
"   access: show access permission/group in specific git including child & parents"
"   commit: find commit in review system"
"   branch: find/add/remove branches by name"
)

local ret=0
case "$1" in
                     ##$1:cmd      ${@:2}:parameters
                        help)                                            reppmenu help "${MENU[@]}"
    ;;                    '')                                            reppmenu revv "${MENU[@]}"
    ;;                server)  [ "$2" = "status" ] && revvserverstatus "${@:3}" || revvserver "${@:2}"
    ;;                   cmd)      reppcheck_initvar reppgittrevv    &&  revvshowcmd "${@:2}"
    ;;               connect)      reppcheck_initvar gittrevv        &&  revvconnect "${@:2}"
    ;;                  info)      reppcheck_initvar gittrevv        &&  revvinfo  "${@:2}"
    ;;                 debug)      reppcheck_initvar gittrevv        &&  revvdebug "${@:2}"
    ;;                forall)      reppcheck_initvar repprevv        &&  revvforall "${@:2}"
    ;;                commit)      reppcheck_initvar reppgittrevv    &&  revvcommit "${@:2}"
    ;;               access*)      reppcheck_initvar repgittprevv    &&  revvaccess "${@:1}"
    ;;               branch*)      reppcheck_initvar reppgittrevv    &&  revvbranch "${@:1}"
    ;;              project*)      reppcheck_initvar repprevv        &&  revvproject "${@:1}"
    ;;    user|sshkey|group*)      reppcheck_initvar repprevv        &&  revvaccount "${@:1}"
esac
return $ret
}



##==========================================================================================================================
function gitt(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
#set +o noglob
local MENU=(
"   info: shows git path, gerrit info/url/remote, push command, commit info, sync time"
"   show: shows git (default 15) commits history, file change list"
"     go: move dir to repo root, git root, manifest dir or specific git"
" commit: git auto commit or show commit info (change file list and diff view)"
" branch: lookup, create, delete remote branch"
"   find: find string(changes) in commit history by multiple way."
"   diff: compare commit, branch with dir/file"
"  reset: reset git repository by choices"
"  debug: show GITT & REPO variable"
)
local ret=0
case "$1" in
    ##$1:below ${@:2}:parameters
          help)                                     reppmenu help "${MENU[@]}"
    ;;      '')                                     reppmenu gitt "${MENU[@]}"
    ;;    info)     reppcheck_initvar Oreppgitt &&  gittinfo
    ;;    show)     reppcheck_initvar gitt      &&  gittshow "${@:2}"
    ;;      go)     reppcheck_initvar gittgo    &&  gittgo "${@:2}"
    ;;  commit)     reppcheck_initvar gitt      &&  gittcommit "${@:2}"
    ;;  branch)     reppcheck_initvar gitt      &&  gittbranch "${@:2}"
    ;;    find)     reppcheck_initvar gitt      &&  gittfind "${@:2}"
    ;;    diff)     reppcheck_initvar gitt      &&  gittdiff "${@:2}"
    ;;   reset)     reppcheck_initvar gitt      &&  gittreset "${@:2}"
    ;;   debug)                                     gittdebug "${@:2}"
    ;;       *)     bar outline "call native git"
                    git "${@}";;
esac
return $ret
}



##==========================================================================================================================
function repp(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
#set +o noglob
local MENU=(
"    info: shows repository info such as manifest path, repo cmd, tree of manifests, etc"
"    show: shows uncommitted changes, top -1 commits, md5 sum for all repository"
"      go: move to repo root dir, manifest dir, git path nearby with similar depth"
"  commit: shows latest commits(git log -1) from all repository (default 20)"
"    find: search(list) string in all (repo revision, remote, branch, project, path)"
"  branch: show branch info, push remote branch, look-up remote-branch"
"    mani: repo manifest handling"
"    init: repo init with automatic options"
"    sync: repo sync with optimized multi-job and options"
"   reset: reset all repositories to original state"
"  ersion: check repo & python version and provide repo upgrade"
"  onnect: check the connection with git host server and accessibilty for branch of git"
"   debug: show variable REPO, REPP, REPPFILE, GITT variable used in script"
" install: check essential linux packages to run repp utility"
"  forall: run 'repo forall' from .repp/reppforall.csv(plz put your cmds before run)"
)

local ret=0
case "$1" in
     ##$1:cmd       check if validation                          ${@:2}:parameters
       help)                                                reppmenu help "${MENU[@]}"
    ;; '')                                                  reppmenu repp "${MENU[@]}"
    ;; info)        reppcheck_initvar repp              &&  reppinfo  "${@:2}"
    ;; show)        reppcheck_initvar repp              &&  reppshow "${@:2}"
    ;; go)          reppcheck_initvar repp              &&  reppgo "${@:2}"
    ;; commit)      reppcheck_initvar repp              &&  reppcommit "${@:2}"
    ;; find|list)   reppcheck_initvar repp              &&  reppfind "${@:2}"
    ;; branch)      reppcheck_initvar repp              &&  reppbranch "${@:2}"
    ;; mani)        reppcheck_initvar reppmani          &&  reppmani "${@:2}";
    ;; forall)      reppcheck_initvar repp              &&  reppforall "${@:2}";
    ;; init)                                                reppinit "${@:2}"
    ;; sync)                                                reppsync "${@:2}"
    ;; reset)       reppcheck_initvar repp              &&  reppreset "${@:2}"
    ;; version)     reppcheck_initvar repp              &&  reppversion "${@:2}"
    ;; connect)                                             reppconnect "${@:2}"
    ;; debug)                                               reppdebug "${@:2}"
    ;; install)                                             reppinstall
    ;; *)           bar outline "result of native repo";    repo "${@}"
esac
return $ret
}



function reppmenu(){
## ---------------------------------------------------------------------------
# main handler for this scriptre
# $1 command
# $2 help array for each command
local cmd="$1"
local MENU=( "${@:2}" )


printf ${green}
cat << PREFACE
==============================================================
 welcome to gitt & repp & review
 -------------------------------------------------------------
 command usage: ex) gitt, gitt info, gitt show [currnet git]
 command usage: ex) repp, repp info, repp show [default.xml]
 command usage: ex) revv
 ex) repp info, repp find [string], repp sync 16 --force-sync, etc
 ex) gitt info, gitt find [string], gitt show, etc
 ex) revv info
 help: http://collab.lge.com/main/x/xYv4j
==============================================================
PREFACE
printf ${NCOL}

if [ "$1" = "help" ]; then
    for m in "${MENU[@]}"; do clog "${m%%:*}" "${m##*:}"; done
    return 0;
fi

local COLUMNS=60
PS3=$'\e[00;35m=== Please input command! [enter:menu, number:choice, ctrl+c:exit] === : \e[0m'
select CHOICE in "${MENU[@]}"; do
    $cmd ${CHOICE%%:*}
    if [ -n "$?" ]; then return 1;fi
done
}



function reppdebug(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'

    #source로 묶어서 실행(변수, 따옴표/특수문자 처리를 shell terminal에서 입력한 그대로 동작시키기 위함, showRUN부분확인)
    source <(cat <<'EOL'
        bar inline "GITT_VARIABLE && REPP_VARIABLE for all repository"
        for var in \
        '${REVV_VER}' '${REVV_TAG}' '${REVV_SERVER}' \
        '${GITT_REMOTE}' '${GITT_PROJECT}' '${GITT_BRANCH}' '${GITT_PATH}' '${GITT_REVIEW}' '${GITT_URL}' \
        '${REPP_PATH}' '${REPP_ROOT}' '${REPP_INIT}' '${REPP_REMOTE}' '${REPP_PROJECT}' '${REPP_BRANCH}' '${REPP_URL}' '${REPP_REPOURL}' '${REPP_REF}' '${REPP_GROUPS}' '${REPP_COUNT}' \
        '${REPPFILE_STATUS}' '${REPPFILE_COMMIT}' '${REPPFILE_CSV}' '${REPPFILE_XML}' '${REPPFILE_MANI}'
        do
           dnlog "$var\t" $(eval echo $var)
        done

        for (( i=0; i < ${#REPP_REMOTELIST[@]}; i++ )); do
            dnlog "\${REPP_REMOTELIST[$i]}\t\t"   "${REPP_REMOTELIST[$i]}"
            dnlog "\${REPP_REVIEWLIST[$i]}\t\t"   "${REPP_REVIEWLIST[$i]}"
        done

        bar inline "[${GITT_PROJECT}] print repo variable"
        showRUN repo forall ${GITT_PROJECT:--r .*build.*} -ec 'echo ${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_UPSTREAM}, ${REPO_DEST_BRANCH}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'

        bar inline "[all repo] print repo variable"
        dnlog                '${REPO_I}/${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'
EOL
)
    ##run echo
}



function reppinstall(){
## ---------------------------------------------------------------------------
#install basic package for repp
if ! command -v curl > /dev/null ; then clog "curl need to be installed:" "sudo apt install curl"; fi
if ! command -v icdiff > /dev/null ; then clog "icdiff need to be installed:" "sudo apt install icdiff"; fi
if ! command -v jq > /dev/null ; then clog "jq need to be installed:" "sudo apt install icdiff"; fi
if ! command -v repo > /dev/null ; then clog "repo need to be installed:" "sudo apt-get install repo"; fi
if [[ ! $(column -V 2>/dev/null|grep util-linux) =~ "util-linux" ]] ;then clog "column need to reinstalled:";
    cat << GUIDE
    1. dpkg -l | grep -i util-linux ##find a nearest version
    2. wget https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.31/util-linux-2.31.tar.gz
    3. tar zxvf util-linux-2.31.tar.gz
    4. cd util-linux-2.31
    5. ./configure
    6. make column
    7. sudo cp .libs/column /usr/bin/column
GUIDE
fi
}



function gittdebug(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'

    if gittcheck_isgitproject; then
        reppcheck_initvar gitt
    fi

    source <(cat <<'EOL'
        bar inline "GITT_VARIABLE && REPP_VARIABLE for this git"
        for var in \
        '${GITT_PROJECT}' '${GITT_REMOTE}' '${GITT_BRANCH}' '${GITT_REVIEW}' '${GITT_URL}' '${GITT_PATH}'
        do
           dnlog "$var\t" $(eval echo $var)
        done

        bar inline "[${GITT_PROJECT}] print REPO variable using repo"
        showRUN repo forall ${GITT_PROJECT:+.} -c 'echo ${REPO_I}/${REPO_COUNT}, ${REPO_LREV}, ${REPO_REMOTE}, \
          ${REPO_UPSTREAM}, ${REPO_DEST_BRANCH}, ${REPO_RREV}, ${REPO_PROJECT}, ${REPO_PATH}, ${REPO_OUTERPATH}, ${REPO_INNERPATH}'

EOL
)
    ##run echo
}



function gitthelp(){
## ---------------------------------------------------------------------------
#reppdebug & gittdebug
#repo forall -c 'echo ${REPO_REMOTE}:${REPO_PROJECT}:${REPO_PATH}:${REPO_LREV}:${REPO_RREV}'

    case ${cmd} in
        help)   echo "print git help"
    ;;  area)   cat <<-EOF
				info) git area
				current : workspace      | index     |   local repository     remote repository
				-----------------------------------------------------------------------------------------------------
				          working area   | cached    |   history              remote
				          unstaged       | staged    |   commit
				          untracked      | tracked   |   tree

EOF
    ;;     *)   echo cat <<-EOF
				usage) gitt help area #show git area
				usage) gitt reset     #show detail reset commands
EOF
esac
}



##============================================================================
## Main
##============================================================================
REVV_VER=
GITT_REMOTE= &&GITT_PROJECT= &&GITT_BRANCH= &&GITT_REVIEW= &&GITT_URL= &&GITT_PATH=
##REPP_PATH=.repo/manifests, REPP_ROOT=src root, REPP_COUNT=total repo count, REPP_CMD=repo command
###REPP_REMOTE=manifest remote, REPP_URL=manifest git url, REPP_BRANCH=manifest branch, EPP_REPOURL=repo url, REPP_REF=reference path, REPP_GROUPS=group option when repo init,
REPP_ROOT= &&REPP_PATH= &&REPP_COUNT= &&REPP_CMD=
REPP_REMOTE= &&REPP_PROJECT= &&REPP_URL= &&REPP_BRANCH= REPP_REPOURL= &&REPP_REF= &&REPP_GROUPS=
REPP_REMOTELIST=()
REPP_REVIEWLIST=()
REPP_PATH_ALL=()

#source로 실행되었는지, call로 실행되었는지 판단
(return 0 2>/dev/null) && sourced=true || sourced=false
if $sourced; then REPP_INIT=0; #repp source 완료
    echo "[WELCOME] repp & gitt utility is applied for current shell";
else err "you must run repp using 'source repp'"; fi

# #repp flow
# 1. source repp로 현재 shell에 repp 적용
# 2. 이후 repp 함수에서 repp info와 같이 직접명령을 실행하거나, 아니면 menu를 통해서 실행
# 3. reppcheck_initvar에서 입력된 명령에 따라 repp,gitt,revv 대한 설정
# 4. repp_initvarr를 통한 repp환경 설정, REPP_INIT 변수를 설정함으로 초기화가 잘되었음을 표시한다.
# *  REPP_INIT=0 source됨, REPP_INIT=1 repo init상태, REPP_INIT=2이면 repp script 초기화완료, REPP_INIT=3 repp_initdb로 db까지 초기화 완료
# 5. repp find 명령을 넣으면 repp함수에서 find 명령인 확인하여 reppfind를 호출하는 방식으로 구동된다.