#!/bin/bash
# ===============================================================================
#  mail: joongkeun.kim@lge.com, av9300@gmail.com
#  this file should be sourced early step in script: source ./prelibrary
# ===============================================================================
#
#### ============================================================================
#### predefined variable
#### ============================================================================
## color definition, BOLD is brighter
## 0|1 = normal|bold;  30:black ~ 37:white
red='\e[0;31m';     RED='\e[1;31m';     green='\e[0;32m';       GREEN='\e[1;32m';
yellow='\e[0;33m';  YELLOW='\e[1;33m';  blue='\e[0;34m';        BLUE='\e[1;34m';
magenta='\e[0;35m'; PURPLE='\e[1;35m';  cyan='\e[0;36m';        CYAN='\e[1;36m';
NCOL='\e[0m';       outline=${cyan};    inline=${yellow};

file_error=~/.repoconfig/repo.error
export PS4='| + '

## ---------------------------------------------------------------------------
# log message to stderr
# $1: message
_space="--------------------------------------------------------------------------------------"
_line="--------------------------------------------------------------------------------------"

lineup="￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣"
linedn="______________________________________________________________________________________"
linemi="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
linedb="〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓"
linewave="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
linedebug="DEBUG ############################################################################################################"
## ---------------------------------------------------------------------------
## one-line function : 간단한 공용함수
## fuction has the captital : 외부에서 호출하지 않아야 하는 함수
## fuction has the only lowcase  : 외부에서 호출이 예상되는 함수
## dnlog, dbar, log can printf special charactor >> << | || , etc
wave()    { printf "${linewave}\n";}
log()     { printf "%b\\n" "${*}" ;}
dnlog()   { printf "%b\\n" "${YELLOW}$1 ${NCOL} ${@:2}";}
dlog()    { printf "%b" "${yellow}$1 ${NCOL} ${@:2}";}
clog()    { log "${cyan}$1 ${NCOL} ${@:2}"  ;}
info()    { log "${GREEN}INFO: ${NCOL} ${*}"  ;}
warn()    { log "${YELLOW}WARN: ${NCOL} ${*}" ;}
err()     { log "${RED}ERROR: ${NCOL} ${*}" > /dev/stderr ;}

#${2:+[$2] }: $2 번째 인자가 존재하면 '[$2] '를 사용
#${_line:(${2:+3}+${#2})}: $2 인자가 존재하면, '[] '표시를 위해 '---' 3글자를 건너띄어라
## supprort 2 _line type: bar inline, bar outline
## bar [inline|outline] "text1"
bar()    { printf "\n${!1}%s%s ${NCOL}\n" "${2:+[$2] }" "${_line:(${2:+3}+${#2})}" ;}
## bbar cyan "text1" "text2\t\n"
bbar()  { printf "${!1}%s%s ${NCOL}%b" "${2:+$2 }" "${_space:(${2:+3}+${#2})} " "$3" ;}
under()  {
    local temp="${1}" ; local ret=''
    if [ "${1:(-2)}" = "\n" ]; then temp=${temp::-2}; ret="\n"; fi
    printf "\n${green}〓〓〓   ${CYAN}%b${green}\n%b${NCOL}" "${temp}" "${linedb}${ret}";
}
#usage
# start: laptime reset;
#   lap: laptime
laptime() {  local _now=$(date +%s.%N);
    [[ $1 == reset ]] && { _lapn=0; _lapc=$_now; return; }
    echo "<<<< $(( _lapn++ )) [ $(echo "$_now - $_lapc" | bc) ]";
}

mark=('/' '-' '\' '|')
#progress는 반복문안에서 호출되어야 함.
#                    색상 시계 문자열    문자열 |  제목       시계                   내용
progress()  { printf "${!1}%s%s ${NCOL}%b\r" "${2:+$2 }" "${mark[$((count%4))]}" "$3" ;}

showcolor(){
    printf "${red}%8s\t%-24s${NCOL}\n"   "red"     "abcdefg 0123456789 ---- ===="
    printf "${RED}%8s\t%-24s${NCOL}\n"   "RED"     "abcdefg 0123456789 ---- ===="
    printf "${green}%8s\t%-24s${NCOL}\n" "green"   "abcdefg 0123456789 ---- ===="
    printf "${GREEN}%8s\t%-24s${NCOL}\n" "GREEN"   "abcdefg 0123456789 ---- ===="
    printf "${yellow}%8s\t%-24s${NCOL}\n" "yellow" "abcdefg 0123456789 ---- ===="
    printf "${YELLOW}%8s\t%-24s${NCOL}\n" "YELLOW" "abcdefg 0123456789 ---- ===="
    printf "${blue}%8s\t%-24s${NCOL}\n"  "blue"    "abcdefg 0123456789 ---- ===="
    printf "${BLUE}%8s\t%-24s${NCOL}\n"  "BLUE"    "abcdefg 0123456789 ---- ===="
    printf "${cyan}%8s\t%-24s${NCOL}\n"  "cyan"    "abcdefg 0123456789 ---- ===="
    printf "${CYAN}%8s\t%-24s${NCOL}\n"  "CYAN"    "abcdefg 0123456789 ---- ===="
    printf "${magenta}%8s\t%-24s${NCOL}\n" "magenta" "abcdefg 0123456789 ---- ===="
    printf "${PURPLE}%8s\t%-24s${NCOL}\n" "PURPLE"  "abcdefg 0123456789 ---- ===="
}

showline(){
printf 'usage:        log "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t';         log "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:       dlog "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t';        dlog "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:      dnlog "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t';       dnlog "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:       clog "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t';        clog "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:       info "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t';        info "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:       warn "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t';        warn "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:        err "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t';         err "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:       wave "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t';        wave "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:      under "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t';       under "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage: bar inline "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t'; bar inline  "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:bar outline "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t'; bar outline "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
printf 'usage:bbar PURPLE "|HEAD $PPID" "BODY Hello World \\t\\tcharEND\\n":\t\t\t'; bbar PURPLE "|HEAD $PPID" "BODY Hello World \t\tcharEND\n"
}

#pCount() { tee >(let sum="$(wc -l) + ${1:-0}"; clog "#count:" "$((sum<0?0:+sum))" ); }
pCount() { tee >(let sum="$(wc -l) + ${1:-0}"; clog "#count:" "$((sum<0?0:+sum))"; echo $sum > /tmp/pCount; ); }
math() {
    case $1 in
       help)  echo "usage: math [min|max|count|sum|avg|mid|all] -1 2 3 4 "
    ;;  min)  echo "${@:2}" | jq -s 'min'
    ;;  max)  echo "${@:2}" | jq -s 'max'
    ;;count)  echo "${@:2}" | jq -s 'length'
    ;;  sum)  echo "${@:2}" | jq -s 'add'
    ;;  avg)  echo "${@:2}" | jq -s 'add/length'
    ;;  mid)  echo "${@:2}" | jq -s '(sort|.[(length/2|floor)])'
    ;;    *)  echo "${@:2}" | jq -s '{ min:min, max:max, count:length, sum:add, avg: (add/length), median: (sort|.[(length/2|floor)]) }'
    esac
}


function getcurrFileName(){
## ---------------------------------------------------------------------------
echo "${BASH_SOURCE[0]}"
basename "$0"
}



function printToFILE(){
## ---------------------------------------------------------------------------
## printToFILE $(mktemp) title contents title-color
## $1: file, ## $2: head-msg, ## $3: content, ## $4: tail-msg

    case $1 in
    create) printfile=$(mktemp);;
    flush)
        if [ -f "$printfile" ]; then
            cat $printfile
            rm -f $printfile;
        fi ;;
    screen) printf "${yellow}%s %s ${NCOL}\n  %s\n" "$2" "${_line:${#2}}" "$3" ;;
    both) printf "${yellow}%s %s ${NCOL}\n  %s\n" "$2" "${_line:${#2}}" "$3" 2>&1 | tee -a $printfile;;
    *) printf "${yellow}%s %s ${NCOL}\n  %s\n" "$2" "${_line:${#2}}" "$3" >> $printfile;;
    esac
}


function showRUN(){ echo "\$> $@"; "$@" ; return $?; }
## ---------------------------------------------------------------------------
# show command before execution
# $1: command
# usage: showRUN repo sync -qcj${njobs:-16} --no-tags --no-clone-bundle $1


function showRUNQ(){
## ---------------------------------------------------------------------------
# show command before execution
# $1: command
# usage: showRUN repo sync -qcj${njobs:-16} --no-tags --no-clone-bundle $1
    if [ "$1" = y ]; then
        echo "\$ ${@:2}";
        read -p "choose [y:continue| ctrl+c:break] : "
        #if [ "$REPLY" == 'y' ]; then "eval ${@:2}" ; fi
        if [ "$REPLY" == 'y' ]; then eval "${@:2}" ; fi
    else
        echo "\$ ${@}";
        eval "${@}"
    fi
}


## ---------------------------------------------------------------------------
# $1: message
# $2: exit code
function die() { local m="$1"; local e=${2-1}; echo "$m"; exit $e; }
function is_root() { [ $(id -u) -eq 0 ] && echo 1 || echo 0 ;}


function getCurrentIP(){
## ---------------------------------------------------------------------------
# get current ip-address

    default_ip=172.0.0.1

    readarray -t a <<<"$(hostname -I) $SSH_CONNECTION"
    for ip in ${a[@]}; do
        max=$(grep -o $ip <<< ${a[*]} | wc -l)
        if [ $max -eq 2 ] ;then default_ip=$ip && echo $ip && break; fi
    done
}


function checkifSHA(){
## ---------------------------------------------------------------------------
# check if SHA
    case $1 in
      *[!0-9A-Fa-f]* | "" ) return 1 ;;
      * ) return 0;;
    esac
}


#### ============================================================================
#### predefined function
#### ============================================================================
function show_menu_do(){
## ---------------------------------------------------------------------------
# [call] show_menu_do "${INPUT}" #inputs should be divided with white spaces
# show the menu and make user select one from it.
    local lines
    #should be up one token
    lines=($1)
    if [[ ${#lines[@]} = 0 ]]; then
        echo "Not found"
        return 1
    fi
    local pathname
    local choice
    if [[ ${#lines[@]} > 1 ]]; then
        while [[ -z "$pathname" ]]; do
            local index=1
            local line
            for line in ${lines[@]}; do
                printf "%6s %s\n" "[$index]" $line
                index=$(($index + 1))
            done
            echo
            echo -n "Select one: "
            unset choice
            read choice
            if [[ $choice -gt ${#lines[@]} || $choice -lt 1 ]]; then
                echo "Invalid choice"
                continue
            fi
            pathname=${lines[$(($choice-1))]}
        done
    else
        # even though zsh arrays are 1-based, $foo[0] is an alias for $foo[1]
        pathname=${lines[0]}
    fi
     RET=$pathname
     return 0
}


function handler_args(){
## ---------------------------------------------------------------------------
# [call] handler_args $@  #$@ command paramter
# Hander Arguments

    local ret
    local options
    while getopts es: options 2> /dev/null
    do
       case $options in
          e) run_emul; ret=processed;;
          d) run_ddms; ret=processed;;
          \?) printf "${RED}Only -a,-e,-s are valid [$options] ${NCOL}\n"
            handler_menu
            ret=processed;;
       esac
    done

    if ! [ "$ret" = "processed" ]; then
        handler_menu
    fi
}


function print_menu() {
## ---------------------------------------------------------------------------
# called from run_menu

    local menu_items=("$@")
    local menu_limit=$(( ${#menu_items[@]} - 1 ))

    printf "${yellow}<< choose with arrow ←↑↓→ or num-key>>${NCOL}\n"
    printf "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
    for (( i = 0; i < $menu_limit; ++i ))
    do
        if [ "$i" = "${menu_items[$menu_limit]}" ]
        then  printf "${CYAN}->${NCOL} %02d: ${menu_items[i]}\n" "$i"
        else  printf "   %02d: ${menu_items[i]}\n" "$i"
        fi
    done
}


function __run_menu() {
## ---------------------------------------------------------------------------
# refresh menu when cursor move and number input

    menu_selected=""
    local menu_items=("$@" "0" ) #0 is endmark
    local menu_size=${#menu_items[@]}
    local menu_limit=$((menu_size - 1))

    clear
    print_menu "${menu_items[@]}"

    while read -rsn1 input
    do
        case "$input" in
            $'\x1B')  # ESC ASCII code (https://dirask.com/posts/ASCII-Table-pJ3Y0j)
                read -rsn1 -t 0.1 input
                if [ "$input" = "[" ]  # occurs before arrow code
                then
                    read -rsn1 -t 0.1 input
                    case "$input" in
                        A)  # Up Arrow
                            if [ "${menu_items[$menu_limit]}" -ge 1 ]
                            then
                                menu_items[$menu_limit]=$(( ${menu_items[$menu_limit]} - 1 ))
                                clear
                                print_menu "${menu_items[@]}"
                            fi;;
                        B)  # Down Arrow
                            if [ "${menu_items[$menu_limit]}" -lt "$menu_limit" ]
                            then
                                menu_items[$menu_limit]=$(( ${menu_items[$menu_limit]} + 1 ))
                                clear
                                print_menu "${menu_items[@]}"
                            fi;;
                    esac
                fi
                read -rsn5 -t 0.1  ;;# flushing stdin
            "")  # Enter key
                menu_selected=${menu_items[${menu_items[$menu_limit]}]}
                return $(( 11 + ${menu_items[$menu_limit]} ))
                ;;
            *)  menu_selected=${menu_items[$input]}
                return "$input"
                ;;
        esac
    done
}


function run_menu() {
## ---------------------------------------------------------------------------
# refresh menu when cursor move and number input

    menu_selected=""
    local menu_items=("$@" "0" ) #0 is endmark
    local menu_size=${#menu_items[@]}
    local menu_limit=$((menu_size - 1))

    clear
    print_menu "${menu_items[@]}"

    while read -rsn1 input
    do
        case "${input:0:1}" in
            $'\x1B')  # ESC ASCII code (https://dirask.com/posts/ASCII-Table-pJ3Y0j)
                echo $input
                read -rsn2 -t 0.1 input2
                case "$input2" in
                    [A)  # Up Arrow
                        if [ "${menu_items[$menu_limit]}" -ge 1 ]; then
                            menu_items[$menu_limit]=$(( ${menu_items[$menu_limit]} - 1 ))
                            clear
                            print_menu "${menu_items[@]}"
                        fi;;
                    [B)  # Down Arrow
                        if [ "${menu_items[$menu_limit]}" -lt "$menu_limit" ]; then
                            menu_items[$menu_limit]=$(( ${menu_items[$menu_limit]} + 1 ))
                            clear
                            print_menu "${menu_items[@]}"
                        fi;;
                esac

                read -rsn5 -t 0.1  ;; # flushing stdin
            "")  # Enter key
                echo $input
                menu_selected=${menu_items[${menu_items[$menu_limit]}]}
                return $(( 11 + ${menu_items[$menu_limit]} ))
                ;;
            ^[0-9]*$)
                echo $input
                read -rsn2 -t 1 input2
                echo [${input}][${input2}]
                menu_selected=${menu_items[${input}${input2}]}
                return "${input}${input2}"
                ;;
             *) read -rsn6   ;; # flushing stdin ;;
        esac
    done
}


## source로 실행되었으면 파일path를 출력하고 아니면 바로 해당함수를 호출해라.
[ "${BASH_SOURCE[0]}" = "${0}" ] && "$@" || echo "$(realpath $BASH_SOURCE) sourced"
