#!/bin/bash
# ==========================================================================
#  readme    : docker handler
#  mail      : joongkeun.kim@lge.com/av9300@gmail.com
# ==========================================================================


printf ${CYAN}
cat << PREFACE > /dev/null
============================================================================
---------------------------           +             ------------------------
-----------------------                                ---------------------
--------------------       WELCOME TO Docker Control      ------------------
============================================================================
PREFACE
printf ${NCOL}

##---------------------------------------------------------- DEBUG OPTION
#DEBUG=["echo -e"|:], : means no-operation
DEBUG=:
##============================================================================
## color definition, BOLD is brighter
red='\e[0;31m';  RED='\e[1;31m';  green='\e[0;32m';  GREEN='\e[1;32m';  yellow='\e[0;33m';   YELLOW='\e[1;33m';
blue='\e[0;34m'; BLUE='\e[1;34m'; cyan='\e[0;36m';   CYAN='\e[1;36m';   magenta='\e[0;35m';  NCOL='\e[0m';

#user setting
account=vc.integrator
home_dir="/data001/${account}"
user_id=$(id -u ${account})
group_id=$user_id
repo_url="10.158.4.241:8082"

#$1: command, #$2: conatainer name, #$3: container port, #$4: image name
cntr_cmd=$1; cntr_name=$2; cntr_port=$3; cntr_img=$4; cntr_file='';
#$DEBUG "cntr_cmd=[$1] cntr_name=[$2] cntr_port=[$3] cntr_img=[$4]"


##--------------------------- Menu Functions --------------------------------
##============================================================================
function echorun(){
## ---------------------------------------------------------------------------
# ex) echo docker images # must call without quote
    echo "\$ $@" ; "$@";
}

function download_dockerfile(){
## ---------------------------------------------------------------------------
    local clone_path printlist
    file_tar=$(mktemp)
    echo "please refer first: http://vgit.lge.com/na/gitweb?p=devops/scm/infra/devenv.git;a=tree;f=dockerfile;hb=HEAD";
    #git clone ssh://vgit.lge.com:29420/devops/scm/infra/devenv.git -b devops_release ${clone_path}
        
    printf "${yellow}\n==================================================================================================="
    printf "\n      %s" "currently supported dockerfiles for projects"
    printf "\n---------------------------------------------------------------------------------------------------\n\n${NCOL}"

    listpath=( $(git archive --remote=ssh://vgit.lge.com:29420/devops/scm/infra/devenv.git devops_release:dockerfile -o ${file_tar} && tar -tf ${file_tar} | grep '.*/.*/$' ))
    printlist=$(declare -p listpath | sed 's/.*(\(.*\)).*/\1/')
    printf "%s\n" ${printlist}
    #git archive --remote=ssh://vgit.lge.com:29420/devops/scm/infra/devenv.git devops_release:dockerfile/honda/tsu . | tar -x -C .
    read -p "input project [Number]: " reply
    if [ -z "$reply" ]; then echo you have to input image number; return; fi
    echorun  tar -xvf ${file_tar} ${listpath[${reply}]}
}


function list_repo(){
## ---------------------------------------------------------------------------
    local i=0 printlist
    # Read the files of a directory
    echo "curl -s -u 'admin'  ${repo_url}/artifactory/api/docker/devops-docker/v2/_catalog"
    listimg=( $(curl -s -u 'admin'  ${repo_url}/artifactory/api/docker/devops-docker/v2/_catalog  |sed -n '2p' | sed 's/.*\[\(.*\)\].*/\1/'| tr -d '[\[\]",]') )
    printlist=$(declare -p listimg | sed 's/.*(\(.*\)).*/\1/')
    printf "%s\n" ${printlist}

    if [ "${listimg[0]}" = "errors" ];then echo "please verify your ID/PW"; exit 0;fi
}



function docker_hub(){
## ---------------------------------------------------------------------------
    local repo_path=${repo_url}/devops-docker
    local path input_img input_tag
    printf "${red}========== "$1" ========== ${NCOL}\n"

    echorun docker login ${repo_url}/artifactory-devops-docker.jfrog.io

    case "${1%%(*}" in
        find)
            list_repo
            echo "[link] http://${repo_url}/ui/repos/tree/General/devops-docker%2Fcommon"
            ;;
        pull)
            list_repo
            read -p "must input image name [Number]: " input_img
            read -t 5 -p "default tag is latest otherwise input tag[2s]:" input_tag
            if [ -z "$input_img" ]; then echo you have to input image number; return; fi
            echorun docker pull ${repo_url}/devops-docker/${listimg[${input_img}]}:${input_tag:=latest}
            ;;
        push)
            list images
            read -p "must input Image [Name}: " cntr_img
            read -p "must input Repository path [ex) vw/imgname]: " path
            if [ "$cntr_img" = "" ];then echo "image is mandatory"; return 1; fi

            ##tag not latest: docker tag ${cntr_img} ${repo_path}/${path}:{tag_name}
            ##push not latest: docker push ${repo_path}/${path}:{tag_name}
            echorun docker tag ${cntr_img} ${repo_path}/${path}
            echorun docker push ${repo_path}/${path}
            ;;
         *) echo "[error] please check your command "
            ;;
    esac
}


function formatprint(){
## ---------------------------------------------------------------------------
    local index=0 line;

    #extract only "print format" from commands.
    list_port=()
    local cmd=( $(echo "$*" |sed 's/.*format *\({{.*}}|\).*/\1/;s/{{//g;s/}}|//g;s/\./ /g') )
    #declare -p cmd
    $DEBUG ${#cmd[@]}


    printf "${yellow}\n==================================================================================================="
    printf "\n      %s" "$*"
    printf "\n---------------------------------------------------------------------------------------------------\n\n${NCOL}"

    ##read as file from command result < <("$cmd")

    readarray -t arrayline < <("$@")
    arrayline=("${cmd[*]/%/|}" "${arrayline[@]}")
    #declare -p arrayline

    ##read one line from array "${arrayline[@]}"
    for line in "${arrayline[@]}"; do
        ##read one item from line "${line}"
        while read -d'|' item; do
            ##default handler for all items. remove spaces.
            width=-14;

            ##custom handler for each item.
            case ${cmd[${index}]} in
                ##width: display column width, minus left align, string replace
                CreatedAt)              width=-16; item=${item%:*};; #remove second
                Status)                 width=12;  item=${item/#Restarting*/NotWorking};; #change status Restarting to Notworking
                Ports)                  width=5;   temp=${item##*:}; item=${temp%->*};list_port+=(${item}) ;; #display port shortly
                Size)                   width=20;   item=${item/virtual/vir} ;;
                #Container size takes time too long, dont use size in docker ps
                #remove virtual memory
                Image|Repository)       width=18;  [[ $list_cmd != images ]] && item=${item##*/} ;; #remove Image path to make it short
                State)                  width=10;; #only display width control
                Tag)                    width=8;;
                Names)                  width=20;;
                ID)                     width=13;;
                *)                      width=16;;
            esac
            #printf "%d:" "${index}"
            printf "%${width}s|" "${item}"
            index=$(( ++index % ${#cmd[@]} ))
        done <<< "${line}"
        printf "\n--------------------------------------------------------------------------------------------------\n"
    done
}


function list(){
## ---------------------------------------------------------------------------
    $DEBUG "[$1] [$2] [$3]"
    list_cmd=$1
    case $list_cmd in
        ##width: display column width, minus left align, string replace
        images) formatprint docker images --format '{{.CreatedAt}}|{{.Size}}|{{.ID}}|{{.Tag}}|{{.Repository}}|' ${@:2};;
        ps) if [ "$2" = "--size" ]; then 
                echo "Wait 10s... to get size of container!!"
                formatprint docker ps --format '{{.CreatedAt}}|{{.Ports}}|{{.State}}|{{.Status}}|{{.Size}}|{{.ID}}|{{.Names}}|{{.Image}}|' ${@:2}; 
            else 
                formatprint docker ps --format '{{.CreatedAt}}|{{.Ports}}|{{.State}}|{{.Status}}|{{.ID}}|{{.Names}}|{{.Image}}|' ${@:2}; 
            fi;;
        *)  formatprint docker images --format '{{.CreatedAt}}|{{.Size}}|{{.ID}}|{{.Tag}}|{{.Repository}}|' ${@:1}; 
            formatprint docker ps --format '{{.CreatedAt}}|{{.Ports}}|{{.State}}|{{.Status}}|{{.Names}}|{{.Image}}|' ${@:1}; 
            ;;
    esac
}


function hello(){
## ---------------------------------------------------------------------------
    local tmppath

    printf "${red}========== "${FUNCNAME[0]}" ========== ${NCOL}\n"
    DOC_F=dockerfile.hello
    echo "make simplest dockerfile for test"
    echo "FROM ubuntu:18.04" > $DOC_F
    echo 'ENTRYPOINT ["/bin/bash", "-c"]' >> $DOC_F
    echo 'CMD "echo HelloWorld!"' >> $DOC_F

    tmppath=$(readlink -f $DOC_F);
    if [ "${tmppath%/*}" = "${HOME}" ];then
        echo "You must move your [$DOC_F] to other dir not in HOME. " && exit 0;
    fi
    docker build -f $DOC_F -t $DOC_F .
    echo "please find generated dockerfile ${DOC_F}: "
    echo
    readlink -f $DOC_F
    return
}


function build(){
## ---------------------------------------------------------------------------

    local tmppath
    printf "\nplease refer current images when building images\n"    
    list images

    printf "${red}========== "${FUNCNAME[0]}" ========== ${NCOL}\n"
    local today=$(date +"%y%m%d%H")

    printf "\n\nplease input your own input or use default !!!\n"
    read -p "input Dockerfile [FileName| Enter:Dockerfile]: " cntr_file
    read -p "input Image [Name(lowercase)| Enter:$today]: " cntr_img

    if [ "$cntr_file" = "" ];then cntr_file="Dockerfile"; fi
    tmppath=$(readlink -f $cntr_file);
    if [ "${tmppath%/*}" = "${HOME}" ];then
        printf "${red}This jois is not permitted in $HOME directory.${NCOL}\n" 
        printf "make new dir, place [$cntr_file] there and continue" && exit 0;

    fi
    if [ "$cntr_img" = "" ];then cntr_img=$today; fi
    docker build -f ${cntr_file} -t ${cntr_img,,} . "$@" |& tee -a log.docker
}


function start(){
## ---------------------------------------------------------------------------
    $DEBUG "$LINENO:[$cntr_cmd] [$cntr_name] [$cntr_port] [$cntr_img]"
    list

    local recent_name=$(docker images --format '{{.Repository}}' |sed -n '1p'| sed 's/.*\///p')

    printf "\n\nPlease Input Image, ID is more accurate!!!\n"
    read -p "input Image ID/Repository [ImageID| Repository| Enter:$recent_name]: " cntr_img
    read -p "input Container [Name| Enter:$recent_name]: " cntr_name
    if [ "$cntr_img" = "" ];then cntr_img=${recent_name}; fi
    if [ "$cntr_name" = "" ];then cntr_name=${recent_name}; fi

    if [ "$1" = "run" ];then
        printf "${red}========== "$1" ========== ${NCOL}\n"
        echorun docker run -dit --name ${cntr_name} ${cntr_img} /bin/bash -c 'echo helloworld'
        return 0
    fi

    local i=7000
    while (( i < 10000 )); do
        if [[ ! "${list_port[*]}" =~ "$i" ]]; then cntr_port="$i"; break; fi
        ((i=i+10))
    done

    # create dirs&files in advanced, if not, these dir&file is created for root account.
    sudo -u ${account} mkdir -p ${home_dir}/Docker_MountDIR ${home_dir}/mirror ${home_dir}/.jfrog
    touch ${home_dir}/.ssh ${home_dir}/.profile ${home_dir}/.bashrc ${home_dir}/.gitconfig 

    ## warning
    ## if mount with ro, file is another copy from start
    ## if mount with ro, dir is ro permissioned from start
    docker run                                                                  \
        -dit --init --privileged --cap-add=ALL --restart="always"               \
        --name ${cntr_name}                                                     \
        -u ${user_id}:${group_id}                                               \
        -p ${cntr_port}:22                                                      \
        -v /etc/group:/etc/group:ro                                             \
        -v /etc/passwd:/etc/passwd:ro                                           \
        -v /etc/shadow:/etc/shadow:ro                                           \
        -v /etc/timezone:/etc/timezone:ro                                       \
        -v /etc/localtime:/etc/localtime:ro                                     \
        -v /etc/ssh:/etc/ssh:ro                                                 \
        -v /usr/local/bin:/usr/local/bin:ro                                     \
        -v /usr/bin/git-lfs:/usr/bin/git-lfs:ro                                 \
        -v /lib/modules:/lib/modules:ro                                         \
        -v ${home_dir}/.profile:${home_dir}/.profile:rw                         \
        -v ${home_dir}/.bashrc:${home_dir}/.bashrc:rw                           \
        -v ${home_dir}/.gitconfig:${home_dir}/.gitconfig:rw                     \
        -v ${home_dir}/.ssh:${home_dir}/.ssh:rw                                 \
        -v ${home_dir}/.jfrog:${home_dir}/.jfrog:rw                             \
        -v ${home_dir}/mirror:${home_dir}/mirror:rw                             \
        -v ${home_dir}/Docker_MountDIR:${home_dir}/Docker_MountDIR:rw           \
        ${cntr_img} /bin/bash -c 'sudo service ssh start && /bin/bash'

        #if [ $? -eq 0 ]; then list ps; fi
    return 0
}


function stoprm(){
## ---------------------------------------------------------------------------
    local cmd=$1
    local param="${@:2}"
    local target
    [ -z "${param}" ] && list ps --all
    printf "${red}========== "stop & remove container" ========== ${NCOL}\n"
    echo "Multiple container can be input with space ex) cntr1 cntr2 cntr3"
    read -p "must input Container [Name| ID]: " target; 
    docker stop ${target}
    docker rm ${target}
    list ps --all
    
    read -p "continue to remove volume? [Name or ID| ctrl+c:exit]: " target
    docker volume rm --force ${target}
}


function rmi(){
## ---------------------------------------------------------------------------
    local cmd=$1

    list images
    printf "${red}========== "$cmd" ========== ${NCOL}\n"
    printf "[docker rmi] command will be executed!! otherwise use [dock stop]\n"
    
    read -p "must input Image ID/Repository or enter [ImageID| Repository]: " cntr_img
    docker rmi ${cntr_img}

    if [ $? -ne 0 ]; then
        read -p "docker rmi ${cntr_img} --force [Enter:${cntr_img}| Ctrl+C]: "
        if [ "$REPLY" = "" ]; then
            docker rmi ${cntr_img} --force
        fi
    fi
}



function exec(){
## ---------------------------------------------------------------------------

    list ps --all
    printf "${red}========== "${FUNCNAME[0]}" ========== ${NCOL}\n"
    local recent_name=$(docker ps --format '{{.Names}}' |sed -n '1p'| sed 's/.*\///p')

    read -p "must input Container [ID| Name| Enter:$recent_name]: " cntr_name
    if [ -z "$cntr_name" ];then cntr_name=${recent_name}; fi
    printf '%s\n' \
    "docker exec -it ${cntr_name} /bin/bash"
    #"docker exec -w ${home_dir} -it ${cntr_name} /bin/bash"

    read -p "please confirm to run [Enter] :"
    case ${REPLY} in
    "") docker exec -it ${cntr_name} /bin/bash ;;
    #2) docker exec -w ${home_dir} -it ${cntr_name} /bin/bash;;
    #3) docker exec -w ${home_dir} -it ${cntr_name} /bin/bash;;
    esac
}


function debug(){
## ---------------------------------------------------------------------------
    local reply
    list ps --all
    printf "${red}========== "${FUNCNAME[0]}" ========== ${NCOL}\n"
    read -p "must input Container [Name]: " cntr_name
    printf '%s\n' \
    "1) docker logs --tail 100 --follow --timestamps ${cntr_name}"\
    "2) docker logs --tail 100 --follow --timestamps ${cntr_name}"

    read -p "input Your choice [Number]: " reply
    case ${reply} in
    1) docker logs --tail 100 --follow --timestamps ${cntr_name} ;;
    esac
}


function clean(){
## ---------------------------------------------------------------------------
    temp_img=$(docker ps | awk "/${cntr_name}/ {print \$2}" | grep -v ID)
    echo    "############### [WARNING] ###############"
    echo    "!! [docker system prune] command will be executed !!
    docker network prune
    docker volume prune
    docker container prune
    docker image prune
    "
    printf "current total docker container is: " && docker ps --all -q | wc -l
    printf "current total docker images is: "    && docker images --all -q | wc -l

    #ask confirm in docker system prune
    docker system prune --all
    
    printf "\nprune is done\n"
    printf "current total docker container is: " && docker ps --all -q | wc -l
    printf "current total docker images is: "    && docker images --all -q | wc -l

    exit 0
}


function info(){
## ---------------------------------------------------------------------------
    read -p "docker info  [enter:continue| ctrl+c:exit]: "
    docker info
    exit 0
}


function copy(){
## ---------------------------------------------------------------------------
    if [ -z "${cntr_name}" ];then 
        list ps --all
	read -p "must input Container [Name| ID]: " cntr_name;
    fi
    echorun docker exec -t $cntr_name /bin/bash -c 'tree -aL 2 /data001/vc.integrator'
    printf "\n${yellow}==== docker copy sample commands ====${NCOL}\n"
    printf "\n${YELLOW} ls docker files ${NCOL}\n"
    echo "docker exec -t $cntr_name /bin/bash -c 'ls -al /data001/vc.integrator'"
    printf "\n${YELLOW} copy between host & docker ${NCOL}\n"
    echo "docker cp $cntr_name:${home_dir}/.bashrc ./target_file"
    echo "docker cp source_file $cntr_name:${home_dir}/target_file"
    exit 0
}

function help(){
## ---------------------------------------------------------------------------
echo -e "
${green}
    example step:
    make image and start: build(image)>> start(container)>> exec(attach)>> stop(container)>> remove(image)
    get image and start : pull(image)>> start(container)>> exec(attach)>> stop(container)>> remove(image)
    make test image & start: hello(image)>> start(container)>> exec(attach)>> ...
    attach legacy container: list(img&cntr)>> exec(attach)>> ...
    find img in artifactory: find(search)>> ...

${yellow}
    command category:
    common) list, clean, help
    image) image/images --all, build, hello, find, pull, push, rmi/remove, down
    container) ps/ps --all, start, run, exec, debug, stop/rm

${cyan}
    command usage:
    dock cmd: ex) dock list
    dock >> select menu#: ex) dock >> input #1
${NCOL} "

    read -p "docker help  [enter:continue| ctrl+c:exit]: "
    docker help
}

MENU=(
    'list(img&cntr)' 'images(list img)' 'ps(list cntr)' 'build(dockerfile)'  
    'start(run++ img)' 'exec(attach cntr)' 'hello(testimg)' 'run(just run)' 
    'stop(&rm ctnr)' 'remove(img)' 'clean(prune all)' 'debug(log)' 'find(search)'
    'pull(from arti)' 'push(to arti)' 'down(dockerfile)' 'copy(fromto host)' 'help'
)

function handler_menu(){
## ---------------------------------------------------------------------------
printf ${green}
cat << PREFACE
===================================================================================================
 the menu for docker tools
 help: http://collab.lge.com/main/x/8X_taQ
 -------------------------------------------------------------------------------------------------
 account=$account, user_id=$(id -u ${account}), group_id=$user_id
 home_dir=${home_dir}"
 -------------------------------------------------------------------------------------------------
 o step: build/pull(image)>> start(container)>> exec(attach)>> stop(container)>> remove(image)
 o step: hello(image)>> run(container)>> exec(attach)>> ...

 supported command category: ex) dock list
 common) list, clean, help
 image) image/images --all, build, hello, find, pull, push, rmi/remove
 container) ps/ps --all, start, run, exec, debug, stop/rm
===================================================================================================
PREFACE
printf ${NCOL}

    #local COLUMNS=30
    #local columns="$(tput cols)"
    #multi-line PS3
    PS3=$'\e[00;34m------------------------------------------------------------------------------------------\e[0m'\
$'\nstep: build/pull(image)>> start(container)>> exec(attach)>> stop(container)>> remove(image)'\
$'\nstep: hello(image)>> run(container)>> exec(attach)>> ...'\
$'\n\e[00;35m=== Please input command! [Number:menu, Ctrl+c:exit] === : \e[0m'

    select CHOICE in "${MENU[@]}"
    do
        handle_commands "${CHOICE%%(*}";
    done    
}


function handle_commands(){
## ---------------------------------------------------------------------------
local ret=0
    case "$1" in
        list) list "${@:2}"                                                 ;;
          images|ps) list "${@:1}"                                          ;;
          image) list images "${@:2}"                                       ;;
        build) build "${@:2}"                                               ;;
          hello) hello;                                                     ;;
        start) start;                                                       ;;
          run) start run                                                    ;;
          exec) exec                                                        ;;
          debug) debug                                                      ;;
        stop|rm) stoprm "${@:1}"                                            ;;
          rmi|remove) rmi                                                   ;;
          clean) clean;                                                     ;;
        pull|push|find) docker_hub "${@:1}"                                 ;;
          down) download_dockerfile  "${@:2}"                               ;;
        copy) copy "${@:2}"                                                 ;;
        info|status) info "${@:2}"                                          ;;
        help) help "${@:2}"                                                 ;;
        "") handler_menu "${@}"                                             ;;
        *) docker "${@}"
          return $ret;;
    esac
}


#for source script,
function ____dock(){
## ---------------------------------------------------------------------------
    echo "this is called from sourced dock script"
    handle_commands $@
}

##============================================================================
## Main
##============================================================================
# check if called from source or not.
(return 0 2>/dev/null) && sourced=1 || sourced=0
if [ $sourced -eq 0 ]; then handle_commands $@;else echo "plz run without source." && return; fi
